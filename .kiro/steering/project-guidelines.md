# EAI Schema Toolkit - Kiro Steering 지침

## 프로젝트 개요
EAI Schema Toolkit은 엔터프라이즈 애플리케이션 통합을 위한 스키마 변환 및 검증 도구입니다. XML, JSON, YAML 형식 간의 변환과 실시간 협업 기능을 제공하는 완성된 프로덕션 레디 솔루션입니다.

## 핵심 아키텍처 원칙

### 1. 기술 스택 준수
- **백엔드**: Node.js + Express + TypeScript
- **프론트엔드**: Vanilla JavaScript (라이브러리 의존성 최소화)
- **실시간 통신**: Socket.IO
- **데이터베이스**: 파일 기반 저장소 (확장 가능)
- **배포**: GitHub Pages (프론트엔드) + Heroku (백엔드)

### 2. 코드 품질 표준
- **타입 안전성**: TypeScript 강제 사용, any 타입 금지
- **코드 스타일**: ESLint 규칙 준수
- **테스트 커버리지**: 새로운 기능은 반드시 단위 테스트 포함
- **문서화**: JSDoc 주석 필수, API 문서 업데이트

### 3. 보안 우선 원칙
- **입력 검증**: 모든 사용자 입력에 대한 엄격한 검증
- **SSRF 방지**: URL 기반 입력에 대한 화이트리스트 검증
- **XXE 공격 방지**: XML 파싱 시 외부 엔티티 비활성화
- **파일 업로드**: 허용된 MIME 타입과 확장자만 처리

## 개발 가이드라인

### 1. 새로운 기능 추가 시
```typescript
// 1. 서비스 레이어에 비즈니스 로직 구현
// src/services/NewFeatureService.ts

// 2. 라우터에 API 엔드포인트 정의
// src/routes/newFeature.ts

// 3. 컨트롤러에서 요청/응답 처리
// 적절한 에러 핸들링과 로깅 포함

// 4. 테스트 작성
// src/__tests__/services/NewFeatureService.test.ts
```

### 2. API 설계 원칙
- **RESTful 설계**: 표준 HTTP 메서드 사용
- **일관된 응답 형식**: 성공/실패 응답 구조 통일
- **에러 처리**: 명확한 에러 메시지와 HTTP 상태 코드
- **버전 관리**: API 버전 명시 (/api/v1/...)

### 3. 성능 최적화
- **비동기 처리**: async/await 패턴 사용
- **스트림 처리**: 대용량 파일 처리 시 스트림 활용
- **캐싱**: 적절한 캐싱 전략 적용
- **모니터링**: Prometheus 메트릭 수집

## 파일 구조 규칙

### 1. 디렉토리 구조
```
src/
├── routes/          # API 라우터
├── services/        # 비즈니스 로직
├── middleware/      # 미들웨어
├── utils/          # 유틸리티 함수
├── mcp/            # MCP 통합
└── __tests__/      # 테스트 파일
```

### 2. 명명 규칙
- **파일명**: PascalCase (서비스, 클래스), camelCase (유틸리티)
- **변수명**: camelCase
- **상수명**: UPPER_SNAKE_CASE
- **인터페이스**: I 접두사 (예: ISchemaValidator)

## 배포 및 운영

### 1. CI/CD 파이프라인
- **테스트**: 모든 PR에 대해 자동 테스트 실행
- **빌드**: TypeScript 컴파일 및 정적 분석
- **배포**: main 브랜치 머지 시 자동 배포
- **롤백**: 배포 실패 시 자동 롤백 메커니즘

### 2. 환경 관리
- **개발 환경**: 로컬 개발 서버
- **스테이징**: GitHub Actions 테스트 환경
- **프로덕션**: Heroku 배포 환경
- **환경 변수**: .env 파일 및 GitHub Secrets 활용

### 3. 모니터링 및 로깅
- **성능 모니터링**: Prometheus + Grafana
- **에러 추적**: Winston 로거 활용
- **헬스 체크**: /api/health 엔드포인트
- **메트릭 수집**: 응답 시간, 에러율, 처리량

## 협업 규칙

### 1. Git 워크플로우
- **브랜치 전략**: feature/기능명, bugfix/이슈번호
- **커밋 메시지**: Conventional Commits 형식
- **PR 리뷰**: 최소 1명의 리뷰어 승인 필요
- **머지 전략**: Squash and merge 사용

### 2. 이슈 관리
- **버그 리포트**: 재현 단계와 환경 정보 포함
- **기능 요청**: 사용자 스토리 형식으로 작성
- **라벨링**: 우선순위, 타입, 상태별 라벨 활용
- **마일스톤**: 릴리스 계획에 따른 마일스톤 설정

## 확장성 고려사항

### 1. MCP 통합
- **프로바이더 패턴**: 새로운 도구 통합 시 MCP 인터페이스 활용
- **플러그인 아키텍처**: 독립적인 모듈로 기능 확장
- **표준 인터페이스**: 일관된 API 설계

### 2. 스케일링 준비
- **마이크로서비스**: 서비스별 독립 배포 가능한 구조
- **컨테이너화**: Docker 지원 준비
- **로드 밸런싱**: 수평 확장 고려한 설계
- **데이터베이스**: 관계형 DB 마이그레이션 준비

## 보안 체크리스트

### 1. 입력 검증
- [ ] 파일 타입 검증 (MIME 타입, 확장자)
- [ ] 파일 크기 제한
- [ ] URL 입력 시 SSRF 방지
- [ ] XML 파싱 시 XXE 방지

### 2. 인증 및 권한
- [ ] API 키 기반 인증 (필요시)
- [ ] 레이트 리미팅 적용
- [ ] CORS 정책 설정
- [ ] 보안 헤더 설정 (Helmet.js)

### 3. 데이터 보호
- [ ] 임시 파일 자동 정리
- [ ] 민감 정보 로깅 방지
- [ ] HTTPS 강제 사용
- [ ] 환경 변수 보안 관리

## 성능 기준

### 1. 응답 시간
- **API 응답**: 95% 요청이 500ms 이내
- **파일 업로드**: 10MB 파일 기준 5초 이내
- **스키마 변환**: 1MB 스키마 기준 2초 이내

### 2. 처리량
- **동시 사용자**: 최소 100명 지원
- **파일 처리**: 시간당 1000개 파일 처리
- **WebSocket 연결**: 동시 50개 연결 지원

### 3. 가용성
- **업타임**: 99.9% 이상
- **에러율**: 1% 미만
- **복구 시간**: 장애 발생 시 5분 이내 복구

## 문서화 요구사항

### 1. 코드 문서화
- **JSDoc**: 모든 public 메서드에 JSDoc 주석
- **README**: 각 모듈별 README 파일
- **API 문서**: OpenAPI/Swagger 스펙 유지

### 2. 사용자 문서화
- **사용자 가이드**: 기능별 사용법 설명
- **API 레퍼런스**: 엔드포인트별 상세 설명
- **트러블슈팅**: 일반적인 문제 해결 방법

### 3. 운영 문서화
- **배포 가이드**: 단계별 배포 절차
- **모니터링 설정**: 메트릭 및 알림 설정
- **백업 및 복구**: 데이터 백업 절차

이 지침을 따라 EAI Schema Toolkit의 품질과 안정성을 유지하며 지속적인 개선을 추진해주세요.