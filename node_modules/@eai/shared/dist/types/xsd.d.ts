import { BaseSchema, SchemaType, TypeDefinition, Constraint, ValidationResult } from './index';
export interface XSDSchema extends BaseSchema {
    type: SchemaType.XSD;
    content: XSDContent;
}
export interface XSDContent {
    schema: XSDSchemaElement;
    elements: XSDElement[];
    attributes: XSDAttribute[];
    complexTypes: XSDComplexType[];
    simpleTypes: XSDSimpleType[];
    groups: XSDGroup[];
    attributeGroups: XSDAttributeGroup[];
}
export interface XSDSchemaElement {
    targetNamespace?: string;
    elementFormDefault?: XSDFormChoice;
    attributeFormDefault?: XSDFormChoice;
    blockDefault?: string;
    finalDefault?: string;
    version?: string;
    xmlns: Record<string, string>;
}
export declare enum XSDFormChoice {
    QUALIFIED = "qualified",
    UNQUALIFIED = "unqualified"
}
export interface XSDElement {
    name: string;
    type?: string;
    ref?: string;
    minOccurs?: number;
    maxOccurs?: number | 'unbounded';
    nillable?: boolean;
    abstract?: boolean;
    substitutionGroup?: string;
    default?: string;
    fixed?: string;
    form?: XSDFormChoice;
    block?: string;
    final?: string;
    complexType?: XSDComplexType;
    simpleType?: XSDSimpleType;
    annotation?: XSDAnnotation;
}
export interface XSDAttribute {
    name: string;
    type?: string;
    ref?: string;
    use?: XSDUse;
    default?: string;
    fixed?: string;
    form?: XSDFormChoice;
    simpleType?: XSDSimpleType;
    annotation?: XSDAnnotation;
}
export declare enum XSDUse {
    REQUIRED = "required",
    OPTIONAL = "optional",
    PROHIBITED = "prohibited"
}
export interface XSDComplexType extends TypeDefinition {
    abstract?: boolean;
    mixed?: boolean;
    block?: string;
    final?: string;
    content?: XSDComplexContent;
    attributes?: XSDAttribute[];
    attributeGroups?: XSDAttributeGroup[];
    anyAttribute?: XSDAnyAttribute;
    annotation?: XSDAnnotation;
}
export interface XSDComplexContent {
    type: XSDContentType;
    base?: string;
    elements?: XSDElement[];
    groups?: XSDGroup[];
    choice?: XSDChoice;
    sequence?: XSDSequence;
    all?: XSDAll;
}
export declare enum XSDContentType {
    EXTENSION = "extension",
    RESTRICTION = "restriction",
    SIMPLE_CONTENT = "simpleContent",
    COMPLEX_CONTENT = "complexContent"
}
export interface XSDSimpleType extends TypeDefinition {
    final?: string;
    restriction?: XSDRestriction;
    list?: XSDList;
    union?: XSDUnion;
    annotation?: XSDAnnotation;
}
export interface XSDRestriction {
    base: string;
    facets: XSDFacet[];
    enumeration?: string[];
    pattern?: string[];
    minInclusive?: string;
    maxInclusive?: string;
    minExclusive?: string;
    maxExclusive?: string;
    length?: number;
    minLength?: number;
    maxLength?: number;
    totalDigits?: number;
    fractionDigits?: number;
    whiteSpace?: XSDWhiteSpace;
}
export declare enum XSDWhiteSpace {
    PRESERVE = "preserve",
    REPLACE = "replace",
    COLLAPSE = "collapse"
}
export interface XSDList {
    itemType: string;
    simpleType?: XSDSimpleType;
}
export interface XSDUnion {
    memberTypes: string[];
    simpleTypes?: XSDSimpleType[];
}
export interface XSDFacet {
    type: XSDFacetType;
    value: string;
    fixed?: boolean;
    annotation?: XSDAnnotation;
}
export declare enum XSDFacetType {
    ENUMERATION = "enumeration",
    FRACTION_DIGITS = "fractionDigits",
    LENGTH = "length",
    MAX_EXCLUSIVE = "maxExclusive",
    MAX_INCLUSIVE = "maxInclusive",
    MAX_LENGTH = "maxLength",
    MIN_EXCLUSIVE = "minExclusive",
    MIN_INCLUSIVE = "minInclusive",
    MIN_LENGTH = "minLength",
    PATTERN = "pattern",
    TOTAL_DIGITS = "totalDigits",
    WHITE_SPACE = "whiteSpace"
}
export interface XSDGroup {
    name?: string;
    ref?: string;
    minOccurs?: number;
    maxOccurs?: number | 'unbounded';
    choice?: XSDChoice;
    sequence?: XSDSequence;
    all?: XSDAll;
    annotation?: XSDAnnotation;
}
export interface XSDChoice {
    minOccurs?: number;
    maxOccurs?: number | 'unbounded';
    elements: XSDElement[];
    groups: XSDGroup[];
    choices: XSDChoice[];
    sequences: XSDSequence[];
    any: XSDAny[];
}
export interface XSDSequence {
    minOccurs?: number;
    maxOccurs?: number | 'unbounded';
    elements: XSDElement[];
    groups: XSDGroup[];
    choices: XSDChoice[];
    sequences: XSDSequence[];
    any: XSDAny[];
}
export interface XSDAll {
    minOccurs?: 0 | 1;
    maxOccurs?: 1;
    elements: XSDElement[];
}
export interface XSDAny {
    namespace?: string;
    processContents?: XSDProcessContents;
    minOccurs?: number;
    maxOccurs?: number | 'unbounded';
}
export declare enum XSDProcessContents {
    STRICT = "strict",
    LAX = "lax",
    SKIP = "skip"
}
export interface XSDAttributeGroup {
    name?: string;
    ref?: string;
    attributes: XSDAttribute[];
    attributeGroups: XSDAttributeGroup[];
    anyAttribute?: XSDAnyAttribute;
    annotation?: XSDAnnotation;
}
export interface XSDAnyAttribute {
    namespace?: string;
    processContents?: XSDProcessContents;
}
export interface XSDAnnotation {
    documentation?: XSDDocumentation[];
    appInfo?: XSDAppInfo[];
}
export interface XSDDocumentation {
    source?: string;
    lang?: string;
    content: string;
}
export interface XSDAppInfo {
    source?: string;
    content: string;
}
export interface XSDParseOptions {
    resolveIncludes: boolean;
    resolveImports: boolean;
    validateSchema: boolean;
    processAnnotations: boolean;
    maxDepth: number;
    timeout: number;
}
export interface XSDParseResult {
    schema: XSDSchema;
    validation: ValidationResult;
    metadata: XSDParseMetadata;
}
export interface XSDParseMetadata {
    version: string;
    elementCount: number;
    typeCount: number;
    attributeCount: number;
    namespaceCount: number;
    includes: string[];
    imports: string[];
}
export interface XSDValidationOptions {
    checkReferences: boolean;
    validateTypes: boolean;
    checkConstraints: boolean;
    strictMode: boolean;
}
export interface XSDValidationError {
    code: XSDErrorCode;
    message: string;
    path: string;
    line?: number;
    column?: number;
    severity: 'error' | 'warning' | 'info';
}
export declare enum XSDErrorCode {
    INVALID_TYPE_REFERENCE = "INVALID_TYPE_REFERENCE",
    CIRCULAR_TYPE_DEFINITION = "CIRCULAR_TYPE_DEFINITION",
    INVALID_FACET_VALUE = "INVALID_FACET_VALUE",
    CONFLICTING_CONSTRAINTS = "CONFLICTING_CONSTRAINTS",
    INVALID_NAMESPACE = "INVALID_NAMESPACE",
    MISSING_REQUIRED_ATTRIBUTE = "MISSING_REQUIRED_ATTRIBUTE",
    INVALID_OCCURRENCE_CONSTRAINT = "INVALID_OCCURRENCE_CONSTRAINT",
    DUPLICATE_DEFINITION = "DUPLICATE_DEFINITION"
}
export interface XSDConversionOptions {
    preserveAnnotations: boolean;
    flattenHierarchy: boolean;
    generateOptionalElements: boolean;
    includeDocumentation: boolean;
}
export interface XSDToEAIMapping {
    elements: ElementMapping[];
    types: ComplexTypeMapping[];
    simpleTypes: SimpleTypeMapping[];
    attributes: AttributeMapping[];
}
export interface ElementMapping {
    xsdElement: string;
    eaiProperty: string;
    typeMapping: string;
    constraints: Constraint[];
}
export interface ComplexTypeMapping {
    xsdType: string;
    eaiEntity: string;
    propertyMappings: XSDPropertyMapping[];
}
export interface SimpleTypeMapping {
    xsdType: string;
    eaiType: string;
    restrictions: RestrictionMapping[];
}
export interface XSDPropertyMapping {
    xsdProperty: string;
    eaiProperty: string;
    transformation?: string;
}
export interface AttributeMapping {
    xsdAttribute: string;
    eaiProperty: string;
    defaultValue?: string;
}
export interface RestrictionMapping {
    xsdRestriction: XSDFacetType;
    eaiConstraint: string;
    value: any;
}
//# sourceMappingURL=xsd.d.ts.map