// OpenAPI → EAI 스키마 변환기
import { 
  SchemaConverter, 
  ConversionContext, 
  ConversionResult, 
  ConversionOptions,
  EAIEntity,
  EAIOperation,
  EAITypeDefinition,
  EAIBinding,
  EAIParameter,
  EAIProperty,
  OperationType,
  ParameterDirection,
  BindingType,
  TypeCategory,
  SecurityType,
  SourceMapping,
  ConversionError,
  ConversionWarning
} from '../types';
import { EAISchemaModel } from '../models/eai-schema';
import { SchemaType, OpenAPISchema, OpenAPIPath, OpenAPIOperation, OpenAPIComponent } from '@eai-toolkit/shared';
import { v4 as uuidv4 } from 'uuid';

/**
 * OpenAPI 스키마를 EAI 스키마로 변환하는 컨버터
 */
export class OpenAPIConverter implements SchemaConverter {
  
  /**
   * OpenAPI 스키마를 EAI 스키마로 변환
   */
  async convert(schema: OpenAPISchema, context: ConversionContext): Promise<ConversionResult> {
    const startTime = Date.now();
    const errors: ConversionError[] = [];
    const warnings: ConversionWarning[] = [];

    try {
      // EAI 스키마 모델 생성
      const eaiSchema = new EAISchemaModel({
        name: schema.info?.title || 'OpenAPI Schema',
        description: schema.info?.description,
        namespace: this.generateNamespace(schema),
        version: schema.info?.version || '1.0.0',
        sourceType: SchemaType.OPENAPI,
        tags: ['openapi', 'rest', 'api', 'converted'],
      });

      // 컴포넌트 스키마를 타입 정의로 변환
      await this.convertComponents(schema, eaiSchema, context, errors, warnings);

      // API 경로를 오퍼레이션으로 변환
      await this.convertPaths(schema, eaiSchema, context, errors, warnings);

      // 서버 정보를 바인딩으로 변환
      await this.convertServers(schema, eaiSchema, context, errors, warnings);

      // 보안 스키마 처리
      await this.convertSecurity(schema, eaiSchema, context, errors, warnings);

      const endTime = Date.now();
      const duration = endTime - startTime;

      // 통계 업데이트
      context.statistics.totalElements = this.countOpenAPIElements(schema);
      context.statistics.convertedElements = eaiSchema.entities.length + eaiSchema.operations.length + eaiSchema.types.length;
      context.statistics.processingTime = duration;

      return {
        success: errors.length === 0,
        eaiSchema,
        errors,
        warnings,
        statistics: context.statistics,
        metadata: {
          conversionId: uuidv4(),
          sourceType: SchemaType.OPENAPI,
          targetType: SchemaType.EAI,
          startTime: new Date(startTime),
          endTime: new Date(endTime),
          duration,
          rulesVersion: '1.0.0',
          engineVersion: '1.0.0',
        },
      };

    } catch (error) {
      const conversionError: ConversionError = {
        code: 'OPENAPI_CONVERSION_FAILED',
        message: `OpenAPI conversion failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        sourcePath: 'root',
        details: error,
        recoverable: false,
      };

      return {
        success: false,
        errors: [conversionError],
        warnings,
        statistics: context.statistics,
        metadata: {
          conversionId: uuidv4(),
          sourceType: SchemaType.OPENAPI,
          targetType: SchemaType.EAI,
          startTime: new Date(startTime),
          endTime: new Date(),
          duration: Date.now() - startTime,
          rulesVersion: '1.0.0',
          engineVersion: '1.0.0',
        },
      };
    }
  }

  /**
   * OpenAPI 컴포넌트를 EAI 타입 정의로 변환
   */
  private async convertComponents(
    schema: OpenAPISchema, 
    eaiSchema: EAISchemaModel, 
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<void> {
    if (!schema.components?.schemas) return;

    for (const [name, componentSchema] of Object.entries(schema.components.schemas)) {
      try {
        // 스키마 타입에 따라 엔티티 또는 타입 정의로 변환
        if (this.isComplexSchema(componentSchema)) {
          await this.convertSchemaToEntity(name, componentSchema, eaiSchema, context, errors, warnings);
        } else {
          await this.convertSchemaToType(name, componentSchema, eaiSchema, context, errors, warnings);
        }

        context.statistics.rulesApplied.set('openapi-component-to-eai', 
          (context.statistics.rulesApplied.get('openapi-component-to-eai') || 0) + 1);

      } catch (error) {
        errors.push({
          code: 'COMPONENT_CONVERSION_ERROR',
          message: `Failed to convert component '${name}': ${error instanceof Error ? error.message : 'Unknown error'}`,
          sourcePath: `components.schemas.${name}`,
          sourceElement: name,
          recoverable: true,
        });
      }
    }
  }

  /**
   * OpenAPI 경로를 EAI 오퍼레이션으로 변환
   */
  private async convertPaths(
    schema: OpenAPISchema, 
    eaiSchema: EAISchemaModel, 
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<void> {
    if (!schema.paths) return;

    for (const [path, pathItem] of Object.entries(schema.paths)) {
      try {
        const httpMethods = ['get', 'post', 'put', 'delete', 'patch', 'head', 'options', 'trace'];
        
        for (const method of httpMethods) {
          const operation = pathItem[method as keyof typeof pathItem] as OpenAPIOperation;
          if (!operation) continue;

          const eaiOperation = await this.convertOperation(
            path, 
            method.toUpperCase(), 
            operation, 
            eaiSchema, 
            context, 
            errors, 
            warnings
          );

          if (eaiOperation) {
            eaiSchema.addOperation(eaiOperation);
          }
        }

        context.statistics.rulesApplied.set('openapi-path-to-operation', 
          (context.statistics.rulesApplied.get('openapi-path-to-operation') || 0) + 1);

      } catch (error) {
        errors.push({
          code: 'PATH_CONVERSION_ERROR',
          message: `Failed to convert path '${path}': ${error instanceof Error ? error.message : 'Unknown error'}`,
          sourcePath: `paths.${path}`,
          sourceElement: path,
          recoverable: true,
        });
      }
    }
  }

  /**
   * OpenAPI 오퍼레이션을 EAI 오퍼레이션으로 변환
   */
  private async convertOperation(
    path: string,
    method: string,
    operation: OpenAPIOperation,
    eaiSchema: EAISchemaModel,
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<EAIOperation | null> {
    try {
      const operationName = operation.operationId || `${method.toLowerCase()}${this.pathToOperationName(path)}`;

      const eaiOperation: EAIOperation = {
        id: uuidv4(),
        name: operationName,
        type: this.mapHttpMethodToOperationType(method),
        description: operation.description || operation.summary,
        inputParameters: await this.convertOperationParameters(operation, context, errors, warnings),
        outputParameters: await this.convertOperationResponses(operation, context, errors, warnings),
        faults: await this.convertOperationErrors(operation, context, errors, warnings),
        bindings: [{
          id: uuidv4(),
          name: `${operationName}Binding`,
          type: BindingType.REST,
          protocol: 'HTTP',
          endpoint: path,
          configuration: {
            method: method,
            path: path,
            consumes: operation.requestBody?.content ? Object.keys(operation.requestBody.content) : [],
            produces: operation.responses ? this.extractResponseContentTypes(operation.responses) : [],
            tags: operation.tags || [],
          },
          sourceMapping: {
            sourceType: SchemaType.OPENAPI,
            sourcePath: `paths.${path}.${method.toLowerCase()}`,
            sourceElement: operationName,
            transformationRules: ['openapi-operation-to-binding'],
            confidence: 95,
          },
        }],
        annotations: [
          ...(operation.tags?.map(tag => ({ key: 'tag', value: tag })) || []),
          { key: 'http.method', value: method },
          { key: 'http.path', value: path },
        ],
        sourceMapping: {
          sourceType: SchemaType.OPENAPI,
          sourcePath: `paths.${path}.${method.toLowerCase()}`,
          sourceElement: operationName,
          transformationRules: ['openapi-operation-to-eai'],
          confidence: 95,
        },
      };

      return eaiOperation;

    } catch (error) {
      errors.push({
        code: 'OPERATION_CONVERSION_ERROR',
        message: `Failed to convert operation '${method} ${path}': ${error instanceof Error ? error.message : 'Unknown error'}`,
        sourcePath: `paths.${path}.${method.toLowerCase()}`,
        sourceElement: `${method} ${path}`,
        recoverable: true,
      });
      return null;
    }
  }

  /**
   * OpenAPI 서버 정보를 EAI 바인딩으로 변환
   */
  private async convertServers(
    schema: OpenAPISchema, 
    eaiSchema: EAISchemaModel, 
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<void> {
    if (!schema.servers) return;

    for (const [index, server] of schema.servers.entries()) {
      try {
        const eaiBinding: EAIBinding = {
          id: uuidv4(),
          name: server.description || `Server${index + 1}`,
          type: BindingType.REST,
          protocol: 'HTTP',
          endpoint: server.url,
          configuration: {
            description: server.description,
            variables: server.variables || {},
          },
          sourceMapping: {
            sourceType: SchemaType.OPENAPI,
            sourcePath: `servers.${index}`,
            sourceElement: server.url,
            transformationRules: ['openapi-server-to-binding'],
            confidence: 90,
          },
        };

        eaiSchema.addBinding(eaiBinding);
        context.statistics.rulesApplied.set('openapi-server-to-binding', 
          (context.statistics.rulesApplied.get('openapi-server-to-binding') || 0) + 1);

      } catch (error) {
        errors.push({
          code: 'SERVER_CONVERSION_ERROR',
          message: `Failed to convert server at index ${index}: ${error instanceof Error ? error.message : 'Unknown error'}`,
          sourcePath: `servers.${index}`,
          sourceElement: server.url,
          recoverable: true,
        });
      }
    }
  }

  /**
   * 스키마를 엔티티로 변환
   */
  private async convertSchemaToEntity(
    name: string,
    componentSchema: any,
    eaiSchema: EAISchemaModel,
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<void> {
    const properties = await this.convertSchemaProperties(componentSchema, context, errors, warnings);

    const eaiEntity: EAIEntity = {
      id: uuidv4(),
      name: name,
      namespace: eaiSchema.metadata.namespace,
      description: componentSchema.description,
      properties,
      relationships: [], // 나중에 참조 관계 분석하여 설정
      constraints: [],
      annotations: [
        { key: 'openapi.type', value: componentSchema.type || 'object' },
        ...(componentSchema.example ? [{ key: 'example', value: JSON.stringify(componentSchema.example) }] : []),
      ],
      sourceMapping: {
        sourceType: SchemaType.OPENAPI,
        sourcePath: `components.schemas.${name}`,
        sourceElement: name,
        transformationRules: ['openapi-schema-to-entity'],
        confidence: 90,
      },
    };

    eaiSchema.addEntity(eaiEntity);
  }

  /**
   * 스키마를 타입 정의로 변환
   */
  private async convertSchemaToType(
    name: string,
    componentSchema: any,
    eaiSchema: EAISchemaModel,
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<void> {
    const eaiType: EAITypeDefinition = {
      name: name,
      namespace: eaiSchema.metadata.namespace,
      category: this.mapOpenAPITypeCategory(componentSchema),
      restrictions: this.convertSchemaRestrictions(componentSchema),
      facets: [],
      description: componentSchema.description,
      annotations: [
        { key: 'openapi.type', value: componentSchema.type || 'string' },
        { key: 'openapi.format', value: componentSchema.format || '' },
      ],
      sourceMapping: {
        sourceType: SchemaType.OPENAPI,
        sourcePath: `components.schemas.${name}`,
        sourceElement: name,
        transformationRules: ['openapi-schema-to-type'],
        confidence: 95,
      },
    };

    eaiSchema.addType(eaiType);
  }

  /**
   * 스키마 프로퍼티 변환
   */
  private async convertSchemaProperties(
    schema: any,
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<EAIProperty[]> {
    const properties: EAIProperty[] = [];

    if (schema.properties) {
      for (const [propName, propSchema] of Object.entries(schema.properties)) {
        try {
          const property: EAIProperty = {
            name: propName,
            type: this.mapOpenAPIType(propSchema as any),
            isRequired: schema.required?.includes(propName) || false,
            isArray: (propSchema as any).type === 'array',
            defaultValue: (propSchema as any).default,
            constraints: [],
            description: (propSchema as any).description,
            annotations: [
              { key: 'openapi.type', value: (propSchema as any).type || 'string' },
              { key: 'openapi.format', value: (propSchema as any).format || '' },
            ],
            sourceMapping: {
              sourceType: SchemaType.OPENAPI,
              sourcePath: `properties.${propName}`,
              sourceElement: propName,
              transformationRules: ['openapi-property-to-eai'],
              confidence: 90,
            },
          };

          properties.push(property);

        } catch (error) {
          errors.push({
            code: 'PROPERTY_CONVERSION_ERROR',
            message: `Failed to convert property '${propName}': ${error instanceof Error ? error.message : 'Unknown error'}`,
            sourcePath: `properties.${propName}`,
            sourceElement: propName,
            recoverable: true,
          });
        }
      }
    }

    return properties;
  }

  /**
   * 오퍼레이션 파라미터 변환
   */
  private async convertOperationParameters(
    operation: OpenAPIOperation,
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<EAIParameter[]> {
    const parameters: EAIParameter[] = [];

    // 경로 파라미터, 쿼리 파라미터, 헤더 파라미터 처리
    if (operation.parameters) {
      for (const param of operation.parameters) {
        try {
          const eaiParam: EAIParameter = {
            name: param.name,
            type: this.mapOpenAPIType(param.schema || { type: 'string' }),
            isRequired: param.required || false,
            isArray: param.schema?.type === 'array',
            direction: ParameterDirection.IN,
            constraints: [],
            description: param.description,
            sourceMapping: {
              sourceType: SchemaType.OPENAPI,
              sourcePath: `parameters.${param.name}`,
              sourceElement: param.name,
              transformationRules: ['openapi-parameter-to-eai'],
              confidence: 95,
            },
          };

          parameters.push(eaiParam);

        } catch (error) {
          errors.push({
            code: 'PARAMETER_CONVERSION_ERROR',
            message: `Failed to convert parameter '${param.name}': ${error instanceof Error ? error.message : 'Unknown error'}`,
            sourcePath: `parameters.${param.name}`,
            sourceElement: param.name,
            recoverable: true,
          });
        }
      }
    }

    // 요청 본문 처리
    if (operation.requestBody) {
      const bodyParam: EAIParameter = {
        name: 'requestBody',
        type: 'object', // 실제로는 content type에 따라 결정
        isRequired: operation.requestBody.required || false,
        isArray: false,
        direction: ParameterDirection.IN,
        constraints: [],
        description: operation.requestBody.description,
        sourceMapping: {
          sourceType: SchemaType.OPENAPI,
          sourcePath: 'requestBody',
          sourceElement: 'requestBody',
          transformationRules: ['openapi-requestbody-to-parameter'],
          confidence: 85,
        },
      };

      parameters.push(bodyParam);
    }

    return parameters;
  }

  /**
   * 오퍼레이션 응답 변환
   */
  private async convertOperationResponses(
    operation: OpenAPIOperation,
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<EAIParameter[]> {
    const parameters: EAIParameter[] = [];

    if (operation.responses) {
      for (const [statusCode, response] of Object.entries(operation.responses)) {
        try {
          // 성공 응답만 출력 파라미터로 변환 (2xx)
          if (statusCode.startsWith('2')) {
            const responseParam: EAIParameter = {
              name: `response${statusCode}`,
              type: 'object', // 실제로는 response content에 따라 결정
              isRequired: true,
              isArray: false,
              direction: ParameterDirection.OUT,
              constraints: [],
              description: response.description,
              sourceMapping: {
                sourceType: SchemaType.OPENAPI,
                sourcePath: `responses.${statusCode}`,
                sourceElement: statusCode,
                transformationRules: ['openapi-response-to-parameter'],
                confidence: 85,
              },
            };

            parameters.push(responseParam);
          }

        } catch (error) {
          errors.push({
            code: 'RESPONSE_CONVERSION_ERROR',
            message: `Failed to convert response '${statusCode}': ${error instanceof Error ? error.message : 'Unknown error'}`,
            sourcePath: `responses.${statusCode}`,
            sourceElement: statusCode,
            recoverable: true,
          });
        }
      }
    }

    return parameters;
  }

  /**
   * 오퍼레이션 에러 변환
   */
  private async convertOperationErrors(
    operation: OpenAPIOperation,
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<any[]> {
    const faults: any[] = [];

    if (operation.responses) {
      for (const [statusCode, response] of Object.entries(operation.responses)) {
        // 에러 응답 (4xx, 5xx)
        if (statusCode.startsWith('4') || statusCode.startsWith('5')) {
          faults.push({
            name: `error${statusCode}`,
            type: 'object',
            description: response.description,
            sourceMapping: {
              sourceType: SchemaType.OPENAPI,
              sourcePath: `responses.${statusCode}`,
              sourceElement: statusCode,
              transformationRules: ['openapi-error-to-fault'],
              confidence: 85,
            },
          });
        }
      }
    }

    return faults;
  }

  /**
   * 보안 스키마 변환
   */
  private async convertSecurity(
    schema: OpenAPISchema, 
    eaiSchema: EAISchemaModel, 
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<void> {
    if (!schema.components?.securitySchemes) return;

    // 보안 정보를 바인딩의 보안 설정으로 추가
    for (const binding of eaiSchema.bindings) {
      if (schema.security) {
        binding.security = {
          type: this.mapSecurityType(schema.components.securitySchemes),
          configuration: schema.components.securitySchemes,
        };
      }
    }
  }

  // 유틸리티 메서드들

  private generateNamespace(schema: OpenAPISchema): string {
    const host = schema.servers?.[0]?.url || 'http://localhost';
    try {
      const url = new URL(host);
      return `http://${url.hostname}${url.pathname}`;
    } catch {
      return 'http://localhost/api';
    }
  }

  private isComplexSchema(schema: any): boolean {
    return schema.type === 'object' || schema.properties || schema.allOf || schema.oneOf || schema.anyOf;
  }

  private pathToOperationName(path: string): string {
    return path
      .split('/')
      .filter(segment => segment && !segment.startsWith('{'))
      .map(segment => segment.charAt(0).toUpperCase() + segment.slice(1))
      .join('');
  }

  private mapHttpMethodToOperationType(method: string): OperationType {
    switch (method.toUpperCase()) {
      case 'GET':
        return OperationType.READ;
      case 'POST':
        return OperationType.CREATE;
      case 'PUT':
      case 'PATCH':
        return OperationType.UPDATE;
      case 'DELETE':
        return OperationType.DELETE;
      default:
        return OperationType.REQUEST_RESPONSE;
    }
  }

  private mapOpenAPITypeCategory(schema: any): TypeCategory {
    if (schema.enum) return TypeCategory.ENUMERATION;
    if (schema.type === 'object') return TypeCategory.COMPLEX;
    if (schema.type === 'array') return TypeCategory.LIST;
    if (schema.oneOf || schema.anyOf) return TypeCategory.UNION;
    return TypeCategory.SIMPLE;
  }

  private mapOpenAPIType(schema: any): string {
    if (schema.type === 'array') {
      return `${this.mapOpenAPIType(schema.items)}[]`;
    }
    
    switch (schema.type) {
      case 'integer':
        return schema.format === 'int64' ? 'long' : 'integer';
      case 'number':
        return schema.format === 'double' ? 'double' : 'decimal';
      case 'boolean':
        return 'boolean';
      case 'string':
        if (schema.format === 'date') return 'date';
        if (schema.format === 'date-time') return 'datetime';
        if (schema.format === 'binary') return 'binary';
        return 'string';
      case 'object':
        return 'object';
      default:
        return 'string';
    }
  }

  private convertSchemaRestrictions(schema: any): any[] {
    const restrictions: any[] = [];

    if (schema.minLength !== undefined) {
      restrictions.push({ type: 'MIN_LENGTH', value: schema.minLength });
    }
    if (schema.maxLength !== undefined) {
      restrictions.push({ type: 'MAX_LENGTH', value: schema.maxLength });
    }
    if (schema.pattern) {
      restrictions.push({ type: 'PATTERN', value: schema.pattern });
    }
    if (schema.minimum !== undefined) {
      restrictions.push({ type: 'MIN_INCLUSIVE', value: schema.minimum });
    }
    if (schema.maximum !== undefined) {
      restrictions.push({ type: 'MAX_INCLUSIVE', value: schema.maximum });
    }
    if (schema.enum) {
      restrictions.push({ type: 'ENUMERATION', value: schema.enum });
    }

    return restrictions;
  }

  private extractResponseContentTypes(responses: any): string[] {
    const contentTypes = new Set<string>();
    
    for (const response of Object.values(responses)) {
      if ((response as any).content) {
        Object.keys((response as any).content).forEach(type => contentTypes.add(type));
      }
    }

    return Array.from(contentTypes);
  }

  private mapSecurityType(securitySchemes: any): SecurityType {
    const firstScheme = Object.values(securitySchemes)[0] as any;
    
    switch (firstScheme?.type) {
      case 'http':
        return firstScheme.scheme === 'basic' ? SecurityType.BASIC : SecurityType.JWT;
      case 'oauth2':
        return SecurityType.OAUTH;
      case 'apiKey':
        return SecurityType.JWT;
      default:
        return SecurityType.NONE;
    }
  }

  private countOpenAPIElements(schema: OpenAPISchema): number {
    let count = 0;
    count += Object.keys(schema.paths || {}).length;
    count += Object.keys(schema.components?.schemas || {}).length;
    count += schema.servers?.length || 0;
    return count;
  }

  getSupportedSourceTypes(): SchemaType[] {
    return [SchemaType.OPENAPI];
  }

  getDefaultOptions(): ConversionOptions {
    return {
      preserveNamespaces: true,
      generateIds: true,
      includeDocumentation: true,
      includeAnnotations: true,
      strictMode: false,
      customTypeMapping: {},
      excludePatterns: [],
      includePatterns: [],
      maxDepth: 10,
      enableOptimizations: true,
    };
  }

  async validateInput(schema: OpenAPISchema): Promise<boolean> {
    if (!schema) return false;
    if (!schema.openapi && !schema.swagger) return false;
    if (!schema.info) return false;
    return true;
  }
}