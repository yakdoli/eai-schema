// XSD → EAI 스키마 변환기
import { 
  SchemaConverter, 
  ConversionContext, 
  ConversionResult, 
  ConversionOptions,
  EAIEntity,
  EAITypeDefinition,
  EAIProperty,
  EAIRelationship,
  EAIConstraint,
  TypeCategory,
  RelationshipType,
  Cardinality,
  RestrictionType,
  ConstraintType,
  ConstraintSeverity,
  SourceMapping,
  ConversionError,
  ConversionWarning
} from '../types';
import { EAISchemaModel } from '../models/eai-schema';
import { SchemaType, XSDSchema, XSDComplexType, XSDSimpleType, XSDElement } from '@eai-toolkit/shared';
import { v4 as uuidv4 } from 'uuid';

/**
 * XSD 스키마를 EAI 스키마로 변환하는 컨버터
 */
export class XSDConverter implements SchemaConverter {
  
  /**
   * XSD 스키마를 EAI 스키마로 변환
   */
  async convert(schema: XSDSchema, context: ConversionContext): Promise<ConversionResult> {
    const startTime = Date.now();
    const errors: ConversionError[] = [];
    const warnings: ConversionWarning[] = [];

    try {
      // EAI 스키마 모델 생성
      const eaiSchema = new EAISchemaModel({
        name: schema.metadata.name || 'XSD Schema',
        description: schema.metadata.description,
        namespace: schema.metadata.targetNamespace || 'http://tempuri.org/',
        sourceType: SchemaType.XSD,
        tags: ['xsd', 'converted'],
      });

      // 단순 타입 변환
      await this.convertSimpleTypes(schema, eaiSchema, context, errors, warnings);

      // 복합 타입 변환
      await this.convertComplexTypes(schema, eaiSchema, context, errors, warnings);

      // 전역 요소를 엔티티로 변환
      await this.convertGlobalElements(schema, eaiSchema, context, errors, warnings);

      // 타입 간 관계 설정
      await this.establishRelationships(schema, eaiSchema, context, errors, warnings);

      const endTime = Date.now();
      const duration = endTime - startTime;

      // 통계 업데이트
      context.statistics.totalElements = this.countXSDElements(schema);
      context.statistics.convertedElements = eaiSchema.entities.length + eaiSchema.types.length;
      context.statistics.processingTime = duration;

      return {
        success: errors.length === 0,
        eaiSchema,
        errors,
        warnings,
        statistics: context.statistics,
        metadata: {
          conversionId: uuidv4(),
          sourceType: SchemaType.XSD,
          targetType: SchemaType.EAI,
          startTime: new Date(startTime),
          endTime: new Date(endTime),
          duration,
          rulesVersion: '1.0.0',
          engineVersion: '1.0.0',
        },
      };

    } catch (error) {
      const conversionError: ConversionError = {
        code: 'XSD_CONVERSION_FAILED',
        message: `XSD conversion failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        sourcePath: 'root',
        details: error,
        recoverable: false,
      };

      return {
        success: false,
        errors: [conversionError],
        warnings,
        statistics: context.statistics,
        metadata: {
          conversionId: uuidv4(),
          sourceType: SchemaType.XSD,
          targetType: SchemaType.EAI,
          startTime: new Date(startTime),
          endTime: new Date(),
          duration: Date.now() - startTime,
          rulesVersion: '1.0.0',
          engineVersion: '1.0.0',
        },
      };
    }
  }

  /**
   * XSD 단순 타입을 EAI 타입으로 변환
   */
  private async convertSimpleTypes(
    schema: XSDSchema, 
    eaiSchema: EAISchemaModel, 
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<void> {
    if (!schema.simpleTypes) return;

    for (const simpleType of schema.simpleTypes) {
      try {
        const eaiType: EAITypeDefinition = {
          name: simpleType.name,
          namespace: simpleType.namespace || schema.metadata.targetNamespace,
          baseType: simpleType.baseType,
          category: this.mapSimpleTypeCategory(simpleType),
          restrictions: this.convertRestrictions(simpleType.restrictions || []),
          facets: simpleType.facets?.map(facet => ({
            name: facet.name,
            value: facet.value,
            fixed: facet.fixed || false,
          })) || [],
          description: simpleType.documentation,
          annotations: simpleType.annotations?.map(ann => ({
            key: ann.name || 'annotation',
            value: ann.value || '',
            namespace: ann.namespace,
          })) || [],
          sourceMapping: {
            sourceType: SchemaType.XSD,
            sourcePath: `simpleTypes.${simpleType.name}`,
            sourceElement: simpleType.name,
            transformationRules: ['xsd-simpletype-to-eai'],
            confidence: 95,
          },
        };

        eaiSchema.addType(eaiType);
        context.statistics.rulesApplied.set('xsd-simpletype-to-eai', 
          (context.statistics.rulesApplied.get('xsd-simpletype-to-eai') || 0) + 1);

      } catch (error) {
        errors.push({
          code: 'SIMPLE_TYPE_CONVERSION_ERROR',
          message: `Failed to convert simple type '${simpleType.name}': ${error instanceof Error ? error.message : 'Unknown error'}`,
          sourcePath: `simpleTypes.${simpleType.name}`,
          sourceElement: simpleType.name,
          recoverable: true,
        });
      }
    }
  }

  /**
   * XSD 복합 타입을 EAI 타입으로 변환
   */
  private async convertComplexTypes(
    schema: XSDSchema, 
    eaiSchema: EAISchemaModel, 
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<void> {
    if (!schema.complexTypes) return;

    for (const complexType of schema.complexTypes) {
      try {
        // 복합 타입을 엔티티로 변환 (구조적 특성이 강하므로)
        const eaiEntity: EAIEntity = {
          id: uuidv4(),
          name: complexType.name,
          namespace: complexType.namespace || schema.metadata.targetNamespace,
          description: complexType.documentation,
          properties: await this.convertComplexTypeElements(complexType, context, errors, warnings),
          relationships: [], // 나중에 설정
          constraints: this.convertComplexTypeConstraints(complexType),
          annotations: complexType.annotations?.map(ann => ({
            key: ann.name || 'annotation',
            value: ann.value || '',
            namespace: ann.namespace,
          })) || [],
          sourceMapping: {
            sourceType: SchemaType.XSD,
            sourcePath: `complexTypes.${complexType.name}`,
            sourceElement: complexType.name,
            transformationRules: ['xsd-complextype-to-entity'],
            confidence: 90,
          },
        };

        eaiSchema.addEntity(eaiEntity);

        // 동시에 타입 정의도 생성 (타입으로도 참조될 수 있으므로)
        const eaiType: EAITypeDefinition = {
          name: complexType.name,
          namespace: complexType.namespace || schema.metadata.targetNamespace,
          baseType: complexType.baseType,
          category: TypeCategory.COMPLEX,
          properties: eaiEntity.properties,
          restrictions: [],
          facets: [],
          description: complexType.documentation,
          annotations: eaiEntity.annotations,
          sourceMapping: {
            sourceType: SchemaType.XSD,
            sourcePath: `complexTypes.${complexType.name}`,
            sourceElement: complexType.name,
            transformationRules: ['xsd-complextype-to-type'],
            confidence: 90,
          },
        };

        eaiSchema.addType(eaiType);

        context.statistics.rulesApplied.set('xsd-complextype-to-entity', 
          (context.statistics.rulesApplied.get('xsd-complextype-to-entity') || 0) + 1);
        context.statistics.rulesApplied.set('xsd-complextype-to-type', 
          (context.statistics.rulesApplied.get('xsd-complextype-to-type') || 0) + 1);

      } catch (error) {
        errors.push({
          code: 'COMPLEX_TYPE_CONVERSION_ERROR',
          message: `Failed to convert complex type '${complexType.name}': ${error instanceof Error ? error.message : 'Unknown error'}`,
          sourcePath: `complexTypes.${complexType.name}`,
          sourceElement: complexType.name,
          recoverable: true,
        });
      }
    }
  }

  /**
   * XSD 전역 요소를 EAI 엔티티로 변환
   */
  private async convertGlobalElements(
    schema: XSDSchema, 
    eaiSchema: EAISchemaModel, 
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<void> {
    if (!schema.elements) return;

    for (const element of schema.elements) {
      try {
        // 이미 복합 타입으로 변환된 경우 스킵
        if (element.type && eaiSchema.findEntity(element.type)) {
          continue;
        }

        const eaiEntity: EAIEntity = {
          id: uuidv4(),
          name: element.name,
          namespace: element.namespace || schema.metadata.targetNamespace,
          description: element.documentation,
          properties: await this.convertElementProperties(element, context, errors, warnings),
          relationships: [],
          constraints: this.convertElementConstraints(element),
          annotations: element.annotations?.map(ann => ({
            key: ann.name || 'annotation',
            value: ann.value || '',
            namespace: ann.namespace,
          })) || [],
          sourceMapping: {
            sourceType: SchemaType.XSD,
            sourcePath: `elements.${element.name}`,
            sourceElement: element.name,
            transformationRules: ['xsd-element-to-entity'],
            confidence: 85,
          },
        };

        eaiSchema.addEntity(eaiEntity);
        context.statistics.rulesApplied.set('xsd-element-to-entity', 
          (context.statistics.rulesApplied.get('xsd-element-to-entity') || 0) + 1);

      } catch (error) {
        errors.push({
          code: 'ELEMENT_CONVERSION_ERROR',
          message: `Failed to convert element '${element.name}': ${error instanceof Error ? error.message : 'Unknown error'}`,
          sourcePath: `elements.${element.name}`,
          sourceElement: element.name,
          recoverable: true,
        });
      }
    }
  }

  /**
   * 복합 타입의 요소들을 EAI 프로퍼티로 변환
   */
  private async convertComplexTypeElements(
    complexType: XSDComplexType, 
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<EAIProperty[]> {
    const properties: EAIProperty[] = [];

    if (complexType.elements) {
      for (const element of complexType.elements) {
        try {
          const property: EAIProperty = {
            name: element.name,
            type: element.type || 'string',
            isRequired: element.minOccurs !== '0',
            isArray: element.maxOccurs === 'unbounded' || (element.maxOccurs && parseInt(element.maxOccurs) > 1),
            defaultValue: element.defaultValue,
            constraints: this.convertElementConstraints(element),
            description: element.documentation,
            annotations: element.annotations?.map(ann => ({
              key: ann.name || 'annotation',
              value: ann.value || '',
              namespace: ann.namespace,
            })) || [],
            sourceMapping: {
              sourceType: SchemaType.XSD,
              sourcePath: `complexTypes.${complexType.name}.elements.${element.name}`,
              sourceElement: element.name,
              transformationRules: ['xsd-element-to-property'],
              confidence: 90,
            },
          };

          properties.push(property);

        } catch (error) {
          errors.push({
            code: 'ELEMENT_TO_PROPERTY_ERROR',
            message: `Failed to convert element '${element.name}' to property: ${error instanceof Error ? error.message : 'Unknown error'}`,
            sourcePath: `complexTypes.${complexType.name}.elements.${element.name}`,
            sourceElement: element.name,
            recoverable: true,
          });
        }
      }
    }

    if (complexType.attributes) {
      for (const attribute of complexType.attributes) {
        try {
          const property: EAIProperty = {
            name: attribute.name,
            type: attribute.type || 'string',
            isRequired: attribute.use === 'required',
            isArray: false,
            defaultValue: attribute.defaultValue,
            constraints: [],
            description: attribute.documentation,
            annotations: [{
              key: 'xsd:attribute',
              value: 'true',
            }],
            sourceMapping: {
              sourceType: SchemaType.XSD,
              sourcePath: `complexTypes.${complexType.name}.attributes.${attribute.name}`,
              sourceElement: attribute.name,
              transformationRules: ['xsd-attribute-to-property'],
              confidence: 90,
            },
          };

          properties.push(property);

        } catch (error) {
          errors.push({
            code: 'ATTRIBUTE_TO_PROPERTY_ERROR',
            message: `Failed to convert attribute '${attribute.name}' to property: ${error instanceof Error ? error.message : 'Unknown error'}`,
            sourcePath: `complexTypes.${complexType.name}.attributes.${attribute.name}`,
            sourceElement: attribute.name,
            recoverable: true,
          });
        }
      }
    }

    return properties;
  }

  /**
   * 요소의 프로퍼티 변환
   */
  private async convertElementProperties(
    element: XSDElement, 
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<EAIProperty[]> {
    const properties: EAIProperty[] = [];

    // 요소가 복합 타입을 참조하는 경우
    if (element.type && element.complexType) {
      return this.convertComplexTypeElements(element.complexType, context, errors, warnings);
    }

    // 단순 요소인 경우 자기 자신을 프로퍼티로 변환
    if (element.type) {
      properties.push({
        name: 'value',
        type: element.type,
        isRequired: true,
        isArray: false,
        defaultValue: element.defaultValue,
        constraints: this.convertElementConstraints(element),
        description: element.documentation,
        annotations: [],
        sourceMapping: {
          sourceType: SchemaType.XSD,
          sourcePath: `elements.${element.name}`,
          sourceElement: element.name,
          transformationRules: ['xsd-simple-element-to-property'],
          confidence: 85,
        },
      });
    }

    return properties;
  }

  /**
   * XSD 제한사항을 EAI 제한사항으로 변환
   */
  private convertRestrictions(restrictions: any[]): any[] {
    return restrictions.map(restriction => ({
      type: this.mapRestrictionType(restriction.type),
      value: restriction.value,
      description: restriction.description,
    }));
  }

  /**
   * 복합 타입의 제약조건 변환
   */
  private convertComplexTypeConstraints(complexType: XSDComplexType): EAIConstraint[] {
    const constraints: EAIConstraint[] = [];

    // 상속 관계 제약조건
    if (complexType.baseType) {
      constraints.push({
        type: ConstraintType.REFERENTIAL_INTEGRITY,
        expression: `extends ${complexType.baseType}`,
        message: `This type extends ${complexType.baseType}`,
        severity: ConstraintSeverity.INFO,
      });
    }

    // 추상 타입 제약조건
    if (complexType.abstract) {
      constraints.push({
        type: ConstraintType.VALIDATION,
        expression: 'abstract = true',
        message: 'This is an abstract type and cannot be instantiated directly',
        severity: ConstraintSeverity.WARNING,
      });
    }

    return constraints;
  }

  /**
   * 요소의 제약조건 변환
   */
  private convertElementConstraints(element: XSDElement): EAIConstraint[] {
    const constraints: EAIConstraint[] = [];

    // 발생 횟수 제약조건
    if (element.minOccurs && element.minOccurs !== '1') {
      constraints.push({
        type: ConstraintType.VALIDATION,
        expression: `minOccurs = ${element.minOccurs}`,
        message: `Minimum occurrence is ${element.minOccurs}`,
        severity: ConstraintSeverity.ERROR,
      });
    }

    if (element.maxOccurs && element.maxOccurs !== '1') {
      constraints.push({
        type: ConstraintType.VALIDATION,
        expression: `maxOccurs = ${element.maxOccurs}`,
        message: `Maximum occurrence is ${element.maxOccurs}`,
        severity: ConstraintSeverity.ERROR,
      });
    }

    // 고정값 제약조건
    if (element.fixed) {
      constraints.push({
        type: ConstraintType.VALIDATION,
        expression: `fixed = "${element.fixed}"`,
        message: `Value must be exactly "${element.fixed}"`,
        severity: ConstraintSeverity.ERROR,
      });
    }

    return constraints;
  }

  /**
   * 타입 간 관계 설정
   */
  private async establishRelationships(
    schema: XSDSchema, 
    eaiSchema: EAISchemaModel, 
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<void> {
    // 복합 타입의 상속 관계 설정
    if (schema.complexTypes) {
      for (const complexType of schema.complexTypes) {
        if (complexType.baseType) {
          const entity = eaiSchema.findEntity(complexType.name);
          const baseEntity = eaiSchema.findEntity(complexType.baseType);

          if (entity && baseEntity) {
            const relationship: EAIRelationship = {
              name: 'extends',
              type: RelationshipType.INHERITANCE,
              target: baseEntity.name,
              cardinality: Cardinality.ONE_TO_ONE,
              description: `Inherits from ${baseEntity.name}`,
              sourceMapping: {
                sourceType: SchemaType.XSD,
                sourcePath: `complexTypes.${complexType.name}.baseType`,
                sourceElement: complexType.baseType,
                transformationRules: ['xsd-inheritance-to-relationship'],
                confidence: 95,
              },
            };

            entity.relationships.push(relationship);
          }
        }
      }
    }

    // 요소 참조 관계 설정
    for (const entity of eaiSchema.entities) {
      for (const property of entity.properties) {
        // 타입 참조가 다른 엔티티를 가리키는 경우
        const referencedEntity = eaiSchema.findEntity(property.type);
        if (referencedEntity && referencedEntity.name !== entity.name) {
          const relationship: EAIRelationship = {
            name: property.name,
            type: property.isArray ? RelationshipType.COMPOSITION : RelationshipType.ASSOCIATION,
            target: referencedEntity.name,
            cardinality: property.isArray ? Cardinality.ONE_TO_MANY : Cardinality.ONE_TO_ONE,
            description: `References ${referencedEntity.name}`,
            sourceMapping: {
              sourceType: SchemaType.XSD,
              sourcePath: property.sourceMapping.sourcePath,
              sourceElement: property.name,
              transformationRules: ['xsd-reference-to-relationship'],
              confidence: 85,
            },
          };

          entity.relationships.push(relationship);
        }
      }
    }
  }

  /**
   * 단순 타입 카테고리 매핑
   */
  private mapSimpleTypeCategory(simpleType: XSDSimpleType): TypeCategory {
    if (simpleType.enumeration && simpleType.enumeration.length > 0) {
      return TypeCategory.ENUMERATION;
    }
    
    if (simpleType.union) {
      return TypeCategory.UNION;
    }
    
    if (simpleType.list) {
      return TypeCategory.LIST;
    }
    
    return TypeCategory.SIMPLE;
  }

  /**
   * 제한사항 타입 매핑
   */
  private mapRestrictionType(type: string): RestrictionType {
    switch (type?.toLowerCase()) {
      case 'minlength':
        return RestrictionType.MIN_LENGTH;
      case 'maxlength':
        return RestrictionType.MAX_LENGTH;
      case 'pattern':
        return RestrictionType.PATTERN;
      case 'mininclusive':
        return RestrictionType.MIN_INCLUSIVE;
      case 'maxinclusive':
        return RestrictionType.MAX_INCLUSIVE;
      case 'minexclusive':
        return RestrictionType.MIN_EXCLUSIVE;
      case 'maxexclusive':
        return RestrictionType.MAX_EXCLUSIVE;
      case 'enumeration':
        return RestrictionType.ENUMERATION;
      case 'whitespace':
        return RestrictionType.WHITE_SPACE;
      case 'totaldigits':
        return RestrictionType.TOTAL_DIGITS;
      case 'fractiondigits':
        return RestrictionType.FRACTION_DIGITS;
      default:
        return RestrictionType.PATTERN;
    }
  }

  /**
   * XSD 요소 개수 계산
   */
  private countXSDElements(schema: XSDSchema): number {
    let count = 0;
    count += schema.elements?.length || 0;
    count += schema.complexTypes?.length || 0;
    count += schema.simpleTypes?.length || 0;
    count += schema.attributes?.length || 0;
    return count;
  }

  /**
   * 지원하는 소스 타입 반환
   */
  getSupportedSourceTypes(): SchemaType[] {
    return [SchemaType.XSD];
  }

  /**
   * 기본 변환 옵션 반환
   */
  getDefaultOptions(): ConversionOptions {
    return {
      preserveNamespaces: true,
      generateIds: true,
      includeDocumentation: true,
      includeAnnotations: true,
      strictMode: false,
      customTypeMapping: {
        'xs:string': 'string',
        'xs:int': 'integer',
        'xs:boolean': 'boolean',
        'xs:decimal': 'decimal',
        'xs:date': 'date',
        'xs:dateTime': 'datetime',
      },
      excludePatterns: [],
      includePatterns: [],
      maxDepth: 10,
      enableOptimizations: true,
    };
  }

  /**
   * 입력 스키마 검증
   */
  async validateInput(schema: XSDSchema): Promise<boolean> {
    if (!schema) return false;
    if (!schema.metadata) return false;
    if (!schema.elements && !schema.complexTypes && !schema.simpleTypes) return false;
    return true;
  }
}