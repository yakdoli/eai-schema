// WSDL → EAI 스키마 변환기
import { 
  SchemaConverter, 
  ConversionContext, 
  ConversionResult, 
  ConversionOptions,
  EAIEntity,
  EAIOperation,
  EAITypeDefinition,
  EAIBinding,
  EAIParameter,
  EAIProperty,
  OperationType,
  ParameterDirection,
  BindingType,
  TypeCategory,
  SourceMapping,
  ConversionError,
  ConversionWarning
} from '../types';
import { EAISchemaModel } from '../models/eai-schema';
import { SchemaType, WSDLSchema, WSDLService, WSDLPortType, WSDLOperation, WSDLMessage, WSDLBinding } from '@eai-toolkit/shared';
import { v4 as uuidv4 } from 'uuid';

/**
 * WSDL 스키마를 EAI 스키마로 변환하는 컨버터
 */
export class WSDLConverter implements SchemaConverter {
  
  /**
   * WSDL 스키마를 EAI 스키마로 변환
   */
  async convert(schema: WSDLSchema, context: ConversionContext): Promise<ConversionResult> {
    const startTime = Date.now();
    const errors: ConversionError[] = [];
    const warnings: ConversionWarning[] = [];

    try {
      // EAI 스키마 모델 생성
      const eaiSchema = new EAISchemaModel({
        name: schema.metadata.name || 'WSDL Schema',
        description: schema.metadata.description,
        namespace: schema.metadata.targetNamespace || 'http://tempuri.org/',
        sourceType: SchemaType.WSDL,
        tags: ['wsdl', 'converted'],
      });

      // 타입 정의 변환
      await this.convertTypes(schema, eaiSchema, context, errors, warnings);

      // 서비스 및 오퍼레이션 변환
      await this.convertServices(schema, eaiSchema, context, errors, warnings);

      // 바인딩 변환
      await this.convertBindings(schema, eaiSchema, context, errors, warnings);

      // 메시지 기반 엔티티 변환
      await this.convertMessages(schema, eaiSchema, context, errors, warnings);

      const endTime = Date.now();
      const duration = endTime - startTime;

      // 통계 업데이트
      context.statistics.totalElements = this.countWSDLElements(schema);
      context.statistics.convertedElements = eaiSchema.entities.length + eaiSchema.operations.length + eaiSchema.types.length;
      context.statistics.processingTime = duration;

      return {
        success: errors.length === 0,
        eaiSchema,
        errors,
        warnings,
        statistics: context.statistics,
        metadata: {
          conversionId: uuidv4(),
          sourceType: SchemaType.WSDL,
          targetType: SchemaType.EAI,
          startTime: new Date(startTime),
          endTime: new Date(endTime),
          duration,
          rulesVersion: '1.0.0',
          engineVersion: '1.0.0',
        },
      };

    } catch (error) {
      const conversionError: ConversionError = {
        code: 'WSDL_CONVERSION_FAILED',
        message: `WSDL conversion failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        sourcePath: 'root',
        details: error,
        recoverable: false,
      };

      return {
        success: false,
        errors: [conversionError],
        warnings,
        statistics: context.statistics,
        metadata: {
          conversionId: uuidv4(),
          sourceType: SchemaType.WSDL,
          targetType: SchemaType.EAI,
          startTime: new Date(startTime),
          endTime: new Date(),
          duration: Date.now() - startTime,
          rulesVersion: '1.0.0',
          engineVersion: '1.0.0',
        },
      };
    }
  }

  /**
   * WSDL 타입 정의를 EAI 타입으로 변환
   */
  private async convertTypes(
    schema: WSDLSchema, 
    eaiSchema: EAISchemaModel, 
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<void> {
    if (!schema.types) return;

    for (const type of schema.types) {
      try {
        const eaiType: EAITypeDefinition = {
          name: type.name,
          namespace: type.namespace || schema.metadata.targetNamespace,
          baseType: type.baseType,
          category: this.mapTypeCategory(type.category),
          properties: type.elements?.map(element => this.convertElementToProperty(element, context)) || [],
          restrictions: type.restrictions?.map(restriction => ({
            type: restriction.type as any,
            value: restriction.value,
            description: restriction.description,
          })) || [],
          facets: type.facets?.map(facet => ({
            name: facet.name,
            value: facet.value,
            fixed: facet.fixed || false,
          })) || [],
          description: type.documentation,
          annotations: type.annotations?.map(ann => ({
            key: ann.name,
            value: ann.value,
            namespace: ann.namespace,
          })) || [],
          sourceMapping: {
            sourceType: SchemaType.WSDL,
            sourcePath: `types.${type.name}`,
            sourceElement: type.name,
            transformationRules: ['wsdl-type-to-eai'],
            confidence: 95,
          },
        };

        eaiSchema.addType(eaiType);
        context.statistics.rulesApplied.set('wsdl-type-to-eai', 
          (context.statistics.rulesApplied.get('wsdl-type-to-eai') || 0) + 1);

      } catch (error) {
        errors.push({
          code: 'TYPE_CONVERSION_ERROR',
          message: `Failed to convert type '${type.name}': ${error instanceof Error ? error.message : 'Unknown error'}`,
          sourcePath: `types.${type.name}`,
          sourceElement: type.name,
          recoverable: true,
        });
      }
    }
  }

  /**
   * WSDL 서비스를 EAI 오퍼레이션으로 변환
   */
  private async convertServices(
    schema: WSDLSchema, 
    eaiSchema: EAISchemaModel, 
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<void> {
    if (!schema.services) return;

    for (const service of schema.services) {
      try {
        // 서비스의 각 포트타입에서 오퍼레이션 추출
        for (const port of service.ports) {
          const portType = schema.portTypes?.find(pt => pt.name === port.binding);
          if (!portType) {
            warnings.push({
              code: 'MISSING_PORTTYPE',
              message: `PortType '${port.binding}' not found for service '${service.name}'`,
              sourcePath: `services.${service.name}.ports.${port.name}`,
              impact: 'MEDIUM' as any,
            });
            continue;
          }

          await this.convertPortTypeOperations(portType, service, eaiSchema, context, errors, warnings);
        }

      } catch (error) {
        errors.push({
          code: 'SERVICE_CONVERSION_ERROR',
          message: `Failed to convert service '${service.name}': ${error instanceof Error ? error.message : 'Unknown error'}`,
          sourcePath: `services.${service.name}`,
          sourceElement: service.name,
          recoverable: true,
        });
      }
    }
  }

  /**
   * PortType 오퍼레이션을 EAI 오퍼레이션으로 변환
   */
  private async convertPortTypeOperations(
    portType: WSDLPortType,
    service: WSDLService,
    eaiSchema: EAISchemaModel,
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<void> {
    if (!portType.operations) return;

    for (const operation of portType.operations) {
      try {
        const eaiOperation: EAIOperation = {
          id: uuidv4(),
          name: operation.name,
          type: this.mapOperationType(operation.type),
          description: operation.documentation,
          inputParameters: await this.convertMessageToParameters(
            operation.input, 
            ParameterDirection.IN, 
            context, 
            errors, 
            warnings
          ),
          outputParameters: await this.convertMessageToParameters(
            operation.output, 
            ParameterDirection.OUT, 
            context, 
            errors, 
            warnings
          ),
          faults: operation.faults?.map(fault => ({
            name: fault.name,
            type: fault.message || 'string',
            description: fault.documentation,
            sourceMapping: {
              sourceType: SchemaType.WSDL,
              sourcePath: `portTypes.${portType.name}.operations.${operation.name}.faults.${fault.name}`,
              sourceElement: fault.name,
              transformationRules: ['wsdl-fault-to-eai'],
              confidence: 90,
            },
          })) || [],
          bindings: [],
          annotations: [],
          sourceMapping: {
            sourceType: SchemaType.WSDL,
            sourcePath: `portTypes.${portType.name}.operations.${operation.name}`,
            sourceElement: operation.name,
            transformationRules: ['wsdl-operation-to-eai'],
            confidence: 95,
          },
        };

        eaiSchema.addOperation(eaiOperation);
        context.statistics.rulesApplied.set('wsdl-operation-to-eai', 
          (context.statistics.rulesApplied.get('wsdl-operation-to-eai') || 0) + 1);

      } catch (error) {
        errors.push({
          code: 'OPERATION_CONVERSION_ERROR',
          message: `Failed to convert operation '${operation.name}': ${error instanceof Error ? error.message : 'Unknown error'}`,
          sourcePath: `portTypes.${portType.name}.operations.${operation.name}`,
          sourceElement: operation.name,
          recoverable: true,
        });
      }
    }
  }

  /**
   * WSDL 메시지를 EAI 파라미터로 변환
   */
  private async convertMessageToParameters(
    messageName: string | undefined,
    direction: ParameterDirection,
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<EAIParameter[]> {
    if (!messageName) return [];

    // 실제 구현에서는 WSDL 스키마에서 메시지 정의를 찾아야 함
    // 여기서는 간단한 예시로 구현
    return [{
      name: messageName.replace('Message', ''),
      type: 'string', // 실제로는 메시지 타입을 분석해야 함
      isRequired: true,
      isArray: false,
      direction,
      constraints: [],
      sourceMapping: {
        sourceType: SchemaType.WSDL,
        sourcePath: `messages.${messageName}`,
        sourceElement: messageName,
        transformationRules: ['wsdl-message-to-parameter'],
        confidence: 85,
      },
    }];
  }

  /**
   * WSDL 바인딩을 EAI 바인딩으로 변환
   */
  private async convertBindings(
    schema: WSDLSchema, 
    eaiSchema: EAISchemaModel, 
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<void> {
    if (!schema.bindings) return;

    for (const binding of schema.bindings) {
      try {
        const eaiBinding: EAIBinding = {
          id: uuidv4(),
          name: binding.name,
          type: this.mapBindingType(binding.type),
          protocol: binding.transport || 'HTTP',
          endpoint: binding.location,
          configuration: {
            style: binding.style,
            transport: binding.transport,
            soapAction: binding.soapAction,
            ...binding.extensions,
          },
          sourceMapping: {
            sourceType: SchemaType.WSDL,
            sourcePath: `bindings.${binding.name}`,
            sourceElement: binding.name,
            transformationRules: ['wsdl-binding-to-eai'],
            confidence: 90,
          },
        };

        eaiSchema.addBinding(eaiBinding);
        context.statistics.rulesApplied.set('wsdl-binding-to-eai', 
          (context.statistics.rulesApplied.get('wsdl-binding-to-eai') || 0) + 1);

      } catch (error) {
        errors.push({
          code: 'BINDING_CONVERSION_ERROR',
          message: `Failed to convert binding '${binding.name}': ${error instanceof Error ? error.message : 'Unknown error'}`,
          sourcePath: `bindings.${binding.name}`,
          sourceElement: binding.name,
          recoverable: true,
        });
      }
    }
  }

  /**
   * WSDL 메시지를 EAI 엔티티로 변환
   */
  private async convertMessages(
    schema: WSDLSchema, 
    eaiSchema: EAISchemaModel, 
    context: ConversionContext,
    errors: ConversionError[],
    warnings: ConversionWarning[]
  ): Promise<void> {
    if (!schema.messages) return;

    for (const message of schema.messages) {
      try {
        const eaiEntity: EAIEntity = {
          id: uuidv4(),
          name: message.name,
          namespace: schema.metadata.targetNamespace,
          description: message.documentation,
          properties: message.parts?.map(part => ({
            name: part.name,
            type: part.type || part.element || 'string',
            isRequired: true,
            isArray: false,
            constraints: [],
            annotations: [],
            sourceMapping: {
              sourceType: SchemaType.WSDL,
              sourcePath: `messages.${message.name}.parts.${part.name}`,
              sourceElement: part.name,
              transformationRules: ['wsdl-message-part-to-property'],
              confidence: 90,
            },
          })) || [],
          relationships: [],
          constraints: [],
          annotations: [],
          sourceMapping: {
            sourceType: SchemaType.WSDL,
            sourcePath: `messages.${message.name}`,
            sourceElement: message.name,
            transformationRules: ['wsdl-message-to-entity'],
            confidence: 85,
          },
        };

        eaiSchema.addEntity(eaiEntity);
        context.statistics.rulesApplied.set('wsdl-message-to-entity', 
          (context.statistics.rulesApplied.get('wsdl-message-to-entity') || 0) + 1);

      } catch (error) {
        errors.push({
          code: 'MESSAGE_CONVERSION_ERROR',
          message: `Failed to convert message '${message.name}': ${error instanceof Error ? error.message : 'Unknown error'}`,
          sourcePath: `messages.${message.name}`,
          sourceElement: message.name,
          recoverable: true,
        });
      }
    }
  }

  /**
   * WSDL 요소를 EAI 프로퍼티로 변환
   */
  private convertElementToProperty(element: any, context: ConversionContext): EAIProperty {
    return {
      name: element.name,
      type: element.type || 'string',
      isRequired: element.minOccurs !== '0',
      isArray: element.maxOccurs === 'unbounded' || (element.maxOccurs && parseInt(element.maxOccurs) > 1),
      constraints: [],
      annotations: [],
      sourceMapping: {
        sourceType: SchemaType.WSDL,
        sourcePath: `elements.${element.name}`,
        sourceElement: element.name,
        transformationRules: ['wsdl-element-to-property'],
        confidence: 90,
      },
    };
  }

  /**
   * WSDL 타입 카테고리를 EAI 타입 카테고리로 매핑
   */
  private mapTypeCategory(category: string): TypeCategory {
    switch (category?.toLowerCase()) {
      case 'complextype':
        return TypeCategory.COMPLEX;
      case 'simpletype':
        return TypeCategory.SIMPLE;
      case 'enumeration':
        return TypeCategory.ENUMERATION;
      case 'union':
        return TypeCategory.UNION;
      case 'list':
        return TypeCategory.LIST;
      default:
        return TypeCategory.PRIMITIVE;
    }
  }

  /**
   * WSDL 오퍼레이션 타입을 EAI 오퍼레이션 타입으로 매핑
   */
  private mapOperationType(type: string): OperationType {
    switch (type?.toLowerCase()) {
      case 'request-response':
        return OperationType.REQUEST_RESPONSE;
      case 'one-way':
        return OperationType.ONE_WAY;
      case 'notification':
        return OperationType.NOTIFICATION;
      case 'solicit-response':
        return OperationType.SOLICIT_RESPONSE;
      default:
        return OperationType.REQUEST_RESPONSE;
    }
  }

  /**
   * WSDL 바인딩 타입을 EAI 바인딩 타입으로 매핑
   */
  private mapBindingType(type: string): BindingType {
    switch (type?.toLowerCase()) {
      case 'soap':
      case 'soap11':
      case 'soap12':
        return BindingType.SOAP;
      case 'http':
        return BindingType.HTTP;
      case 'rest':
        return BindingType.REST;
      default:
        return BindingType.SOAP;
    }
  }

  /**
   * WSDL 요소 개수 계산
   */
  private countWSDLElements(schema: WSDLSchema): number {
    let count = 0;
    count += schema.services?.length || 0;
    count += schema.portTypes?.length || 0;
    count += schema.messages?.length || 0;
    count += schema.bindings?.length || 0;
    count += schema.types?.length || 0;
    return count;
  }

  /**
   * 지원하는 소스 타입 반환
   */
  getSupportedSourceTypes(): SchemaType[] {
    return [SchemaType.WSDL];
  }

  /**
   * 기본 변환 옵션 반환
   */
  getDefaultOptions(): ConversionOptions {
    return {
      preserveNamespaces: true,
      generateIds: true,
      includeDocumentation: true,
      includeAnnotations: true,
      strictMode: false,
      customTypeMapping: {},
      excludePatterns: [],
      includePatterns: [],
      maxDepth: 10,
      enableOptimizations: true,
    };
  }

  /**
   * 입력 스키마 검증
   */
  async validateInput(schema: WSDLSchema): Promise<boolean> {
    if (!schema) return false;
    if (!schema.metadata) return false;
    if (!schema.services && !schema.portTypes && !schema.messages) return false;
    return true;
  }
}