// EAI 스키마 모델 구현
import { 
  EAISchema, 
  EAISchemaMetadata, 
  EAIEntity, 
  EAIOperation, 
  EAITypeDefinition,
  EAIBinding,
  EAIAnnotation,
  SourceMapping,
  ConversionContext
} from '../types';
import { SchemaType } from '@eai-toolkit/shared';
import { v4 as uuidv4 } from 'uuid';

/**
 * EAI 스키마 모델 클래스
 * 통합된 EAI 스키마 구조를 관리하고 조작하는 기능을 제공
 */
export class EAISchemaModel implements EAISchema {
  public version: string;
  public metadata: EAISchemaMetadata;
  public entities: EAIEntity[];
  public operations: EAIOperation[];
  public types: EAITypeDefinition[];
  public bindings: EAIBinding[];
  public extensions: Record<string, any>;

  constructor(metadata: Partial<EAISchemaMetadata> = {}) {
    this.version = '1.0.0';
    this.metadata = this.createMetadata(metadata);
    this.entities = [];
    this.operations = [];
    this.types = [];
    this.bindings = [];
    this.extensions = {};
  }

  /**
   * 메타데이터 생성
   */
  private createMetadata(partial: Partial<EAISchemaMetadata>): EAISchemaMetadata {
    const now = new Date();
    return {
      id: partial.id || uuidv4(),
      name: partial.name || 'Unnamed Schema',
      description: partial.description,
      namespace: partial.namespace || 'http://eai-toolkit.com/schema',
      version: partial.version || '1.0.0',
      sourceType: partial.sourceType || SchemaType.EAI,
      createdAt: partial.createdAt || now,
      updatedAt: partial.updatedAt || now,
      tags: partial.tags || [],
      annotations: partial.annotations || [],
    };
  }

  /**
   * 엔티티 추가
   */
  addEntity(entity: EAIEntity): void {
    // 중복 체크
    const existingEntity = this.entities.find(e => e.name === entity.name && e.namespace === entity.namespace);
    if (existingEntity) {
      throw new Error(`Entity with name '${entity.name}' already exists in namespace '${entity.namespace}'`);
    }

    this.entities.push(entity);
    this.updateTimestamp();
  }

  /**
   * 오퍼레이션 추가
   */
  addOperation(operation: EAIOperation): void {
    // 중복 체크
    const existingOperation = this.operations.find(o => o.name === operation.name);
    if (existingOperation) {
      throw new Error(`Operation with name '${operation.name}' already exists`);
    }

    this.operations.push(operation);
    this.updateTimestamp();
  }

  /**
   * 타입 정의 추가
   */
  addType(type: EAITypeDefinition): void {
    // 중복 체크
    const existingType = this.types.find(t => t.name === type.name && t.namespace === type.namespace);
    if (existingType) {
      throw new Error(`Type with name '${type.name}' already exists in namespace '${type.namespace}'`);
    }

    this.types.push(type);
    this.updateTimestamp();
  }

  /**
   * 바인딩 추가
   */
  addBinding(binding: EAIBinding): void {
    // 중복 체크
    const existingBinding = this.bindings.find(b => b.name === binding.name);
    if (existingBinding) {
      throw new Error(`Binding with name '${binding.name}' already exists`);
    }

    this.bindings.push(binding);
    this.updateTimestamp();
  }

  /**
   * 엔티티 검색
   */
  findEntity(name: string, namespace?: string): EAIEntity | undefined {
    return this.entities.find(e => 
      e.name === name && 
      (namespace === undefined || e.namespace === namespace)
    );
  }

  /**
   * 오퍼레이션 검색
   */
  findOperation(name: string): EAIOperation | undefined {
    return this.operations.find(o => o.name === name);
  }

  /**
   * 타입 검색
   */
  findType(name: string, namespace?: string): EAITypeDefinition | undefined {
    return this.types.find(t => 
      t.name === name && 
      (namespace === undefined || t.namespace === namespace)
    );
  }

  /**
   * 바인딩 검색
   */
  findBinding(name: string): EAIBinding | undefined {
    return this.bindings.find(b => b.name === name);
  }

  /**
   * 네임스페이스별 엔티티 그룹화
   */
  getEntitiesByNamespace(): Map<string, EAIEntity[]> {
    const namespaceMap = new Map<string, EAIEntity[]>();
    
    this.entities.forEach(entity => {
      const namespace = entity.namespace || 'default';
      if (!namespaceMap.has(namespace)) {
        namespaceMap.set(namespace, []);
      }
      namespaceMap.get(namespace)!.push(entity);
    });

    return namespaceMap;
  }

  /**
   * 타입별 오퍼레이션 그룹화
   */
  getOperationsByType(): Map<string, EAIOperation[]> {
    const typeMap = new Map<string, EAIOperation[]>();
    
    this.operations.forEach(operation => {
      const type = operation.type;
      if (!typeMap.has(type)) {
        typeMap.set(type, []);
      }
      typeMap.get(type)!.push(operation);
    });

    return typeMap;
  }

  /**
   * 스키마 통계 정보 생성
   */
  getStatistics(): EAISchemaStatistics {
    return {
      totalEntities: this.entities.length,
      totalOperations: this.operations.length,
      totalTypes: this.types.length,
      totalBindings: this.bindings.length,
      namespaces: Array.from(new Set(this.entities.map(e => e.namespace).filter(Boolean))),
      operationTypes: Array.from(new Set(this.operations.map(o => o.type))),
      typeCategories: Array.from(new Set(this.types.map(t => t.category))),
      bindingTypes: Array.from(new Set(this.bindings.map(b => b.type))),
      complexity: this.calculateComplexity(),
    };
  }

  /**
   * 스키마 복잡도 계산
   */
  private calculateComplexity(): ComplexityScore {
    const entityComplexity = this.entities.reduce((sum, entity) => {
      return sum + entity.properties.length + entity.relationships.length;
    }, 0);

    const operationComplexity = this.operations.reduce((sum, operation) => {
      return sum + operation.inputParameters.length + operation.outputParameters.length;
    }, 0);

    const typeComplexity = this.types.reduce((sum, type) => {
      return sum + (type.properties?.length || 0) + type.restrictions.length;
    }, 0);

    const totalComplexity = entityComplexity + operationComplexity + typeComplexity;

    return {
      total: totalComplexity,
      entity: entityComplexity,
      operation: operationComplexity,
      type: typeComplexity,
      score: this.normalizeComplexityScore(totalComplexity),
    };
  }

  /**
   * 복잡도 점수 정규화 (0-100)
   */
  private normalizeComplexityScore(complexity: number): number {
    // 간단한 로그 스케일 정규화
    if (complexity === 0) return 0;
    const normalized = Math.min(100, Math.log10(complexity + 1) * 20);
    return Math.round(normalized);
  }

  /**
   * 스키마 검증
   */
  validate(): EAISchemaValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    // 메타데이터 검증
    if (!this.metadata.name.trim()) {
      errors.push('Schema name is required');
    }

    if (!this.metadata.namespace.trim()) {
      errors.push('Schema namespace is required');
    }

    // 엔티티 검증
    this.entities.forEach((entity, index) => {
      if (!entity.name.trim()) {
        errors.push(`Entity at index ${index} has empty name`);
      }

      // 프로퍼티 검증
      entity.properties.forEach((prop, propIndex) => {
        if (!prop.name.trim()) {
          errors.push(`Property at index ${propIndex} in entity '${entity.name}' has empty name`);
        }
        if (!prop.type.trim()) {
          errors.push(`Property '${prop.name}' in entity '${entity.name}' has empty type`);
        }
      });

      // 관계 검증
      entity.relationships.forEach((rel, relIndex) => {
        if (!rel.target.trim()) {
          errors.push(`Relationship at index ${relIndex} in entity '${entity.name}' has empty target`);
        }
        
        // 타겟 엔티티 존재 확인
        if (!this.findEntity(rel.target)) {
          warnings.push(`Relationship '${rel.name}' in entity '${entity.name}' references non-existent entity '${rel.target}'`);
        }
      });
    });

    // 오퍼레이션 검증
    this.operations.forEach((operation, index) => {
      if (!operation.name.trim()) {
        errors.push(`Operation at index ${index} has empty name`);
      }

      // 파라미터 검증
      [...operation.inputParameters, ...operation.outputParameters].forEach((param, paramIndex) => {
        if (!param.name.trim()) {
          errors.push(`Parameter at index ${paramIndex} in operation '${operation.name}' has empty name`);
        }
        if (!param.type.trim()) {
          errors.push(`Parameter '${param.name}' in operation '${operation.name}' has empty type`);
        }
      });
    });

    // 타입 정의 검증
    this.types.forEach((type, index) => {
      if (!type.name.trim()) {
        errors.push(`Type at index ${index} has empty name`);
      }

      // 베이스 타입 존재 확인
      if (type.baseType && !this.findType(type.baseType)) {
        warnings.push(`Type '${type.name}' extends non-existent base type '${type.baseType}'`);
      }
    });

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      statistics: this.getStatistics(),
    };
  }

  /**
   * 스키마를 JSON으로 직렬화
   */
  toJSON(): string {
    return JSON.stringify({
      version: this.version,
      metadata: this.metadata,
      entities: this.entities,
      operations: this.operations,
      types: this.types,
      bindings: this.bindings,
      extensions: this.extensions,
    }, null, 2);
  }

  /**
   * JSON에서 스키마 복원
   */
  static fromJSON(json: string): EAISchemaModel {
    const data = JSON.parse(json);
    const schema = new EAISchemaModel(data.metadata);
    
    schema.version = data.version;
    schema.entities = data.entities || [];
    schema.operations = data.operations || [];
    schema.types = data.types || [];
    schema.bindings = data.bindings || [];
    schema.extensions = data.extensions || {};

    return schema;
  }

  /**
   * 스키마 복제
   */
  clone(): EAISchemaModel {
    return EAISchemaModel.fromJSON(this.toJSON());
  }

  /**
   * 스키마 병합
   */
  merge(other: EAISchemaModel): EAISchemaModel {
    const merged = this.clone();

    // 엔티티 병합 (중복 시 다른 스키마 우선)
    other.entities.forEach(entity => {
      const existing = merged.findEntity(entity.name, entity.namespace);
      if (!existing) {
        merged.addEntity(entity);
      }
    });

    // 오퍼레이션 병합
    other.operations.forEach(operation => {
      const existing = merged.findOperation(operation.name);
      if (!existing) {
        merged.addOperation(operation);
      }
    });

    // 타입 병합
    other.types.forEach(type => {
      const existing = merged.findType(type.name, type.namespace);
      if (!existing) {
        merged.addType(type);
      }
    });

    // 바인딩 병합
    other.bindings.forEach(binding => {
      const existing = merged.findBinding(binding.name);
      if (!existing) {
        merged.addBinding(binding);
      }
    });

    // 확장 병합
    merged.extensions = { ...merged.extensions, ...other.extensions };

    return merged;
  }

  /**
   * 타임스탬프 업데이트
   */
  private updateTimestamp(): void {
    this.metadata.updatedAt = new Date();
  }
}

// 스키마 통계 인터페이스
export interface EAISchemaStatistics {
  totalEntities: number;
  totalOperations: number;
  totalTypes: number;
  totalBindings: number;
  namespaces: string[];
  operationTypes: string[];
  typeCategories: string[];
  bindingTypes: string[];
  complexity: ComplexityScore;
}

export interface ComplexityScore {
  total: number;
  entity: number;
  operation: number;
  type: number;
  score: number; // 0-100
}

// 스키마 검증 결과 인터페이스
export interface EAISchemaValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  statistics: EAISchemaStatistics;
}