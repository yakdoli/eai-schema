// 스키마 변환 매니저
import { 
  ConversionManager, 
  SchemaConverter, 
  ConversionContext, 
  ConversionResult, 
  ConversionOptions,
  ConversionStatistics,
  ConversionError,
  ConversionWarning
} from '../types';
import { SchemaType, AnySourceSchema } from '@eai-toolkit/shared';
import { WSDLConverter } from '../converters/wsdl-converter';
import { XSDConverter } from '../converters/xsd-converter';
import { OpenAPIConverter } from '../converters/openapi-converter';
import { SchemaConversionRuleEngine } from '../rules/conversion-rule-engine';
import { v4 as uuidv4 } from 'uuid';

/**
 * 스키마 변환을 관리하는 중앙 매니저 클래스
 */
export class SchemaConversionManager implements ConversionManager {
  private converters: Map<SchemaType, SchemaConverter> = new Map();
  private ruleEngine: SchemaConversionRuleEngine;
  private defaultOptions: ConversionOptions;

  constructor() {
    this.ruleEngine = new SchemaConversionRuleEngine();
    this.defaultOptions = this.createDefaultOptions();
    this.initializeConverters();
  }

  /**
   * 기본 변환기들 초기화
   */
  private initializeConverters(): void {
    this.registerConverter(SchemaType.WSDL, new WSDLConverter());
    this.registerConverter(SchemaType.XSD, new XSDConverter());
    this.registerConverter(SchemaType.OPENAPI, new OpenAPIConverter());
  }

  /**
   * 기본 변환 옵션 생성
   */
  private createDefaultOptions(): ConversionOptions {
    return {
      preserveNamespaces: true,
      generateIds: true,
      includeDocumentation: true,
      includeAnnotations: true,
      strictMode: false,
      customTypeMapping: {},
      excludePatterns: [],
      includePatterns: [],
      maxDepth: 10,
      enableOptimizations: true,
    };
  }

  /**
   * 변환기 등록
   */
  registerConverter(type: SchemaType, converter: SchemaConverter): void {
    if (!converter) {
      throw new Error(`Converter for type '${type}' cannot be null or undefined`);
    }

    // 변환기가 해당 타입을 지원하는지 확인
    const supportedTypes = converter.getSupportedSourceTypes();
    if (!supportedTypes.includes(type)) {
      throw new Error(`Converter does not support source type '${type}'`);
    }

    this.converters.set(type, converter);
  }

  /**
   * 변환기 등록 해제
   */
  unregisterConverter(type: SchemaType): void {
    if (!this.converters.has(type)) {
      throw new Error(`No converter registered for type '${type}'`);
    }

    this.converters.delete(type);
  }

  /**
   * 변환기 조회
   */
  getConverter(type: SchemaType): SchemaConverter | undefined {
    return this.converters.get(type);
  }

  /**
   * 스키마 변환 실행
   */
  async convert(schema: AnySourceSchema, options?: Partial<ConversionOptions>): Promise<ConversionResult> {
    const startTime = Date.now();
    
    try {
      // 스키마 타입 감지
      const schemaType = this.detectSchemaType(schema);
      if (!schemaType) {
        return this.createErrorResult('SCHEMA_TYPE_DETECTION_FAILED', 'Unable to detect schema type', startTime);
      }

      // 변환기 조회
      const converter = this.getConverter(schemaType);
      if (!converter) {
        return this.createErrorResult('CONVERTER_NOT_FOUND', `No converter available for schema type '${schemaType}'`, startTime);
      }

      // 변환 옵션 병합
      const mergedOptions = this.mergeOptions(options);

      // 변환 컨텍스트 생성
      const context = await this.createConversionContext(schema, schemaType, mergedOptions);

      // 입력 스키마 검증
      const isValidInput = await converter.validateInput(schema);
      if (!isValidInput) {
        return this.createErrorResult('INVALID_INPUT_SCHEMA', 'Input schema validation failed', startTime);
      }

      // 변환 실행
      const result = await converter.convert(schema, context);

      // 후처리
      await this.postProcessResult(result, context);

      return result;

    } catch (error) {
      return this.createErrorResult(
        'CONVERSION_FAILED', 
        `Conversion failed: ${error instanceof Error ? error.message : 'Unknown error'}`, 
        startTime,
        error
      );
    }
  }

  /**
   * 스키마 타입 감지
   */
  private detectSchemaType(schema: AnySourceSchema): SchemaType | null {
    // 스키마 객체의 특성을 기반으로 타입 감지
    if (this.isWSDLSchema(schema)) {
      return SchemaType.WSDL;
    }
    
    if (this.isXSDSchema(schema)) {
      return SchemaType.XSD;
    }
    
    if (this.isOpenAPISchema(schema)) {
      return SchemaType.OPENAPI;
    }

    if (this.isJSONSchema(schema)) {
      return SchemaType.JSON_SCHEMA;
    }

    // SAP 스키마 타입들
    if (this.isSAPODataSchema(schema)) {
      return SchemaType.SAP_ODATA;
    }

    if (this.isSAPIDocSchema(schema)) {
      return SchemaType.SAP_IDOC;
    }

    if (this.isSAPRFCSchema(schema)) {
      return SchemaType.SAP_RFC;
    }

    return null;
  }

  /**
   * 스키마 타입 감지 헬퍼 메서드들
   */
  private isWSDLSchema(schema: any): boolean {
    return schema && 
           schema.metadata && 
           (schema.services || schema.portTypes || schema.messages || schema.bindings);
  }

  private isXSDSchema(schema: any): boolean {
    return schema && 
           schema.metadata && 
           (schema.elements || schema.complexTypes || schema.simpleTypes);
  }

  private isOpenAPISchema(schema: any): boolean {
    return schema && 
           (schema.openapi || schema.swagger) && 
           schema.info && 
           schema.paths;
  }

  private isJSONSchema(schema: any): boolean {
    return schema && 
           (schema.$schema || schema.type || schema.properties);
  }

  private isSAPODataSchema(schema: any): boolean {
    return schema && 
           schema.metadata && 
           (schema.entitySets || schema.entityTypes);
  }

  private isSAPIDocSchema(schema: any): boolean {
    return schema && 
           schema.metadata && 
           schema.segments;
  }

  private isSAPRFCSchema(schema: any): boolean {
    return schema && 
           schema.metadata && 
           schema.functionName;
  }

  /**
   * 변환 옵션 병합
   */
  private mergeOptions(options?: Partial<ConversionOptions>): ConversionOptions {
    return {
      ...this.defaultOptions,
      ...options,
      customTypeMapping: {
        ...this.defaultOptions.customTypeMapping,
        ...(options?.customTypeMapping || {}),
      },
    };
  }

  /**
   * 변환 컨텍스트 생성
   */
  private async createConversionContext(
    sourceSchema: AnySourceSchema, 
    sourceType: SchemaType, 
    options: ConversionOptions
  ): Promise<ConversionContext> {
    const context: ConversionContext = {
      sourceSchema,
      targetType: SchemaType.EAI,
      options,
      rules: this.ruleEngine.getRules(),
      customRules: this.ruleEngine.getCustomRules(),
      namespaceMap: new Map(),
      typeMap: new Map(),
      warnings: [],
      statistics: {
        totalElements: 0,
        convertedElements: 0,
        skippedElements: 0,
        errorElements: 0,
        warningElements: 0,
        processingTime: 0,
        memoryUsage: 0,
        rulesApplied: new Map(),
      },
    };

    // 네임스페이스 매핑 초기화
    await this.initializeNamespaceMapping(context);

    // 타입 매핑 초기화
    await this.initializeTypeMapping(context);

    return context;
  }

  /**
   * 네임스페이스 매핑 초기화
   */
  private async initializeNamespaceMapping(context: ConversionContext): Promise<void> {
    const sourceSchema = context.sourceSchema;
    
    if (sourceSchema.metadata?.targetNamespace) {
      context.namespaceMap.set('target', sourceSchema.metadata.targetNamespace);
    }

    // 추가 네임스페이스 매핑 로직
    if (sourceSchema.metadata?.imports) {
      for (const importItem of sourceSchema.metadata.imports) {
        if (importItem.namespace && importItem.location) {
          context.namespaceMap.set(importItem.location, importItem.namespace);
        }
      }
    }
  }

  /**
   * 타입 매핑 초기화
   */
  private async initializeTypeMapping(context: ConversionContext): Promise<void> {
    // 기본 타입 매핑
    const defaultTypeMappings = {
      'string': 'string',
      'int': 'integer',
      'integer': 'integer',
      'long': 'long',
      'float': 'decimal',
      'double': 'decimal',
      'decimal': 'decimal',
      'boolean': 'boolean',
      'date': 'date',
      'dateTime': 'datetime',
      'time': 'time',
      'base64Binary': 'binary',
      'hexBinary': 'binary',
    };

    for (const [source, target] of Object.entries(defaultTypeMappings)) {
      context.typeMap.set(source, target);
    }

    // 커스텀 타입 매핑 추가
    for (const [source, target] of Object.entries(context.options.customTypeMapping)) {
      context.typeMap.set(source, target);
    }
  }

  /**
   * 결과 후처리
   */
  private async postProcessResult(result: ConversionResult, context: ConversionContext): Promise<void> {
    if (!result.success || !result.eaiSchema) {
      return;
    }

    // 스키마 검증
    const validationResult = result.eaiSchema.validate();
    if (!validationResult.isValid) {
      // 검증 에러를 경고로 변환
      for (const error of validationResult.errors) {
        const warning: ConversionWarning = {
          code: 'SCHEMA_VALIDATION_ERROR',
          message: error,
          sourcePath: 'post-processing',
          impact: 'MEDIUM' as any,
          suggestion: 'Review the converted schema for consistency',
        };
        result.warnings.push(warning);
      }
    }

    // 통계 정보 업데이트
    const schemaStats = result.eaiSchema.getStatistics();
    context.statistics.convertedElements = schemaStats.totalEntities + schemaStats.totalOperations + schemaStats.totalTypes;

    // 메모리 사용량 추정 (간단한 구현)
    context.statistics.memoryUsage = this.estimateMemoryUsage(result.eaiSchema);
  }

  /**
   * 메모리 사용량 추정
   */
  private estimateMemoryUsage(eaiSchema: any): number {
    // JSON 직렬화 크기를 기반으로 한 간단한 추정
    try {
      const jsonString = JSON.stringify(eaiSchema);
      return jsonString.length * 2; // UTF-16 문자당 2바이트 추정
    } catch {
      return 0;
    }
  }

  /**
   * 에러 결과 생성
   */
  private createErrorResult(
    code: string, 
    message: string, 
    startTime: number, 
    details?: any
  ): ConversionResult {
    const error: ConversionError = {
      code,
      message,
      sourcePath: 'root',
      details,
      recoverable: false,
    };

    return {
      success: false,
      errors: [error],
      warnings: [],
      statistics: {
        totalElements: 0,
        convertedElements: 0,
        skippedElements: 0,
        errorElements: 1,
        warningElements: 0,
        processingTime: Date.now() - startTime,
        memoryUsage: 0,
        rulesApplied: new Map(),
      },
      metadata: {
        conversionId: uuidv4(),
        sourceType: SchemaType.WSDL, // 기본값
        targetType: SchemaType.EAI,
        startTime: new Date(startTime),
        endTime: new Date(),
        duration: Date.now() - startTime,
        rulesVersion: '1.0.0',
        engineVersion: '1.0.0',
      },
    };
  }

  /**
   * 지원하는 변환 타입 반환
   */
  getSupportedConversions(): SchemaType[] {
    return Array.from(this.converters.keys());
  }

  /**
   * 변환 통계 반환
   */
  getConversionStatistics(): Map<SchemaType, number> {
    const statistics = new Map<SchemaType, number>();
    
    // 실제 구현에서는 변환 이력을 추적해야 함
    for (const type of this.converters.keys()) {
      statistics.set(type, 0);
    }

    return statistics;
  }

  /**
   * 규칙 엔진 접근자
   */
  getRuleEngine(): SchemaConversionRuleEngine {
    return this.ruleEngine;
  }

  /**
   * 기본 옵션 설정
   */
  setDefaultOptions(options: Partial<ConversionOptions>): void {
    this.defaultOptions = {
      ...this.defaultOptions,
      ...options,
      customTypeMapping: {
        ...this.defaultOptions.customTypeMapping,
        ...(options.customTypeMapping || {}),
      },
    };
  }

  /**
   * 변환기 정보 반환
   */
  getConverterInfo(): Array<{ type: SchemaType; supportedTypes: SchemaType[] }> {
    const info: Array<{ type: SchemaType; supportedTypes: SchemaType[] }> = [];

    for (const [type, converter] of this.converters.entries()) {
      info.push({
        type,
        supportedTypes: converter.getSupportedSourceTypes(),
      });
    }

    return info;
  }

  /**
   * 변환 가능 여부 확인
   */
  canConvert(sourceType: SchemaType): boolean {
    return this.converters.has(sourceType);
  }

  /**
   * 배치 변환 (여러 스키마 동시 변환)
   */
  async convertBatch(
    schemas: Array<{ schema: AnySourceSchema; options?: Partial<ConversionOptions> }>
  ): Promise<ConversionResult[]> {
    const results: ConversionResult[] = [];

    // 병렬 처리
    const promises = schemas.map(({ schema, options }) => this.convert(schema, options));
    const batchResults = await Promise.allSettled(promises);

    for (const result of batchResults) {
      if (result.status === 'fulfilled') {
        results.push(result.value);
      } else {
        // 실패한 변환에 대한 에러 결과 생성
        results.push(this.createErrorResult(
          'BATCH_CONVERSION_FAILED',
          `Batch conversion failed: ${result.reason}`,
          Date.now(),
          result.reason
        ));
      }
    }

    return results;
  }

  /**
   * 변환 프리뷰 (실제 변환 없이 결과 미리보기)
   */
  async previewConversion(
    schema: AnySourceSchema, 
    options?: Partial<ConversionOptions>
  ): Promise<{ 
    canConvert: boolean; 
    estimatedElements: number; 
    warnings: ConversionWarning[]; 
    supportedFeatures: string[] 
  }> {
    const schemaType = this.detectSchemaType(schema);
    const canConvert = schemaType ? this.canConvert(schemaType) : false;
    
    if (!canConvert || !schemaType) {
      return {
        canConvert: false,
        estimatedElements: 0,
        warnings: [{
          code: 'UNSUPPORTED_SCHEMA_TYPE',
          message: 'Schema type is not supported for conversion',
          sourcePath: 'root',
          impact: 'CRITICAL' as any,
        }],
        supportedFeatures: [],
      };
    }

    const converter = this.getConverter(schemaType)!;
    const mergedOptions = this.mergeOptions(options);
    const context = await this.createConversionContext(schema, schemaType, mergedOptions);

    // 요소 수 추정
    const estimatedElements = this.estimateElementCount(schema, schemaType);

    // 지원 기능 목록
    const supportedFeatures = this.getSupportedFeatures(schemaType);

    return {
      canConvert: true,
      estimatedElements,
      warnings: context.warnings,
      supportedFeatures,
    };
  }

  /**
   * 요소 수 추정
   */
  private estimateElementCount(schema: AnySourceSchema, schemaType: SchemaType): number {
    let count = 0;

    switch (schemaType) {
      case SchemaType.WSDL:
        const wsdlSchema = schema as any;
        count += wsdlSchema.services?.length || 0;
        count += wsdlSchema.portTypes?.length || 0;
        count += wsdlSchema.messages?.length || 0;
        count += wsdlSchema.types?.length || 0;
        break;

      case SchemaType.XSD:
        const xsdSchema = schema as any;
        count += xsdSchema.elements?.length || 0;
        count += xsdSchema.complexTypes?.length || 0;
        count += xsdSchema.simpleTypes?.length || 0;
        break;

      case SchemaType.OPENAPI:
        const openApiSchema = schema as any;
        count += Object.keys(openApiSchema.paths || {}).length;
        count += Object.keys(openApiSchema.components?.schemas || {}).length;
        break;
    }

    return count;
  }

  /**
   * 지원 기능 목록 반환
   */
  private getSupportedFeatures(schemaType: SchemaType): string[] {
    const commonFeatures = [
      'Entity Conversion',
      'Type Mapping',
      'Namespace Preservation',
      'Documentation Preservation',
    ];

    switch (schemaType) {
      case SchemaType.WSDL:
        return [
          ...commonFeatures,
          'Service to Operation Mapping',
          'Message to Entity Conversion',
          'SOAP Binding Support',
          'Port Type Processing',
        ];

      case SchemaType.XSD:
        return [
          ...commonFeatures,
          'Complex Type to Entity',
          'Simple Type to Type Definition',
          'Element to Property Mapping',
          'Inheritance Relationship',
          'Constraint Preservation',
        ];

      case SchemaType.OPENAPI:
        return [
          ...commonFeatures,
          'Path to Operation Mapping',
          'Schema to Entity Conversion',
          'Parameter Mapping',
          'HTTP Method Support',
          'Security Schema Processing',
        ];

      default:
        return commonFeatures;
    }
  }
}