// 변환 규칙 엔진 구현
import { 
  ConversionRuleEngine, 
  ConversionRule, 
  CustomConversionRule, 
  ConversionContext,
  ConversionWarning,
  ConversionImpact
} from '../types';

/**
 * 스키마 변환 규칙을 관리하고 적용하는 엔진
 */
export class SchemaConversionRuleEngine implements ConversionRuleEngine {
  private rules: Map<string, ConversionRule> = new Map();
  private customRules: Map<string, CustomConversionRule> = new Map();
  private ruleCategories: Map<string, string[]> = new Map();

  constructor() {
    this.initializeDefaultRules();
  }

  /**
   * 기본 변환 규칙 초기화
   */
  private initializeDefaultRules(): void {
    // WSDL 변환 규칙
    this.addDefaultRule({
      id: 'wsdl-service-to-operations',
      name: 'WSDL Service to Operations',
      description: 'WSDL 서비스의 오퍼레이션을 EAI 오퍼레이션으로 변환',
      sourcePattern: 'wsdl.services.*.operations.*',
      targetPattern: 'eai.operations.*',
      transformation: 'service_operation_mapping',
      priority: 100,
      applied: false,
      appliedCount: 0,
    });

    this.addDefaultRule({
      id: 'wsdl-message-to-entity',
      name: 'WSDL Message to Entity',
      description: 'WSDL 메시지를 EAI 엔티티로 변환',
      sourcePattern: 'wsdl.messages.*',
      targetPattern: 'eai.entities.*',
      transformation: 'message_entity_mapping',
      priority: 90,
      applied: false,
      appliedCount: 0,
    });

    this.addDefaultRule({
      id: 'wsdl-complextype-to-entity',
      name: 'WSDL ComplexType to Entity',
      description: 'WSDL 복합 타입을 EAI 엔티티로 변환',
      sourcePattern: 'wsdl.types.complexType.*',
      targetPattern: 'eai.entities.*',
      transformation: 'complextype_entity_mapping',
      priority: 85,
      applied: false,
      appliedCount: 0,
    });

    // XSD 변환 규칙
    this.addDefaultRule({
      id: 'xsd-complextype-to-entity',
      name: 'XSD ComplexType to Entity',
      description: 'XSD 복합 타입을 EAI 엔티티로 변환',
      sourcePattern: 'xsd.complexTypes.*',
      targetPattern: 'eai.entities.*',
      transformation: 'xsd_complextype_mapping',
      priority: 95,
      applied: false,
      appliedCount: 0,
    });

    this.addDefaultRule({
      id: 'xsd-simpletype-to-type',
      name: 'XSD SimpleType to Type',
      description: 'XSD 단순 타입을 EAI 타입 정의로 변환',
      sourcePattern: 'xsd.simpleTypes.*',
      targetPattern: 'eai.types.*',
      transformation: 'xsd_simpletype_mapping',
      priority: 90,
      applied: false,
      appliedCount: 0,
    });

    this.addDefaultRule({
      id: 'xsd-element-to-property',
      name: 'XSD Element to Property',
      description: 'XSD 요소를 EAI 프로퍼티로 변환',
      sourcePattern: 'xsd.*.elements.*',
      targetPattern: 'eai.*.properties.*',
      transformation: 'xsd_element_mapping',
      priority: 80,
      applied: false,
      appliedCount: 0,
    });

    // OpenAPI 변환 규칙
    this.addDefaultRule({
      id: 'openapi-path-to-operation',
      name: 'OpenAPI Path to Operation',
      description: 'OpenAPI 경로를 EAI 오퍼레이션으로 변환',
      sourcePattern: 'openapi.paths.*.*',
      targetPattern: 'eai.operations.*',
      transformation: 'openapi_path_mapping',
      priority: 95,
      applied: false,
      appliedCount: 0,
    });

    this.addDefaultRule({
      id: 'openapi-schema-to-entity',
      name: 'OpenAPI Schema to Entity',
      description: 'OpenAPI 스키마를 EAI 엔티티로 변환',
      sourcePattern: 'openapi.components.schemas.*',
      targetPattern: 'eai.entities.*',
      transformation: 'openapi_schema_mapping',
      priority: 90,
      applied: false,
      appliedCount: 0,
    });

    this.addDefaultRule({
      id: 'openapi-parameter-to-parameter',
      name: 'OpenAPI Parameter to Parameter',
      description: 'OpenAPI 파라미터를 EAI 파라미터로 변환',
      sourcePattern: 'openapi.*.parameters.*',
      targetPattern: 'eai.*.parameters.*',
      transformation: 'openapi_parameter_mapping',
      priority: 85,
      applied: false,
      appliedCount: 0,
    });

    // 공통 변환 규칙
    this.addDefaultRule({
      id: 'namespace-preservation',
      name: 'Namespace Preservation',
      description: '네임스페이스 정보 보존',
      sourcePattern: '*.namespace',
      targetPattern: 'eai.*.namespace',
      transformation: 'namespace_mapping',
      priority: 70,
      applied: false,
      appliedCount: 0,
    });

    this.addDefaultRule({
      id: 'documentation-preservation',
      name: 'Documentation Preservation',
      description: '문서화 정보 보존',
      sourcePattern: '*.documentation',
      targetPattern: 'eai.*.description',
      transformation: 'documentation_mapping',
      priority: 60,
      applied: false,
      appliedCount: 0,
    });

    // 규칙 카테고리 설정
    this.ruleCategories.set('wsdl', [
      'wsdl-service-to-operations',
      'wsdl-message-to-entity',
      'wsdl-complextype-to-entity',
    ]);

    this.ruleCategories.set('xsd', [
      'xsd-complextype-to-entity',
      'xsd-simpletype-to-type',
      'xsd-element-to-property',
    ]);

    this.ruleCategories.set('openapi', [
      'openapi-path-to-operation',
      'openapi-schema-to-entity',
      'openapi-parameter-to-parameter',
    ]);

    this.ruleCategories.set('common', [
      'namespace-preservation',
      'documentation-preservation',
    ]);
  }

  /**
   * 기본 규칙 추가
   */
  private addDefaultRule(rule: ConversionRule): void {
    this.rules.set(rule.id, rule);
  }

  /**
   * 변환 규칙 로드
   */
  loadRules(rules: ConversionRule[]): void {
    for (const rule of rules) {
      this.rules.set(rule.id, rule);
    }
  }

  /**
   * 커스텀 규칙 추가
   */
  addCustomRule(rule: CustomConversionRule): void {
    // 규칙 검증
    if (!rule.id || !rule.name || !rule.transformer) {
      throw new Error('Invalid custom rule: id, name, and transformer are required');
    }

    // 중복 ID 체크
    if (this.customRules.has(rule.id)) {
      throw new Error(`Custom rule with id '${rule.id}' already exists`);
    }

    this.customRules.set(rule.id, rule);
  }

  /**
   * 커스텀 규칙 제거
   */
  removeCustomRule(ruleId: string): void {
    if (!this.customRules.has(ruleId)) {
      throw new Error(`Custom rule with id '${ruleId}' not found`);
    }

    this.customRules.delete(ruleId);
  }

  /**
   * 요소에 규칙 적용
   */
  applyRules(element: any, context: ConversionContext): any {
    let transformedElement = { ...element };
    const appliedRules: string[] = [];

    // 우선순위 순으로 규칙 정렬
    const sortedRules = this.getSortedRules();

    for (const rule of sortedRules) {
      try {
        // 기본 규칙 적용
        if (this.rules.has(rule.id)) {
          const conversionRule = this.rules.get(rule.id)!;
          
          if (this.matchesPattern(element, conversionRule.sourcePattern, context)) {
            transformedElement = this.applyConversionRule(transformedElement, conversionRule, context);
            appliedRules.push(rule.id);
            
            // 적용 통계 업데이트
            conversionRule.applied = true;
            conversionRule.appliedCount++;
            context.statistics.rulesApplied.set(rule.id, 
              (context.statistics.rulesApplied.get(rule.id) || 0) + 1);
          }
        }

        // 커스텀 규칙 적용
        if (this.customRules.has(rule.id)) {
          const customRule = this.customRules.get(rule.id)!;
          
          if (customRule.enabled && this.matchesCustomRule(element, customRule, context)) {
            transformedElement = customRule.transformer(transformedElement, context);
            appliedRules.push(rule.id);
            
            context.statistics.rulesApplied.set(rule.id, 
              (context.statistics.rulesApplied.get(rule.id) || 0) + 1);
          }
        }

      } catch (error) {
        // 규칙 적용 실패 시 경고 추가
        const warning: ConversionWarning = {
          code: 'RULE_APPLICATION_FAILED',
          message: `Failed to apply rule '${rule.id}': ${error instanceof Error ? error.message : 'Unknown error'}`,
          sourcePath: this.getElementPath(element, context),
          impact: ConversionImpact.LOW,
          suggestion: `Review rule '${rule.id}' configuration`,
        };

        context.warnings.push(warning);
      }
    }

    // 적용된 규칙 정보를 메타데이터에 추가
    if (transformedElement && typeof transformedElement === 'object') {
      transformedElement._appliedRules = appliedRules;
    }

    return transformedElement;
  }

  /**
   * 패턴 매칭 검사
   */
  private matchesPattern(element: any, pattern: string, context: ConversionContext): boolean {
    // 간단한 패턴 매칭 구현 (실제로는 더 복잡한 로직 필요)
    const elementPath = this.getElementPath(element, context);
    const regexPattern = pattern
      .replace(/\*/g, '[^.]*')
      .replace(/\.\.\./g, '.*');
    
    const regex = new RegExp(`^${regexPattern}$`);
    return regex.test(elementPath);
  }

  /**
   * 커스텀 규칙 매칭 검사
   */
  private matchesCustomRule(element: any, rule: CustomConversionRule, context: ConversionContext): boolean {
    // 소스 패턴 매칭
    const elementPath = this.getElementPath(element, context);
    if (!rule.sourcePattern.test(elementPath)) {
      return false;
    }

    // 조건 함수 검사
    if (rule.condition && !rule.condition(element, context)) {
      return false;
    }

    return true;
  }

  /**
   * 변환 규칙 적용
   */
  private applyConversionRule(element: any, rule: ConversionRule, context: ConversionContext): any {
    // 변환 타입에 따른 처리
    switch (rule.transformation) {
      case 'service_operation_mapping':
        return this.applyServiceOperationMapping(element, context);
      
      case 'message_entity_mapping':
        return this.applyMessageEntityMapping(element, context);
      
      case 'complextype_entity_mapping':
        return this.applyComplexTypeEntityMapping(element, context);
      
      case 'xsd_complextype_mapping':
        return this.applyXSDComplexTypeMapping(element, context);
      
      case 'xsd_simpletype_mapping':
        return this.applyXSDSimpleTypeMapping(element, context);
      
      case 'xsd_element_mapping':
        return this.applyXSDElementMapping(element, context);
      
      case 'openapi_path_mapping':
        return this.applyOpenAPIPathMapping(element, context);
      
      case 'openapi_schema_mapping':
        return this.applyOpenAPISchemaMapping(element, context);
      
      case 'openapi_parameter_mapping':
        return this.applyOpenAPIParameterMapping(element, context);
      
      case 'namespace_mapping':
        return this.applyNamespaceMapping(element, context);
      
      case 'documentation_mapping':
        return this.applyDocumentationMapping(element, context);
      
      default:
        return element;
    }
  }

  /**
   * 요소 경로 생성
   */
  private getElementPath(element: any, context: ConversionContext): string {
    // 실제 구현에서는 요소의 위치를 추적하는 더 정교한 로직 필요
    if (element && element._path) {
      return element._path;
    }
    
    return `${context.sourceSchema.metadata?.name || 'unknown'}.element`;
  }

  /**
   * 우선순위 순으로 규칙 정렬
   */
  private getSortedRules(): Array<{ id: string; priority: number }> {
    const allRules: Array<{ id: string; priority: number }> = [];

    // 기본 규칙
    for (const rule of this.rules.values()) {
      allRules.push({ id: rule.id, priority: rule.priority });
    }

    // 커스텀 규칙
    for (const rule of this.customRules.values()) {
      if (rule.enabled) {
        allRules.push({ id: rule.id, priority: rule.priority });
      }
    }

    return allRules.sort((a, b) => b.priority - a.priority);
  }

  // 구체적인 변환 매핑 메서드들 (간단한 구현)

  private applyServiceOperationMapping(element: any, context: ConversionContext): any {
    return {
      ...element,
      _eaiType: 'operation',
      _transformedBy: 'service_operation_mapping',
    };
  }

  private applyMessageEntityMapping(element: any, context: ConversionContext): any {
    return {
      ...element,
      _eaiType: 'entity',
      _transformedBy: 'message_entity_mapping',
    };
  }

  private applyComplexTypeEntityMapping(element: any, context: ConversionContext): any {
    return {
      ...element,
      _eaiType: 'entity',
      _transformedBy: 'complextype_entity_mapping',
    };
  }

  private applyXSDComplexTypeMapping(element: any, context: ConversionContext): any {
    return {
      ...element,
      _eaiType: 'entity',
      _transformedBy: 'xsd_complextype_mapping',
    };
  }

  private applyXSDSimpleTypeMapping(element: any, context: ConversionContext): any {
    return {
      ...element,
      _eaiType: 'type',
      _transformedBy: 'xsd_simpletype_mapping',
    };
  }

  private applyXSDElementMapping(element: any, context: ConversionContext): any {
    return {
      ...element,
      _eaiType: 'property',
      _transformedBy: 'xsd_element_mapping',
    };
  }

  private applyOpenAPIPathMapping(element: any, context: ConversionContext): any {
    return {
      ...element,
      _eaiType: 'operation',
      _transformedBy: 'openapi_path_mapping',
    };
  }

  private applyOpenAPISchemaMapping(element: any, context: ConversionContext): any {
    return {
      ...element,
      _eaiType: 'entity',
      _transformedBy: 'openapi_schema_mapping',
    };
  }

  private applyOpenAPIParameterMapping(element: any, context: ConversionContext): any {
    return {
      ...element,
      _eaiType: 'parameter',
      _transformedBy: 'openapi_parameter_mapping',
    };
  }

  private applyNamespaceMapping(element: any, context: ConversionContext): any {
    if (context.options.preserveNamespaces && element.namespace) {
      return {
        ...element,
        _preservedNamespace: element.namespace,
        _transformedBy: 'namespace_mapping',
      };
    }
    return element;
  }

  private applyDocumentationMapping(element: any, context: ConversionContext): any {
    if (context.options.includeDocumentation && element.documentation) {
      return {
        ...element,
        _preservedDocumentation: element.documentation,
        _transformedBy: 'documentation_mapping',
      };
    }
    return element;
  }

  /**
   * 모든 규칙 반환
   */
  getRules(): ConversionRule[] {
    return Array.from(this.rules.values());
  }

  /**
   * 모든 커스텀 규칙 반환
   */
  getCustomRules(): CustomConversionRule[] {
    return Array.from(this.customRules.values());
  }

  /**
   * 카테고리별 규칙 반환
   */
  getRulesByCategory(category: string): ConversionRule[] {
    const ruleIds = this.ruleCategories.get(category) || [];
    return ruleIds
      .map(id => this.rules.get(id))
      .filter(rule => rule !== undefined) as ConversionRule[];
  }

  /**
   * 규칙 통계 반환
   */
  getRuleStatistics(): Map<string, { applied: boolean; appliedCount: number }> {
    const statistics = new Map<string, { applied: boolean; appliedCount: number }>();

    for (const rule of this.rules.values()) {
      statistics.set(rule.id, {
        applied: rule.applied,
        appliedCount: rule.appliedCount,
      });
    }

    return statistics;
  }

  /**
   * 규칙 엔진 리셋
   */
  reset(): void {
    // 적용 통계 리셋
    for (const rule of this.rules.values()) {
      rule.applied = false;
      rule.appliedCount = 0;
    }
  }

  /**
   * 규칙 검증
   */
  validateRule(rule: ConversionRule | CustomConversionRule): boolean {
    if (!rule.id || !rule.name) {
      return false;
    }

    if ('transformer' in rule) {
      // 커스텀 규칙 검증
      return typeof rule.transformer === 'function';
    } else {
      // 기본 규칙 검증
      return Boolean(rule.sourcePattern && rule.targetPattern && rule.transformation);
    }
  }
}