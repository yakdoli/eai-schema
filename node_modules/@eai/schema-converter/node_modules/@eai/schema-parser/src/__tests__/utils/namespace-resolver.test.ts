import { NamespaceResolver } from '../../utils/namespace-resolver';
import { NamespaceContext } from '../../types';

describe('NamespaceResolver', () => {
  let resolver: NamespaceResolver;

  beforeEach(() => {
    resolver = new NamespaceResolver();
  });

  describe('네임스페이스 추출', () => {
    it('기본 네임스페이스 선언을 추출해야 함', () => {
      const xmlContent = `
        <?xml version="1.0" encoding="UTF-8"?>
        <schema xmlns="http://www.w3.org/2001/XMLSchema"
                targetNamespace="http://example.com/test">
        </schema>
      `;

      const namespaces = resolver.extractNamespaces(xmlContent);

      expect(namespaces.defaultNamespace).toBe('http://www.w3.org/2001/XMLSchema');
      expect(namespaces.targetNamespace).toBe('http://example.com/test');
      expect(namespaces.prefixToUri.get('')).toBe('http://www.w3.org/2001/XMLSchema');
    });

    it('접두사가 있는 네임스페이스 선언을 추출해야 함', () => {
      const xmlContent = `
        <?xml version="1.0" encoding="UTF-8"?>
        <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   xmlns:tns="http://example.com/test"
                   xmlns:common="http://example.com/common">
        </xs:schema>
      `;

      const namespaces = resolver.extractNamespaces(xmlContent);

      expect(namespaces.prefixToUri.get('xs')).toBe('http://www.w3.org/2001/XMLSchema');
      expect(namespaces.prefixToUri.get('tns')).toBe('http://example.com/test');
      expect(namespaces.prefixToUri.get('common')).toBe('http://example.com/common');
      
      expect(namespaces.uriToPrefix.get('http://www.w3.org/2001/XMLSchema')).toBe('xs');
      expect(namespaces.uriToPrefix.get('http://example.com/test')).toBe('tns');
      expect(namespaces.uriToPrefix.get('http://example.com/common')).toBe('common');
    });

    it('혼합된 네임스페이스 선언을 처리해야 함', () => {
      const xmlContent = `
        <?xml version="1.0" encoding="UTF-8"?>
        <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   xmlns="http://example.com/default"
                   xmlns:tns="http://example.com/test"
                   targetNamespace="http://example.com/test">
        </xs:schema>
      `;

      const namespaces = resolver.extractNamespaces(xmlContent);

      expect(namespaces.prefixToUri.get('xs')).toBe('http://www.w3.org/2001/XMLSchema');
      expect(namespaces.prefixToUri.get('')).toBe('http://example.com/default');
      expect(namespaces.prefixToUri.get('tns')).toBe('http://example.com/test');
      expect(namespaces.defaultNamespace).toBe('http://example.com/default');
      expect(namespaces.targetNamespace).toBe('http://example.com/test');
    });

    it('잘못된 XML에서도 안전하게 처리해야 함', () => {
      const invalidXml = 'invalid xml content';

      const namespaces = resolver.extractNamespaces(invalidXml);

      expect(namespaces.prefixToUri.size).toBe(0);
      expect(namespaces.uriToPrefix.size).toBe(0);
      expect(namespaces.defaultNamespace).toBeUndefined();
      expect(namespaces.targetNamespace).toBeUndefined();
    });
  });

  describe('네임스페이스 처리', () => {
    it('네임스페이스가 있는 객체를 처리해야 함', () => {
      const data = {
        'xs:schema': {
          '@_targetNamespace': 'http://example.com/test',
          'xs:element': {
            '@_name': 'testElement',
            '@_type': 'xs:string'
          }
        }
      };

      const namespaces: NamespaceContext = {
        prefixToUri: new Map([['xs', 'http://www.w3.org/2001/XMLSchema']]),
        uriToPrefix: new Map([['http://www.w3.org/2001/XMLSchema', 'xs']])
      };

      const processed = resolver.processNamespaces(data, namespaces);

      expect(processed['{http://www.w3.org/2001/XMLSchema}schema']).toBeDefined();
      expect(processed['{http://www.w3.org/2001/XMLSchema}schema']['{http://www.w3.org/2001/XMLSchema}element']).toBeDefined();
    });

    it('배열이 포함된 객체를 처리해야 함', () => {
      const data = {
        'xs:schema': {
          'xs:element': [
            { '@_name': 'element1' },
            { '@_name': 'element2' }
          ]
        }
      };

      const namespaces: NamespaceContext = {
        prefixToUri: new Map([['xs', 'http://www.w3.org/2001/XMLSchema']]),
        uriToPrefix: new Map([['http://www.w3.org/2001/XMLSchema', 'xs']])
      };

      const processed = resolver.processNamespaces(data, namespaces);

      expect(Array.isArray(processed['{http://www.w3.org/2001/XMLSchema}schema']['{http://www.w3.org/2001/XMLSchema}element'])).toBe(true);
      expect(processed['{http://www.w3.org/2001/XMLSchema}schema']['{http://www.w3.org/2001/XMLSchema}element']).toHaveLength(2);
    });

    it('네임스페이스가 없는 요소는 그대로 유지해야 함', () => {
      const data = {
        'xs:schema': {
          'localElement': 'value',
          'xs:element': 'namespaced'
        }
      };

      const namespaces: NamespaceContext = {
        prefixToUri: new Map([['xs', 'http://www.w3.org/2001/XMLSchema']]),
        uriToPrefix: new Map([['http://www.w3.org/2001/XMLSchema', 'xs']])
      };

      const processed = resolver.processNamespaces(data, namespaces);

      expect(processed['{http://www.w3.org/2001/XMLSchema}schema']['localElement']).toBe('value');
      expect(processed['{http://www.w3.org/2001/XMLSchema}schema']['{http://www.w3.org/2001/XMLSchema}element']).toBe('namespaced');
    });
  });

  describe('네임스페이스 이름 해결', () => {
    it('접두사가 있는 이름을 해결해야 함', () => {
      const namespaces: NamespaceContext = {
        prefixToUri: new Map([['xs', 'http://www.w3.org/2001/XMLSchema']]),
        uriToPrefix: new Map([['http://www.w3.org/2001/XMLSchema', 'xs']])
      };

      const resolved = resolver.resolveNamespacedName('xs:element', namespaces);

      expect(resolved).toBe('{http://www.w3.org/2001/XMLSchema}element');
    });

    it('접두사가 없는 이름은 그대로 반환해야 함', () => {
      const namespaces: NamespaceContext = {
        prefixToUri: new Map(),
        uriToPrefix: new Map()
      };

      const resolved = resolver.resolveNamespacedName('element', namespaces);

      expect(resolved).toBe('element');
    });

    it('알 수 없는 접두사는 원본을 반환해야 함', () => {
      const namespaces: NamespaceContext = {
        prefixToUri: new Map([['xs', 'http://www.w3.org/2001/XMLSchema']]),
        uriToPrefix: new Map([['http://www.w3.org/2001/XMLSchema', 'xs']])
      };

      const resolved = resolver.resolveNamespacedName('unknown:element', namespaces);

      expect(resolved).toBe('unknown:element');
    });
  });

  describe('네임스페이스 검색', () => {
    let namespaces: NamespaceContext;

    beforeEach(() => {
      namespaces = {
        prefixToUri: new Map([
          ['xs', 'http://www.w3.org/2001/XMLSchema'],
          ['tns', 'http://example.com/test']
        ]),
        uriToPrefix: new Map([
          ['http://www.w3.org/2001/XMLSchema', 'xs'],
          ['http://example.com/test', 'tns']
        ])
      };
    });

    it('URI로 접두사를 찾을 수 있어야 함', () => {
      const prefix = resolver.findPrefixForUri('http://www.w3.org/2001/XMLSchema', namespaces);
      expect(prefix).toBe('xs');
    });

    it('접두사로 URI를 찾을 수 있어야 함', () => {
      const uri = resolver.findUriForPrefix('tns', namespaces);
      expect(uri).toBe('http://example.com/test');
    });

    it('존재하지 않는 URI/접두사에 대해 undefined를 반환해야 함', () => {
      const prefix = resolver.findPrefixForUri('http://nonexistent.com', namespaces);
      const uri = resolver.findUriForPrefix('nonexistent', namespaces);

      expect(prefix).toBeUndefined();
      expect(uri).toBeUndefined();
    });
  });

  describe('네임스페이스 컨텍스트 병합', () => {
    it('두 컨텍스트를 올바르게 병합해야 함', () => {
      const context1: NamespaceContext = {
        prefixToUri: new Map([['xs', 'http://www.w3.org/2001/XMLSchema']]),
        uriToPrefix: new Map([['http://www.w3.org/2001/XMLSchema', 'xs']]),
        defaultNamespace: 'http://example.com/default1'
      };

      const context2: NamespaceContext = {
        prefixToUri: new Map([['tns', 'http://example.com/test']]),
        uriToPrefix: new Map([['http://example.com/test', 'tns']]),
        defaultNamespace: 'http://example.com/default2',
        targetNamespace: 'http://example.com/target'
      };

      const merged = resolver.mergeNamespaceContexts(context1, context2);

      expect(merged.prefixToUri.get('xs')).toBe('http://www.w3.org/2001/XMLSchema');
      expect(merged.prefixToUri.get('tns')).toBe('http://example.com/test');
      expect(merged.defaultNamespace).toBe('http://example.com/default2'); // context2가 우선
      expect(merged.targetNamespace).toBe('http://example.com/target');
    });

    it('충돌하는 접두사는 두 번째 컨텍스트가 우선해야 함', () => {
      const context1: NamespaceContext = {
        prefixToUri: new Map([['ns', 'http://example.com/ns1']]),
        uriToPrefix: new Map([['http://example.com/ns1', 'ns']])
      };

      const context2: NamespaceContext = {
        prefixToUri: new Map([['ns', 'http://example.com/ns2']]),
        uriToPrefix: new Map([['http://example.com/ns2', 'ns']])
      };

      const merged = resolver.mergeNamespaceContexts(context1, context2);

      expect(merged.prefixToUri.get('ns')).toBe('http://example.com/ns2');
      expect(merged.uriToPrefix.get('http://example.com/ns2')).toBe('ns');
    });
  });

  describe('네임스페이스 충돌 검사', () => {
    it('충돌이 없는 경우 빈 배열을 반환해야 함', () => {
      const namespaces: NamespaceContext = {
        prefixToUri: new Map([
          ['xs', 'http://www.w3.org/2001/XMLSchema'],
          ['tns', 'http://example.com/test']
        ]),
        uriToPrefix: new Map([
          ['http://www.w3.org/2001/XMLSchema', 'xs'],
          ['http://example.com/test', 'tns']
        ])
      };

      const conflicts = resolver.checkNamespaceConflicts(namespaces);

      expect(conflicts).toHaveLength(0);
    });

    it('접두사 충돌을 감지해야 함', () => {
      const namespaces: NamespaceContext = {
        prefixToUri: new Map([
          ['ns', 'http://example.com/ns1'],
          ['ns', 'http://example.com/ns2'] // 이것은 실제로는 Map에서 덮어씌워짐
        ]),
        uriToPrefix: new Map()
      };

      // Map의 특성상 실제 충돌 시나리오를 만들기 위해 직접 설정
      namespaces.prefixToUri.set('ns', 'http://example.com/ns1');
      // 실제 충돌 검사 로직을 테스트하기 위해서는 다른 방법이 필요할 수 있음
    });
  });

  describe('표준 네임스페이스 검사', () => {
    it('표준 XML 스키마 네임스페이스를 인식해야 함', () => {
      expect(resolver.isStandardXMLSchemaNamespace('http://www.w3.org/2001/XMLSchema')).toBe(true);
      expect(resolver.isStandardXMLSchemaNamespace('http://www.w3.org/2001/XMLSchema-instance')).toBe(true);
      expect(resolver.isStandardXMLSchemaNamespace('http://www.w3.org/XML/1998/namespace')).toBe(true);
      expect(resolver.isStandardXMLSchemaNamespace('http://www.w3.org/2000/xmlns/')).toBe(true);
    });

    it('사용자 정의 네임스페이스는 표준이 아님을 인식해야 함', () => {
      expect(resolver.isStandardXMLSchemaNamespace('http://example.com/custom')).toBe(false);
      expect(resolver.isStandardXMLSchemaNamespace('http://mycompany.com/schema')).toBe(false);
    });
  });

  describe('문자열 변환', () => {
    it('네임스페이스 컨텍스트를 읽기 쉬운 문자열로 변환해야 함', () => {
      const namespaces: NamespaceContext = {
        prefixToUri: new Map([
          ['', 'http://example.com/default'],
          ['xs', 'http://www.w3.org/2001/XMLSchema'],
          ['tns', 'http://example.com/test']
        ]),
        uriToPrefix: new Map([
          ['http://example.com/default', ''],
          ['http://www.w3.org/2001/XMLSchema', 'xs'],
          ['http://example.com/test', 'tns']
        ]),
        defaultNamespace: 'http://example.com/default',
        targetNamespace: 'http://example.com/test'
      };

      const str = resolver.toString(namespaces);

      expect(str).toContain('네임스페이스 컨텍스트');
      expect(str).toContain('기본 네임스페이스: http://example.com/default');
      expect(str).toContain('타겟 네임스페이스: http://example.com/test');
      expect(str).toContain('xs -> http://www.w3.org/2001/XMLSchema');
      expect(str).toContain('(기본) -> http://example.com/default');
    });
  });
});