import { OpenAPIParser } from '../../parsers/openapi-parser';

describe('OpenAPIParser', () => {
  let parser: OpenAPIParser;

  beforeEach(() => {
    parser = new OpenAPIParser();
  });

  afterEach(() => {
    parser.clearCache();
  });

  describe('기본 파싱', () => {
    it('간단한 OpenAPI 3.0 스펙을 파싱해야 함', async () => {
      const spec = {
        openapi: '3.0.0',
        info: {
          title: 'Test API',
          version: '1.0.0'
        },
        paths: {
          '/users': {
            get: {
              responses: {
                '200': {
                  description: 'Success'
                }
              }
            }
          }
        }
      };

      const result = await parser.parse(spec);

      expect(result.validation.isValid).toBe(true);
      expect(result.schema.type).toBe('OPENAPI');
      expect(result.schema.name).toBe('Test API');
      expect(result.schema.version).toBe('1.0.0');
      expect(result.metadata.version).toBe('3.0.0');
      expect(result.metadata.pathCount).toBe(1);
      expect(result.metadata.operationCount).toBe(1);
    });

    it('OpenAPI 3.1 스펙을 파싱해야 함', async () => {
      const spec = {
        openapi: '3.1.0',
        info: {
          title: 'Test API v3.1',
          version: '2.0.0'
        },
        paths: {}
      };

      const result = await parser.parse(spec);

      expect(result.validation.isValid).toBe(true);
      expect(result.metadata.version).toBe('3.1.0');
    });

    it('JSON 문자열을 파싱해야 함', async () => {
      const specString = JSON.stringify({
        openapi: '3.0.0',
        info: {
          title: 'String API',
          version: '1.0.0'
        },
        paths: {}
      });

      const result = await parser.parse(specString);

      expect(result.validation.isValid).toBe(true);
      expect(result.schema.name).toBe('String API');
    });

    it('잘못된 JSON을 처리해야 함', async () => {
      const invalidJson = '{ invalid json }';

      const result = await parser.parse(invalidJson);

      expect(result.validation.isValid).toBe(false);
      expect(result.validation.errors.length).toBeGreaterThan(0);
    });
  });

  describe('YAML 파싱', () => {
    it('간단한 YAML을 파싱해야 함', async () => {
      const yamlContent = `
openapi: 3.0.0
info:
  title: YAML API
  version: 1.0.0
paths: {}
      `.trim();

      const result = await parser.parse(yamlContent);

      // 현재 구현에서는 제한적인 YAML 지원
      expect(result.validation.isValid).toBe(false);
      expect(result.validation.errors.length).toBeGreaterThan(0);
    });
  });

  describe('버전 검증', () => {
    it('OpenAPI 버전이 없으면 에러를 반환해야 함', async () => {
      const spec = {
        info: {
          title: 'No Version API',
          version: '1.0.0'
        },
        paths: {}
      };

      const result = await parser.parse(spec);

      expect(result.validation.isValid).toBe(false);
      expect(result.validation.errors.some(e => e.code === 'MISSING_OPENAPI_VERSION')).toBe(true);
    });

    it('지원되지 않는 버전에 대해 에러를 반환해야 함', async () => {
      const spec = {
        openapi: '2.0',
        info: {
          title: 'Old Version API',
          version: '1.0.0'
        },
        paths: {}
      };

      const result = await parser.parse(spec);

      expect(result.validation.isValid).toBe(false);
      expect(result.validation.errors.some(e => e.code === 'UNSUPPORTED_OPENAPI_VERSION')).toBe(true);
    });
  });

  describe('필수 필드 검증', () => {
    it('info 필드가 없으면 에러를 반환해야 함', async () => {
      const spec = {
        openapi: '3.0.0',
        paths: {}
      };

      const result = await parser.parse(spec);

      expect(result.validation.isValid).toBe(false);
      expect(result.validation.errors.some(e => e.code === 'MISSING_INFO')).toBe(true);
    });

    it('info.title이 없으면 에러를 반환해야 함', async () => {
      const spec = {
        openapi: '3.0.0',
        info: {
          version: '1.0.0'
        },
        paths: {}
      };

      const result = await parser.parse(spec);

      expect(result.validation.isValid).toBe(false);
      expect(result.validation.errors.some(e => e.code === 'MISSING_INFO_TITLE')).toBe(true);
    });

    it('info.version이 없으면 에러를 반환해야 함', async () => {
      const spec = {
        openapi: '3.0.0',
        info: {
          title: 'No Version Info API'
        },
        paths: {}
      };

      const result = await parser.parse(spec);

      expect(result.validation.isValid).toBe(false);
      expect(result.validation.errors.some(e => e.code === 'MISSING_INFO_VERSION')).toBe(true);
    });

    it('paths 필드가 없으면 에러를 반환해야 함', async () => {
      const spec = {
        openapi: '3.0.0',
        info: {
          title: 'No Paths API',
          version: '1.0.0'
        }
      };

      const result = await parser.parse(spec);

      expect(result.validation.isValid).toBe(false);
      expect(result.validation.errors.some(e => e.code === 'MISSING_PATHS')).toBe(true);
    });
  });

  describe('경로 매개변수 검증', () => {
    it('경로 매개변수가 오퍼레이션에 정의되지 않으면 에러를 반환해야 함', async () => {
      const spec = {
        openapi: '3.0.0',
        info: {
          title: 'Path Param API',
          version: '1.0.0'
        },
        paths: {
          '/users/{id}': {
            get: {
              responses: {
                '200': {
                  description: 'Success'
                }
              }
            }
          }
        }
      };

      const result = await parser.parse(spec);

      expect(result.validation.isValid).toBe(false);
      expect(result.validation.errors.some(e => e.code === 'MISSING_PATH_PARAMETERS')).toBe(true);
    });

    it('경로 매개변수가 올바르게 정의되면 통과해야 함', async () => {
      const spec = {
        openapi: '3.0.0',
        info: {
          title: 'Valid Path Param API',
          version: '1.0.0'
        },
        paths: {
          '/users/{id}': {
            get: {
              parameters: [
                {
                  name: 'id',
                  in: 'path',
                  required: true,
                  schema: {
                    type: 'string'
                  }
                }
              ],
              responses: {
                '200': {
                  description: 'Success'
                }
              }
            }
          }
        }
      };

      const result = await parser.parse(spec);

      expect(result.validation.isValid).toBe(true);
    });

    it('여러 경로 매개변수를 검증해야 함', async () => {
      const spec = {
        openapi: '3.0.0',
        info: {
          title: 'Multiple Path Params API',
          version: '1.0.0'
        },
        paths: {
          '/users/{userId}/posts/{postId}': {
            get: {
              parameters: [
                {
                  name: 'userId',
                  in: 'path',
                  required: true,
                  schema: { type: 'string' }
                }
                // postId 매개변수 누락
              ],
              responses: {
                '200': {
                  description: 'Success'
                }
              }
            }
          }
        }
      };

      const result = await parser.parse(spec);

      expect(result.validation.isValid).toBe(false);
      expect(result.validation.errors.some(e => 
        e.code === 'MISSING_PATH_PARAMETER' && e.message.includes('postId')
      )).toBe(true);
    });
  });

  describe('참조 해결', () => {
    it('로컬 컴포넌트 참조를 해결해야 함', async () => {
      const spec = {
        openapi: '3.0.0',
        info: {
          title: 'Reference API',
          version: '1.0.0'
        },
        paths: {
          '/users': {
            get: {
              responses: {
                '200': {
                  description: 'Success',
                  content: {
                    'application/json': {
                      schema: {
                        $ref: '#/components/schemas/User'
                      }
                    }
                  }
                }
              }
            }
          }
        },
        components: {
          schemas: {
            User: {
              type: 'object',
              properties: {
                id: { type: 'string' },
                name: { type: 'string' }
              }
            }
          }
        }
      };

      const result = await parser.parse(spec, { resolveReferences: true });

      expect(result.validation.isValid).toBe(true);
      expect(result.metadata.schemaCount).toBe(1);
      expect(result.metadata.componentCount).toBe(1);
    });

    it('순환 참조를 감지해야 함', async () => {
      const spec = {
        openapi: '3.0.0',
        info: {
          title: 'Circular Reference API',
          version: '1.0.0'
        },
        paths: {},
        components: {
          schemas: {
            Node: {
              type: 'object',
              properties: {
                value: { type: 'string' },
                child: { $ref: '#/components/schemas/Node' }
              }
            }
          }
        }
      };

      const result = await parser.parse(spec, { resolveReferences: true });

      expect(result.validation.isValid).toBe(true);
      // 순환 참조가 감지되어도 파싱은 성공해야 함
    });

    it('외부 참조를 식별해야 함', async () => {
      const spec = {
        openapi: '3.0.0',
        info: {
          title: 'External Reference API',
          version: '1.0.0'
        },
        paths: {
          '/users': {
            get: {
              responses: {
                '200': {
                  $ref: 'https://example.com/responses.yaml#/Success'
                }
              }
            }
          }
        }
      };

      const result = await parser.parse(spec, { resolveReferences: false });

      expect(result.validation.isValid).toBe(true);
      expect(result.metadata.externalReferences).toContain('https://example.com/responses.yaml#/Success');
    });
  });

  describe('컴포넌트 역참조', () => {
    it('컴포넌트를 인라인으로 확장해야 함', async () => {
      const spec = {
        openapi: '3.0.0',
        info: {
          title: 'Dereference API',
          version: '1.0.0'
        },
        paths: {
          '/users': {
            get: {
              responses: {
                '200': {
                  description: 'Success',
                  content: {
                    'application/json': {
                      schema: {
                        $ref: '#/components/schemas/User'
                      }
                    }
                  }
                }
              }
            }
          }
        },
        components: {
          schemas: {
            User: {
              type: 'object',
              properties: {
                id: { type: 'string' },
                name: { type: 'string' }
              }
            }
          }
        }
      };

      const result = await parser.parse(spec, { 
        resolveReferences: true,
        dereferenceComponents: true 
      });

      expect(result.validation.isValid).toBe(true);
      // 컴포넌트가 인라인으로 확장되었는지 확인
      const responseSchema = result.schema.content.paths['/users'].get.responses['200']
        .content['application/json'].schema;
      expect(responseSchema.type).toBe('object');
      expect(responseSchema.properties.id.type).toBe('string');
    });
  });

  describe('메타데이터 생성', () => {
    it('복잡한 API의 메타데이터를 생성해야 함', async () => {
      const spec = {
        openapi: '3.0.0',
        info: {
          title: 'Complex API',
          version: '1.0.0'
        },
        paths: {
          '/users': {
            get: {
              responses: { '200': { description: 'Success' } }
            },
            post: {
              responses: { '201': { description: 'Created' } }
            }
          },
          '/users/{id}': {
            get: {
              responses: { '200': { description: 'Success' } }
            },
            put: {
              responses: { '200': { description: 'Updated' } }
            },
            delete: {
              responses: { '204': { description: 'Deleted' } }
            }
          }
        },
        components: {
          schemas: {
            User: { type: 'object' },
            Error: { type: 'object' }
          },
          responses: {
            NotFound: { description: 'Not found' }
          },
          parameters: {
            UserId: { name: 'id', in: 'path' }
          }
        }
      };

      const result = await parser.parse(spec);

      expect(result.metadata.version).toBe('3.0.0');
      expect(result.metadata.pathCount).toBe(2);
      expect(result.metadata.operationCount).toBe(5);
      expect(result.metadata.schemaCount).toBe(2);
      expect(result.metadata.componentCount).toBe(4); // schemas(2) + responses(1) + parameters(1)
    });
  });

  describe('에러 처리', () => {
    it('빈 입력을 처리해야 함', async () => {
      const result = await parser.parse('');

      expect(result.validation.isValid).toBe(false);
      expect(result.validation.errors.length).toBeGreaterThan(0);
    });

    it('null 입력을 처리해야 함', async () => {
      const result = await parser.parse(null as any);

      expect(result.validation.isValid).toBe(false);
      expect(result.validation.errors.length).toBeGreaterThan(0);
    });

    it('최대 깊이 초과를 처리해야 함', async () => {
      const spec = {
        openapi: '3.0.0',
        info: {
          title: 'Deep API',
          version: '1.0.0'
        },
        paths: {},
        components: {
          schemas: {
            Deep: {
              type: 'object',
              properties: {
                nested: { $ref: '#/components/schemas/Deep' }
              }
            }
          }
        }
      };

      const result = await parser.parse(spec, { 
        resolveReferences: true,
        maxDepth: 5 
      });

      expect(result.validation.isValid).toBe(true);
    });
  });

  describe('파싱 옵션', () => {
    it('참조 해결을 비활성화할 수 있어야 함', async () => {
      const spec = {
        openapi: '3.0.0',
        info: {
          title: 'No Resolve API',
          version: '1.0.0'
        },
        paths: {
          '/users': {
            get: {
              responses: {
                '200': {
                  $ref: '#/components/responses/Success'
                }
              }
            }
          }
        },
        components: {
          responses: {
            Success: {
              description: 'Success response'
            }
          }
        }
      };

      const result = await parser.parse(spec, { resolveReferences: false });

      expect(result.validation.isValid).toBe(true);
      expect(result.schema.content.paths['/users'].get.responses['200'].$ref)
        .toBe('#/components/responses/Success');
    });

    it('스키마 검증을 비활성화할 수 있어야 함', async () => {
      const invalidSpec = {
        openapi: '3.0.0',
        info: {
          title: 'Invalid API',
          version: '1.0.0'
        },
        paths: {
          '/users/{id}': {
            get: {
              // 경로 매개변수가 정의되지 않음
              responses: {
                '200': { description: 'Success' }
              }
            }
          }
        }
      };

      const result = await parser.parse(invalidSpec, { validateSchema: false });

      expect(result.validation.isValid).toBe(true);
    });
  });

  describe('HTTP 메서드 처리', () => {
    it('모든 HTTP 메서드를 처리해야 함', async () => {
      const spec = {
        openapi: '3.0.0',
        info: {
          title: 'All Methods API',
          version: '1.0.0'
        },
        paths: {
          '/resource': {
            get: { responses: { '200': { description: 'GET' } } },
            post: { responses: { '201': { description: 'POST' } } },
            put: { responses: { '200': { description: 'PUT' } } },
            delete: { responses: { '204': { description: 'DELETE' } } },
            options: { responses: { '200': { description: 'OPTIONS' } } },
            head: { responses: { '200': { description: 'HEAD' } } },
            patch: { responses: { '200': { description: 'PATCH' } } },
            trace: { responses: { '200': { description: 'TRACE' } } }
          }
        }
      };

      const result = await parser.parse(spec);

      expect(result.validation.isValid).toBe(true);
      expect(result.metadata.operationCount).toBe(8);
    });
  });
});