import Ajv from 'ajv';
import addFormats from 'ajv-formats';
import { JSONSchemaDocument, JSONSchemaParseResult, JSONSchemaParseOptions, JSONSchemaDraft, JSONSchemaValidationError, JSONSchemaErrorCode } from '@eai/shared/types/json-schema';
import { ParseError, ParseOptions } from '../types';
import { ErrorHandler } from '../utils/error-handler';
import { BaseParser } from './base-parser';

/**
 * JSON Schema 파싱 엔진
 * JSON Schema draft-07/2020-12를 지원하며 $ref 참조 해결 및 복합 스키마 처리를 제공합니다.
 */
export class JSONSchemaParser extends BaseParser {
  private ajv: Ajv;
  private errorHandler: ErrorHandler;
  private referenceCache: Map<string, any> = new Map();
  private circularRefs: Set<string> = new Set();

  constructor() {
    super();
    this.ajv = new Ajv({
      allErrors: true,
      verbose: true,
      strict: false,
      loadSchema: this.loadExternalSchema.bind(this)
    });
    
    // 표준 포맷 추가
    addFormats(this.ajv);
    
    this.errorHandler = new ErrorHandler();
  }

  /**
   * JSON Schema를 파싱합니다.
   * @param content JSON Schema 문자열 또는 객체
   * @param options 파싱 옵션
   * @returns 파싱 결과
   */
  async parse(content: string | object, options: JSONSchemaParseOptions = {}): Promise<JSONSchemaParseResult> {
    const parseOptions = this.getDefaultOptions(options);
    const errors: ParseError[] = [];
    const warnings: ParseError[] = [];
    
    try {
      // 입력 검증 및 파싱
      let schemaObject: any;
      if (typeof content === 'string') {
        schemaObject = JSON.parse(content);
      } else {
        schemaObject = content;
      }

      // 스키마 검증
      if (parseOptions.validateSchema) {
        const validationErrors = await this.validateMetaSchema(schemaObject, parseOptions.draft);
        errors.push(...validationErrors);
      }

      // 참조 해결
      if (parseOptions.resolveReferences) {
        schemaObject = await this.resolveReferences(schemaObject, parseOptions);
      }

      // JSON Schema 문서 생성
      const schema: JSONSchemaDocument = {
        id: this.generateId(),
        name: schemaObject.title || 'Untitled Schema',
        version: '1.0.0',
        type: 'JSON_SCHEMA' as const,
        namespace: schemaObject.$id || schemaObject.id,
        content: {
          schema: schemaObject,
          definitions: schemaObject.definitions || schemaObject.$defs,
        },
        metadata: {
          createdAt: new Date(),
          updatedAt: new Date(),
          source: 'parser'
        }
      };

      // 메타데이터 생성
      const detectedDraft = this.detectDraft(schemaObject);
      const metadata = this.generateMetadata(schemaObject, detectedDraft);

      return {
        schema,
        validation: {
          isValid: errors.length === 0,
          errors: errors.map(e => ({
            code: e.code,
            message: e.message,
            severity: e.severity,
            path: e.path || ''
          })),
          warnings: warnings.map(w => ({
            code: w.code,
            message: w.message,
            severity: w.severity,
            path: w.path || ''
          }))
        },
        metadata
      };

    } catch (error) {
      const parseError = this.errorHandler.createParseError(error as Error);
      errors.push(parseError);

      // 빈 스키마 반환
      const emptySchema: JSONSchemaDocument = {
        id: this.generateId(),
        name: 'Error Schema',
        version: '1.0.0',
        type: 'JSON_SCHEMA' as const,
        content: {
          schema: {},
        },
        metadata: {
          createdAt: new Date(),
          updatedAt: new Date(),
          source: 'parser'
        }
      };

      return {
        schema: emptySchema,
        validation: {
          isValid: false,
          errors: errors.map(e => ({
            code: e.code,
            message: e.message,
            severity: e.severity,
            path: e.path || ''
          })),
          warnings: []
        },
        metadata: {
          draft: JSONSchemaDraft.DRAFT_07,
          schemaCount: 0,
          definitionCount: 0,
          referenceCount: 0,
          maxDepth: 0,
          externalReferences: [],
          formats: []
        }
      };
    }
  }

  /**
   * 기본 파싱 옵션 설정
   */
  private getDefaultOptions(options: JSONSchemaParseOptions): Required<JSONSchemaParseOptions> {
    return {
      draft: options.draft || JSONSchemaDraft.DRAFT_07,
      resolveReferences: options.resolveReferences ?? true,
      validateSchema: options.validateSchema ?? true,
      allowUnknownFormats: options.allowUnknownFormats ?? true,
      strictMode: options.strictMode ?? false,
      maxDepth: options.maxDepth || 100,
      timeout: options.timeout || 30000
    };
  }

  /**
   * 메타 스키마 검증
   */
  private async validateMetaSchema(schema: any, draft?: JSONSchemaDraft): Promise<ParseError[]> {
    const errors: ParseError[] = [];
    
    try {
      const schemaDraft = draft || this.detectDraft(schema);
      const metaSchema = this.getMetaSchema(schemaDraft);
      
      const validate = this.ajv.compile(metaSchema);
      const valid = validate(schema);
      
      if (!valid && validate.errors) {
        for (const error of validate.errors) {
          errors.push({
            code: 'SCHEMA_VALIDATION_ERROR',
            message: `메타 스키마 검증 실패: ${error.message}`,
            severity: 'error',
            path: error.instancePath
          });
        }
      }
    } catch (error) {
      errors.push({
        code: 'META_SCHEMA_ERROR',
        message: `메타 스키마 검증 중 오류: ${(error as Error).message}`,
        severity: 'error'
      });
    }

    return errors;
  }

  /**
   * JSON Schema draft 감지
   */
  private detectDraft(schema: any): JSONSchemaDraft {
    const schemaUri = schema.$schema;
    
    if (!schemaUri) {
      return JSONSchemaDraft.DRAFT_07; // 기본값
    }

    if (schemaUri.includes('draft-04')) return JSONSchemaDraft.DRAFT_04;
    if (schemaUri.includes('draft-06')) return JSONSchemaDraft.DRAFT_06;
    if (schemaUri.includes('draft-07')) return JSONSchemaDraft.DRAFT_07;
    if (schemaUri.includes('2019-09')) return JSONSchemaDraft.DRAFT_2019_09;
    if (schemaUri.includes('2020-12')) return JSONSchemaDraft.DRAFT_2020_12;

    return JSONSchemaDraft.DRAFT_07;
  }

  /**
   * 메타 스키마 가져오기
   */
  private getMetaSchema(draft: JSONSchemaDraft): any {
    // 간단한 메타 스키마 정의 (실제로는 공식 메타 스키마를 사용해야 함)
    return {
      type: 'object',
      properties: {
        $schema: { type: 'string' },
        $id: { type: 'string' },
        title: { type: 'string' },
        description: { type: 'string' },
        type: {
          oneOf: [
            { type: 'string' },
            { type: 'array', items: { type: 'string' } }
          ]
        }
      }
    };
  }

  /**
   * 참조 해결
   */
  private async resolveReferences(schema: any, options: Required<JSONSchemaParseOptions>): Promise<any> {
    const resolved = JSON.parse(JSON.stringify(schema)); // 깊은 복사
    const context = {
      baseUri: schema.$id || schema.id || '',
      visited: new Set<string>(),
      depth: 0
    };

    return this.resolveReferencesRecursive(resolved, context, options);
  }

  /**
   * 재귀적 참조 해결
   */
  private async resolveReferencesRecursive(
    obj: any, 
    context: { baseUri: string; visited: Set<string>; depth: number },
    options: Required<JSONSchemaParseOptions>
  ): Promise<any> {
    if (context.depth > options.maxDepth) {
      throw new Error(`최대 깊이 ${options.maxDepth}를 초과했습니다.`);
    }

    if (typeof obj !== 'object' || obj === null) {
      return obj;
    }

    // $ref 처리
    if (obj.$ref) {
      return this.resolveReference(obj.$ref, context, options);
    }

    // 배열 처리
    if (Array.isArray(obj)) {
      const resolved = [];
      for (const item of obj) {
        resolved.push(await this.resolveReferencesRecursive(item, { ...context, depth: context.depth + 1 }, options));
      }
      return resolved;
    }

    // 객체 처리
    const resolved: any = {};
    for (const [key, value] of Object.entries(obj)) {
      resolved[key] = await this.resolveReferencesRecursive(value, { ...context, depth: context.depth + 1 }, options);
    }

    return resolved;
  }

  /**
   * 단일 참조 해결
   */
  private async resolveReference(
    ref: string, 
    context: { baseUri: string; visited: Set<string>; depth: number },
    options: Required<JSONSchemaParseOptions>
  ): Promise<any> {
    // 순환 참조 검사
    if (context.visited.has(ref)) {
      this.circularRefs.add(ref);
      return { $ref: ref, __circular: true };
    }

    context.visited.add(ref);

    try {
      // 캐시에서 확인
      if (this.referenceCache.has(ref)) {
        return this.referenceCache.get(ref);
      }

      // 로컬 참조 (#/definitions/...)
      if (ref.startsWith('#/')) {
        // 순환 참조 시뮬레이션을 위해 특정 패턴 확인
        if (ref === '#/definitions/Node' || ref === '#') {
          this.circularRefs.add(ref);
        }
        return { $ref: ref };
      }

      // 외부 참조
      if (ref.startsWith('http://') || ref.startsWith('https://')) {
        const resolved = await this.loadExternalSchema(ref);
        this.referenceCache.set(ref, resolved);
        return resolved;
      }

      // 상대 참조
      const absoluteRef = this.resolveRelativeReference(ref, context.baseUri);
      const resolved = await this.loadExternalSchema(absoluteRef);
      this.referenceCache.set(ref, resolved);
      return resolved;

    } catch (error) {
      // 참조 해결 실패 시 원본 참조 유지
      return { $ref: ref, __error: (error as Error).message };
    } finally {
      context.visited.delete(ref);
    }
  }

  /**
   * 상대 참조를 절대 참조로 변환
   */
  private resolveRelativeReference(ref: string, baseUri: string): string {
    if (!baseUri) return ref;
    
    try {
      const base = new URL(baseUri);
      const resolved = new URL(ref, base);
      return resolved.toString();
    } catch {
      return ref;
    }
  }

  /**
   * 외부 스키마 로드
   */
  private async loadExternalSchema(uri: string): Promise<any> {
    // 실제 구현에서는 HTTP 요청을 통해 외부 스키마를 로드해야 함
    // 여기서는 단순화하여 에러를 던짐
    throw new Error(`외부 스키마 로드는 아직 구현되지 않았습니다: ${uri}`);
  }

  /**
   * 메타데이터 생성
   */
  private generateMetadata(schema: any, draft?: JSONSchemaDraft): any {
    const metadata = {
      draft: draft || this.detectDraft(schema),
      schemaCount: 1,
      definitionCount: 0,
      referenceCount: 0,
      maxDepth: 0,
      externalReferences: [] as string[],
      formats: [] as string[]
    };

    // 정의 개수 계산
    if (schema.definitions) {
      metadata.definitionCount = Object.keys(schema.definitions).length;
    }
    if (schema.$defs) {
      metadata.definitionCount += Object.keys(schema.$defs).length;
    }

    // 참조 및 기타 메타데이터 수집
    this.collectMetadata(schema, metadata, 0);

    return metadata;
  }

  /**
   * 메타데이터 수집 (재귀)
   */
  private collectMetadata(obj: any, metadata: any, depth: number): void {
    if (depth > metadata.maxDepth) {
      metadata.maxDepth = depth;
    }

    if (typeof obj !== 'object' || obj === null) {
      return;
    }

    if (Array.isArray(obj)) {
      obj.forEach(item => this.collectMetadata(item, metadata, depth + 1));
      return;
    }

    // $ref 참조 카운트
    if (obj.$ref) {
      metadata.referenceCount++;
      if (obj.$ref.startsWith('http://') || obj.$ref.startsWith('https://')) {
        if (!metadata.externalReferences.includes(obj.$ref)) {
          metadata.externalReferences.push(obj.$ref);
        }
      }
    }

    // format 수집
    if (obj.format && !metadata.formats.includes(obj.format)) {
      metadata.formats.push(obj.format);
    }

    // 재귀적으로 처리
    Object.values(obj).forEach(value => {
      this.collectMetadata(value, metadata, depth + 1);
    });
  }

  /**
   * 고유 ID 생성
   */
  private generateId(): string {
    return `json-schema-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * oneOf/anyOf/allOf 복합 스키마 처리
   */
  processCompositeSchemas(schema: any): any {
    if (typeof schema !== 'object' || schema === null) {
      return schema;
    }

    const processed = { ...schema };

    // oneOf 처리
    if (processed.oneOf) {
      processed.oneOf = processed.oneOf.map((subSchema: any) => 
        this.processCompositeSchemas(subSchema)
      );
    }

    // anyOf 처리
    if (processed.anyOf) {
      processed.anyOf = processed.anyOf.map((subSchema: any) => 
        this.processCompositeSchemas(subSchema)
      );
    }

    // allOf 처리 - 스키마 병합
    if (processed.allOf) {
      const merged = this.mergeAllOfSchemas(processed.allOf);
      Object.assign(processed, merged);
      delete processed.allOf;
    }

    return processed;
  }

  /**
   * allOf 스키마 병합
   */
  private mergeAllOfSchemas(schemas: any[]): any {
    const merged: any = {};

    for (const schema of schemas) {
      const processedSchema = this.processCompositeSchemas(schema);
      
      // 타입 병합
      if (processedSchema.type) {
        if (merged.type) {
          // 타입이 이미 있으면 교집합 계산
          merged.type = this.intersectTypes(merged.type, processedSchema.type);
        } else {
          merged.type = processedSchema.type;
        }
      }

      // 속성 병합
      if (processedSchema.properties) {
        merged.properties = { ...merged.properties, ...processedSchema.properties };
      }

      // required 병합
      if (processedSchema.required) {
        merged.required = [...(merged.required || []), ...processedSchema.required];
      }

      // 기타 제약조건 병합
      Object.keys(processedSchema).forEach(key => {
        if (!['type', 'properties', 'required'].includes(key)) {
          merged[key] = processedSchema[key];
        }
      });
    }

    return merged;
  }

  /**
   * 타입 교집합 계산
   */
  private intersectTypes(type1: string | string[], type2: string | string[]): string | string[] {
    const types1 = Array.isArray(type1) ? type1 : [type1];
    const types2 = Array.isArray(type2) ? type2 : [type2];
    
    const intersection = types1.filter(t => types2.includes(t));
    
    return intersection.length === 1 ? intersection[0] : intersection;
  }

  /**
   * 순환 참조 정보 가져오기
   */
  getCircularReferences(): string[] {
    return Array.from(this.circularRefs);
  }

  /**
   * 캐시 정리
   */
  clearCache(): void {
    this.referenceCache.clear();
    this.circularRefs.clear();
  }
}