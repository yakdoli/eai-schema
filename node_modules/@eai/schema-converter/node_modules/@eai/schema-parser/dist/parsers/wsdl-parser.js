import { XMLParser } from 'fast-xml-parser';
import { WSDLVersion, WSDLErrorCode, WSDLStyle, WSDLUse, WSDLAddressType, SchemaType, OperationType, BindingType, } from '@eai/shared';
import { BaseParser } from './base-parser';
import { ErrorHandler } from '../utils/error-handler';
import { NamespaceResolver } from '../utils/namespace-resolver';
/**
 * WSDL 파싱 엔진
 * WSDL 1.1 및 2.0 스펙을 지원하며, 서비스, 포트, 오퍼레이션, 바인딩, 메시지 정의를 파싱합니다.
 */
export class WSDLParser extends BaseParser {
    xmlParser;
    namespaceResolver;
    errorHandler;
    constructor() {
        super();
        this.xmlParser = new XMLParser({
            ignoreAttributes: false,
            attributeNamePrefix: '@_',
            textNodeName: '#text',
            parseAttributeValue: true,
            trimValues: true,
            alwaysCreateTextNode: false,
            isArray: (name, jpath, isLeafNode, isAttribute) => {
                // 배열로 처리해야 할 요소들 정의
                const arrayElements = [
                    'wsdl:service',
                    'wsdl:port',
                    'wsdl:binding',
                    'wsdl:portType',
                    'wsdl:operation',
                    'wsdl:message',
                    'wsdl:part',
                    'soap:header',
                    'soap:fault',
                    'xs:element',
                    'xs:complexType',
                    'xs:simpleType',
                ];
                return arrayElements.some(element => jpath.includes(element));
            },
        });
        this.namespaceResolver = new NamespaceResolver();
        this.errorHandler = new ErrorHandler();
    }
    /**
     * WSDL 문서를 파싱합니다
     */
    async parse(content, options = {}) {
        const parseOptions = {
            resolveExternalReferences: false,
            validateSchema: true,
            ignoreBaseNamespaces: false,
            maxDepth: 10,
            timeout: 30000,
            ...options,
        };
        try {
            // XML 파싱
            const parsedXml = this.xmlParser.parse(content);
            // WSDL 버전 감지
            const version = this.detectWSDLVersion(parsedXml);
            // 네임스페이스 해결
            const definitions = this.extractDefinitions(parsedXml);
            this.namespaceResolver.setNamespaces(definitions.xmlns);
            // WSDL 콘텐츠 파싱
            const wsdlContent = await this.parseWSDLContent(parsedXml, parseOptions);
            // 스키마 객체 생성
            const schema = {
                id: this.generateId(),
                name: definitions.name || 'Unnamed WSDL',
                version: '1.0',
                type: SchemaType.WSDL,
                originalFormat: 'WSDL',
                metadata: {
                    namespace: definitions.targetNamespace,
                    targetNamespace: definitions.targetNamespace,
                    imports: [],
                    annotations: [],
                    documentation: this.extractDocumentation(parsedXml),
                },
                content: wsdlContent,
                createdAt: new Date(),
                updatedAt: new Date(),
            };
            // 메타데이터 생성
            const metadata = this.generateMetadata(schema, version);
            // 검증 수행
            const validation = parseOptions.validateSchema
                ? await this.validateWSDL(schema, parseOptions)
                : { isValid: true, errors: [], warnings: [], infos: [] };
            return {
                schema,
                validation,
                metadata,
            };
        }
        catch (error) {
            throw this.errorHandler.handleParsingError(error, 'WSDL');
        }
    }
    /**
     * WSDL 버전을 감지합니다
     */
    detectWSDLVersion(parsedXml) {
        const definitions = parsedXml['wsdl:definitions'] || parsedXml.definitions;
        if (!definitions) {
            throw new Error('Invalid WSDL: definitions element not found');
        }
        // WSDL 2.0은 description 요소를 사용
        if (parsedXml['wsdl:description'] || parsedXml.description) {
            return WSDLVersion.WSDL_2_0;
        }
        // 네임스페이스로 버전 판단
        const xmlns = definitions['@_xmlns'] || {};
        if (xmlns['wsdl'] && xmlns['wsdl'].includes('2004') || xmlns['wsdl'].includes('2006')) {
            return WSDLVersion.WSDL_2_0;
        }
        return WSDLVersion.WSDL_1_1;
    }
    /**
     * WSDL definitions 요소를 추출합니다
     */
    extractDefinitions(parsedXml) {
        const definitions = parsedXml['wsdl:definitions'] || parsedXml.definitions;
        if (!definitions) {
            throw new Error('Invalid WSDL: definitions element not found');
        }
        const xmlns = {};
        // 네임스페이스 속성 추출
        Object.keys(definitions).forEach(key => {
            if (key.startsWith('@_xmlns')) {
                const nsPrefix = key.replace('@_xmlns:', '').replace('@_xmlns', '');
                xmlns[nsPrefix || 'default'] = definitions[key];
            }
        });
        return {
            name: definitions['@_name'] || 'Unnamed',
            targetNamespace: definitions['@_targetNamespace'] || '',
            xmlns,
            elementFormDefault: definitions['@_elementFormDefault'],
            attributeFormDefault: definitions['@_attributeFormDefault'],
        };
    }
    /**
     * WSDL 콘텐츠를 파싱합니다
     */
    async parseWSDLContent(parsedXml, options) {
        const definitions = parsedXml['wsdl:definitions'] || parsedXml.definitions;
        return {
            definitions: this.extractDefinitions(parsedXml),
            services: await this.parseServices(definitions),
            bindings: await this.parseBindings(definitions),
            portTypes: await this.parsePortTypes(definitions),
            messages: await this.parseMessages(definitions),
            types: await this.parseTypes(definitions),
        };
    }
    /**
     * WSDL 서비스를 파싱합니다
     */
    async parseServices(definitions) {
        const services = definitions['wsdl:service'] || definitions.service || [];
        const serviceArray = Array.isArray(services) ? services : [services];
        return serviceArray.map(service => ({
            name: service['@_name'] || 'Unnamed Service',
            documentation: this.extractDocumentation(service),
            ports: this.parsePorts(service),
        }));
    }
    /**
     * WSDL 포트를 파싱합니다
     */
    parsePorts(service) {
        const ports = service['wsdl:port'] || service.port || [];
        const portArray = Array.isArray(ports) ? ports : [ports];
        return portArray.map(port => ({
            name: port['@_name'] || 'Unnamed Port',
            binding: this.namespaceResolver.resolveQName(port['@_binding'] || ''),
            address: this.parseAddress(port),
        }));
    }
    /**
     * WSDL 주소를 파싱합니다
     */
    parseAddress(port) {
        // SOAP 주소
        const soapAddress = port['soap:address'] || port['soap12:address'];
        if (soapAddress) {
            return {
                location: soapAddress['@_location'] || '',
                type: WSDLAddressType.SOAP,
            };
        }
        // HTTP 주소
        const httpAddress = port['http:address'];
        if (httpAddress) {
            return {
                location: httpAddress['@_location'] || '',
                type: WSDLAddressType.HTTP,
            };
        }
        // 기본값
        return {
            location: '',
            type: WSDLAddressType.SOAP,
        };
    }
    /**
     * WSDL 바인딩을 파싱합니다
     */
    async parseBindings(definitions) {
        const bindings = definitions['wsdl:binding'] || definitions.binding || [];
        const bindingArray = Array.isArray(bindings) ? bindings : [bindings];
        return bindingArray.map(binding => {
            const soapBinding = binding['soap:binding'] || binding['soap12:binding'];
            return {
                name: binding['@_name'] || 'Unnamed Binding',
                type: BindingType.SOAP, // WSDL은 주로 SOAP 바인딩을 사용
                portType: this.namespaceResolver.resolveQName(binding['@_type'] || ''),
                style: soapBinding ? this.parseStyle(soapBinding['@_style']) : undefined,
                transport: soapBinding ? soapBinding['@_transport'] || '' : '',
                operations: this.parseBindingOperations(binding),
            };
        });
    }
    /**
     * WSDL 바인딩 오퍼레이션을 파싱합니다
     */
    parseBindingOperations(binding) {
        const operations = binding['wsdl:operation'] || binding.operation || [];
        const operationArray = Array.isArray(operations) ? operations : [operations];
        return operationArray.map(operation => {
            const soapOperation = operation['soap:operation'] || operation['soap12:operation'];
            return {
                name: operation['@_name'] || 'Unnamed Operation',
                soapAction: soapOperation ? soapOperation['@_soapAction'] : undefined,
                style: soapOperation ? this.parseStyle(soapOperation['@_style']) : undefined,
                input: this.parseBindingMessage(operation['wsdl:input'] || operation.input),
                output: this.parseBindingMessage(operation['wsdl:output'] || operation.output),
                faults: this.parseBindingFaults(operation),
            };
        });
    }
    /**
     * WSDL 바인딩 메시지를 파싱합니다
     */
    parseBindingMessage(message) {
        if (!message)
            return undefined;
        const soapBody = message['soap:body'] || message['soap12:body'];
        return {
            use: soapBody ? this.parseUse(soapBody['@_use']) : undefined,
            encodingStyle: soapBody ? soapBody['@_encodingStyle'] : undefined,
            namespace: soapBody ? soapBody['@_namespace'] : undefined,
            parts: this.parseBindingParts(soapBody),
        };
    }
    /**
     * WSDL 바인딩 파트를 파싱합니다
     */
    parseBindingParts(soapBody) {
        if (!soapBody || !soapBody['@_parts'])
            return [];
        const parts = soapBody['@_parts'].split(' ');
        return parts.map((part) => ({
            name: part,
            element: undefined,
            type: undefined,
        }));
    }
    /**
     * WSDL 바인딩 폴트를 파싱합니다
     */
    parseBindingFaults(operation) {
        const faults = operation['wsdl:fault'] || operation.fault || [];
        const faultArray = Array.isArray(faults) ? faults : [faults];
        return faultArray.map(fault => {
            const soapFault = fault['soap:fault'] || fault['soap12:fault'];
            return {
                name: fault['@_name'] || 'Unnamed Fault',
                use: soapFault ? this.parseUse(soapFault['@_use']) : undefined,
                encodingStyle: soapFault ? soapFault['@_encodingStyle'] : undefined,
                namespace: soapFault ? soapFault['@_namespace'] : undefined,
            };
        });
    }
    /**
     * WSDL 포트 타입을 파싱합니다
     */
    async parsePortTypes(definitions) {
        const portTypes = definitions['wsdl:portType'] || definitions.portType || [];
        const portTypeArray = Array.isArray(portTypes) ? portTypes : [portTypes];
        return portTypeArray.map(portType => ({
            name: portType['@_name'] || 'Unnamed PortType',
            documentation: this.extractDocumentation(portType),
            operations: this.parseOperations(portType),
        }));
    }
    /**
     * WSDL 오퍼레이션을 파싱합니다
     */
    parseOperations(portType) {
        const operations = portType['wsdl:operation'] || portType.operation || [];
        const operationArray = Array.isArray(operations) ? operations : [operations];
        return operationArray.map(operation => ({
            name: operation['@_name'] || 'Unnamed Operation',
            type: this.determineOperationType(operation),
            parameterOrder: operation['@_parameterOrder'],
            input: this.parseOperationMessage(operation['wsdl:input'] || operation.input),
            output: this.parseOperationMessage(operation['wsdl:output'] || operation.output),
            faults: this.parseOperationFaults(operation),
            documentation: this.extractDocumentation(operation),
        }));
    }
    /**
     * 오퍼레이션 타입을 결정합니다
     */
    determineOperationType(operation) {
        const hasInput = !!(operation['wsdl:input'] || operation.input);
        const hasOutput = !!(operation['wsdl:output'] || operation.output);
        if (hasInput && hasOutput) {
            return OperationType.REQUEST_RESPONSE;
        }
        else if (hasInput && !hasOutput) {
            return OperationType.ONE_WAY;
        }
        else if (!hasInput && hasOutput) {
            return OperationType.NOTIFICATION;
        }
        else {
            return OperationType.SOLICIT_RESPONSE;
        }
    }
    /**
     * WSDL 오퍼레이션 메시지를 파싱합니다
     */
    parseOperationMessage(message) {
        if (!message)
            return undefined;
        return {
            name: message['@_name'],
            message: this.namespaceResolver.resolveQName(message['@_message'] || ''),
            documentation: this.extractDocumentation(message),
        };
    }
    /**
     * WSDL 오퍼레이션 폴트를 파싱합니다
     */
    parseOperationFaults(operation) {
        const faults = operation['wsdl:fault'] || operation.fault || [];
        const faultArray = Array.isArray(faults) ? faults : [faults];
        return faultArray.map(fault => ({
            name: fault['@_name'] || 'Unnamed Fault',
            message: this.namespaceResolver.resolveQName(fault['@_message'] || ''),
            documentation: this.extractDocumentation(fault),
        }));
    }
    /**
     * WSDL 메시지를 파싱합니다
     */
    async parseMessages(definitions) {
        const messages = definitions['wsdl:message'] || definitions.message || [];
        const messageArray = Array.isArray(messages) ? messages : [messages];
        return messageArray.map(message => ({
            name: message['@_name'] || 'Unnamed Message',
            documentation: this.extractDocumentation(message),
            parts: this.parseMessageParts(message),
        }));
    }
    /**
     * WSDL 메시지 파트를 파싱합니다
     */
    parseMessageParts(message) {
        const parts = message['wsdl:part'] || message.part || [];
        const partArray = Array.isArray(parts) ? parts : [parts];
        return partArray.map(part => ({
            name: part['@_name'] || 'Unnamed Part',
            element: part['@_element'] ? this.namespaceResolver.resolveQName(part['@_element']) : undefined,
            type: part['@_type'] ? this.namespaceResolver.resolveQName(part['@_type']) : undefined,
            documentation: this.extractDocumentation(part),
        }));
    }
    /**
     * WSDL 타입을 파싱합니다
     */
    async parseTypes(definitions) {
        const types = definitions['wsdl:types'] || definitions.types;
        if (!types) {
            return {
                schemas: [],
                imports: [],
            };
        }
        return {
            schemas: await this.parseSchemas(types),
            imports: this.parseImports(types),
        };
    }
    /**
     * WSDL 스키마를 파싱합니다
     */
    async parseSchemas(types) {
        const schemas = types['xs:schema'] || types['xsd:schema'] || types.schema || [];
        const schemaArray = Array.isArray(schemas) ? schemas : [schemas];
        // 여기서는 기본적인 스키마 정보만 추출
        // 상세한 XSD 파싱은 XSDParser에서 처리
        return schemaArray.map(schema => ({
            targetNamespace: schema['@_targetNamespace'],
            elementFormDefault: schema['@_elementFormDefault'],
            attributeFormDefault: schema['@_attributeFormDefault'],
            elements: [], // XSDParser에서 처리
            types: [], // XSDParser에서 처리
        }));
    }
    /**
     * WSDL 임포트를 파싱합니다
     */
    parseImports(types) {
        const imports = types['wsdl:import'] || types.import || [];
        const importArray = Array.isArray(imports) ? imports : [imports];
        return importArray.map(imp => ({
            namespace: imp['@_namespace'] || '',
            location: imp['@_location'] || '',
        }));
    }
    /**
     * 스타일을 파싱합니다
     */
    parseStyle(style) {
        if (!style)
            return undefined;
        switch (style.toLowerCase()) {
            case 'document':
                return WSDLStyle.DOCUMENT;
            case 'rpc':
                return WSDLStyle.RPC;
            default:
                return undefined;
        }
    }
    /**
     * 사용법을 파싱합니다
     */
    parseUse(use) {
        if (!use)
            return undefined;
        switch (use.toLowerCase()) {
            case 'literal':
                return WSDLUse.LITERAL;
            case 'encoded':
                return WSDLUse.ENCODED;
            default:
                return undefined;
        }
    }
    /**
     * 문서화 정보를 추출합니다
     */
    extractDocumentation(element) {
        const doc = element['wsdl:documentation'] || element.documentation;
        if (!doc)
            return undefined;
        if (typeof doc === 'string') {
            return doc.trim();
        }
        if (doc['#text']) {
            return doc['#text'].trim();
        }
        return undefined;
    }
    /**
     * 메타데이터를 생성합니다
     */
    generateMetadata(schema, version) {
        const content = schema.content;
        return {
            version,
            serviceCount: content.services.length,
            operationCount: content.portTypes.reduce((count, pt) => count + pt.operations.length, 0),
            messageCount: content.messages.length,
            bindingCount: content.bindings.length,
            externalReferences: this.extractExternalReferences(content),
            namespaces: Object.keys(content.definitions.xmlns),
        };
    }
    /**
     * 외부 참조를 추출합니다
     */
    extractExternalReferences(content) {
        const references = [];
        // 임포트에서 외부 참조 추출
        content.types.imports.forEach(imp => {
            if (imp.location && !imp.location.startsWith('#')) {
                references.push(imp.location);
            }
        });
        return [...new Set(references)];
    }
    /**
     * WSDL을 검증합니다
     */
    async validateWSDL(schema, options) {
        const errors = [];
        const warnings = [];
        const infos = [];
        // 기본 구조 검증
        this.validateBasicStructure(schema, errors);
        // 참조 무결성 검증
        this.validateReferences(schema, errors, warnings);
        // 바인딩 검증
        this.validateBindings(schema, errors, warnings);
        // 네임스페이스 검증
        this.validateNamespaces(schema, warnings);
        return {
            isValid: errors.length === 0,
            errors,
            warnings,
            infos,
        };
    }
    /**
     * 기본 구조를 검증합니다
     */
    validateBasicStructure(schema, errors) {
        const content = schema.content;
        // 서비스가 있는지 확인
        if (content.services.length === 0) {
            errors.push({
                code: WSDLErrorCode.MISSING_REFERENCE,
                message: 'No services defined in WSDL',
                path: '/definitions',
                severity: 'error',
            });
        }
        // 포트 타입이 있는지 확인
        if (content.portTypes.length === 0) {
            errors.push({
                code: WSDLErrorCode.INVALID_PORT_TYPE,
                message: 'No port types defined in WSDL',
                path: '/definitions',
                severity: 'error',
            });
        }
    }
    /**
     * 참조 무결성을 검증합니다
     */
    validateReferences(schema, errors, warnings) {
        const content = schema.content;
        // 바인딩에서 포트 타입 참조 검증
        content.bindings.forEach(binding => {
            const portType = content.portTypes.find(pt => pt.name === binding.portType);
            if (!portType) {
                errors.push({
                    code: WSDLErrorCode.MISSING_REFERENCE,
                    message: `Port type '${binding.portType}' referenced by binding '${binding.name}' not found`,
                    path: `/definitions/binding[@name='${binding.name}']`,
                    severity: 'error',
                });
            }
        });
        // 오퍼레이션에서 메시지 참조 검증
        content.portTypes.forEach(portType => {
            portType.operations.forEach(operation => {
                if (operation.input) {
                    const message = content.messages.find(m => m.name === operation.input.message);
                    if (!message) {
                        errors.push({
                            code: WSDLErrorCode.MISSING_MESSAGE,
                            message: `Message '${operation.input.message}' referenced by operation '${operation.name}' not found`,
                            path: `/definitions/portType[@name='${portType.name}']/operation[@name='${operation.name}']`,
                            severity: 'error',
                        });
                    }
                }
                if (operation.output) {
                    const message = content.messages.find(m => m.name === operation.output.message);
                    if (!message) {
                        errors.push({
                            code: WSDLErrorCode.MISSING_MESSAGE,
                            message: `Message '${operation.output.message}' referenced by operation '${operation.name}' not found`,
                            path: `/definitions/portType[@name='${portType.name}']/operation[@name='${operation.name}']`,
                            severity: 'error',
                        });
                    }
                }
            });
        });
    }
    /**
     * 바인딩을 검증합니다
     */
    validateBindings(schema, errors, warnings) {
        const content = schema.content;
        content.bindings.forEach(binding => {
            // 바인딩에 오퍼레이션이 있는지 확인
            if (binding.operations.length === 0) {
                warnings.push({
                    code: WSDLErrorCode.INVALID_BINDING,
                    message: `Binding '${binding.name}' has no operations`,
                    path: `/definitions/binding[@name='${binding.name}']`,
                    severity: 'warning',
                });
            }
            // 포트 타입과 바인딩 오퍼레이션 일치 확인
            const portType = content.portTypes.find(pt => pt.name === binding.portType);
            if (portType) {
                binding.operations.forEach(bindingOp => {
                    const portTypeOp = portType.operations.find(op => op.name === bindingOp.name);
                    if (!portTypeOp) {
                        warnings.push({
                            code: WSDLErrorCode.INVALID_OPERATION,
                            message: `Operation '${bindingOp.name}' in binding '${binding.name}' not found in port type '${portType.name}'`,
                            path: `/definitions/binding[@name='${binding.name}']/operation[@name='${bindingOp.name}']`,
                            severity: 'warning',
                        });
                    }
                });
            }
        });
    }
    /**
     * 네임스페이스를 검증합니다
     */
    validateNamespaces(schema, warnings) {
        const xmlns = schema.content.definitions.xmlns;
        // 필수 네임스페이스 확인
        const requiredNamespaces = ['wsdl', 'soap'];
        requiredNamespaces.forEach(ns => {
            if (!xmlns[ns]) {
                warnings.push({
                    code: WSDLErrorCode.INVALID_NAMESPACE,
                    message: `Required namespace '${ns}' not declared`,
                    path: '/definitions',
                    severity: 'warning',
                });
            }
        });
        // 타겟 네임스페이스 확인
        if (!schema.content.definitions.targetNamespace) {
            warnings.push({
                code: WSDLErrorCode.INVALID_NAMESPACE,
                message: 'Target namespace not specified',
                path: '/definitions',
                severity: 'warning',
            });
        }
    }
    /**
     * 고유 ID를 생성합니다
     */
    generateId() {
        return `wsdl_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}
