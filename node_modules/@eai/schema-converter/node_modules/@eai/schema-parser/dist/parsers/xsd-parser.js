import { XMLParser } from './xml-parser';
import { NamespaceResolver } from '../utils/namespace-resolver';
import { ErrorHandler } from '../utils/error-handler';
/**
 * XSD 스키마 파싱 엔진
 * XML 파서를 기반으로 XSD 스키마를 파싱하고 타입 정의를 추출합니다.
 */
export class XSDParser {
    xmlParser;
    namespaceResolver;
    errorHandler;
    constructor() {
        this.xmlParser = new XMLParser();
        this.namespaceResolver = new NamespaceResolver();
        this.errorHandler = new ErrorHandler();
    }
    /**
     * XSD 스키마를 파싱합니다.
     * @param xsdContent XSD 스키마 문자열
     * @param options 파싱 옵션
     * @returns XSD 파싱 결과
     */
    async parse(xsdContent, options = {}) {
        const errors = [];
        const warnings = [];
        const complexTypes = [];
        const simpleTypes = [];
        try {
            // 먼저 XML로 파싱
            const xmlResult = await this.xmlParser.parse(xsdContent, {
                ...options,
                processNamespaces: true
            });
            errors.push(...xmlResult.errors);
            warnings.push(...xmlResult.warnings);
            if (!xmlResult.data) {
                throw new Error('XML 파싱 실패로 인해 XSD 파싱을 계속할 수 없습니다.');
            }
            // XSD 스키마 구조 검증
            const schemaRoot = this.findSchemaRoot(xmlResult.data);
            if (!schemaRoot) {
                throw new Error('유효한 XSD 스키마 루트 요소를 찾을 수 없습니다.');
            }
            // XSD 스키마 객체 생성
            const schema = this.createXSDSchema(schemaRoot, xmlResult.namespaces);
            // 복합 타입 파싱
            const complexTypeResults = this.parseComplexTypes(schemaRoot, xmlResult.namespaces);
            complexTypes.push(...complexTypeResults.types);
            errors.push(...complexTypeResults.errors);
            // 단순 타입 파싱
            const simpleTypeResults = this.parseSimpleTypes(schemaRoot, xmlResult.namespaces);
            simpleTypes.push(...simpleTypeResults.types);
            errors.push(...simpleTypeResults.errors);
            // 참조 해결
            if (options.resolveReferences !== false) {
                const referenceResults = await this.resolveReferences(schema, complexTypes, simpleTypes);
                errors.push(...referenceResults.errors);
                warnings.push(...referenceResults.warnings);
            }
            return {
                schema,
                errors,
                warnings,
                complexTypes,
                simpleTypes
            };
        }
        catch (error) {
            errors.push(this.errorHandler.createParseError(error));
            // 기본 스키마 반환 (부분 실패 허용 시)
            const emptySchema = {
                targetNamespace: '',
                elementFormDefault: 'unqualified',
                attributeFormDefault: 'unqualified',
                elements: [],
                complexTypes: [],
                simpleTypes: [],
                attributes: [],
                groups: [],
                attributeGroups: [],
                imports: [],
                includes: []
            };
            return {
                schema: emptySchema,
                errors,
                warnings,
                complexTypes,
                simpleTypes
            };
        }
    }
    /**
     * XSD 스키마 루트 요소 찾기
     */
    findSchemaRoot(data) {
        if (!data || typeof data !== 'object') {
            return null;
        }
        // 직접 schema 요소인 경우
        const schemaKeys = ['schema', 'xs:schema', 'xsd:schema'];
        for (const key of schemaKeys) {
            if (data[key]) {
                return data[key];
            }
        }
        // 네임스페이스가 해결된 형태로 찾기
        for (const key of Object.keys(data)) {
            if (key.includes('schema') && key.includes('}')) {
                return data[key];
            }
        }
        // 중첩된 구조에서 schema 찾기
        const findSchema = (obj) => {
            if (typeof obj !== 'object' || obj === null)
                return null;
            for (const key of Object.keys(obj)) {
                if (key === 'schema' || key.endsWith(':schema') || (key.includes('schema') && key.includes('}'))) {
                    return obj[key];
                }
                if (typeof obj[key] === 'object') {
                    const nested = findSchema(obj[key]);
                    if (nested)
                        return nested;
                }
            }
            return null;
        };
        return findSchema(data);
    }
    /**
     * XSD 스키마 객체 생성
     */
    createXSDSchema(schemaRoot, namespaces) {
        // 속성을 다양한 형태로 찾기
        let attributes = {};
        // @_ 형태의 속성
        if (schemaRoot['@_']) {
            attributes = { ...attributes, ...schemaRoot['@_'] };
        }
        // 직접 속성 형태 (fast-xml-parser에서 @_로 시작하는 키들)
        const attrKeys = Object.keys(schemaRoot).filter(key => key.startsWith('@_'));
        for (const key of attrKeys) {
            const attrName = key.substring(2); // @_ 제거
            attributes[attrName] = schemaRoot[key];
        }
        // 네임스페이스에서 targetNamespace 가져오기
        const targetNamespace = attributes.targetNamespace ||
            namespaces.targetNamespace ||
            '';
        return {
            targetNamespace,
            elementFormDefault: attributes.elementFormDefault || 'unqualified',
            attributeFormDefault: attributes.attributeFormDefault || 'unqualified',
            elements: [],
            complexTypes: [],
            simpleTypes: [],
            attributes: [],
            groups: [],
            attributeGroups: [],
            imports: this.parseImports(schemaRoot),
            includes: this.parseIncludes(schemaRoot)
        };
    }
    /**
     * 복합 타입 파싱
     */
    parseComplexTypes(schemaRoot, namespaces) {
        const types = [];
        const errors = [];
        try {
            const complexTypeElements = this.extractElements(schemaRoot, 'complexType');
            for (const element of complexTypeElements) {
                try {
                    const complexType = this.parseComplexType(element, namespaces);
                    types.push(complexType);
                }
                catch (error) {
                    errors.push({
                        code: 'COMPLEX_TYPE_PARSE_ERROR',
                        message: `복합 타입 파싱 실패: ${error.message}`,
                        severity: 'error'
                    });
                }
            }
        }
        catch (error) {
            errors.push({
                code: 'COMPLEX_TYPES_EXTRACTION_ERROR',
                message: `복합 타입 추출 실패: ${error.message}`,
                severity: 'error'
            });
        }
        return { types, errors };
    }
    /**
     * 단일 복합 타입 파싱
     */
    parseComplexType(element, namespaces) {
        // 속성을 다양한 형태로 찾기
        let attributes = {};
        if (element['@_']) {
            attributes = { ...attributes, ...element['@_'] };
        }
        // @_로 시작하는 직접 속성들
        const attrKeys = Object.keys(element).filter(key => key.startsWith('@_'));
        for (const key of attrKeys) {
            const attrName = key.substring(2); // @_ 제거
            attributes[attrName] = element[key];
        }
        const name = attributes.name || '';
        const complexType = {
            name,
            namespace: namespaces.targetNamespace,
            baseType: this.extractBaseType(element),
            elements: this.parseElements(element),
            attributes: this.parseAttributes(element),
            mixed: attributes.mixed === 'true',
            abstract: attributes.abstract === 'true'
        };
        return complexType;
    }
    /**
     * 단순 타입 파싱
     */
    parseSimpleTypes(schemaRoot, namespaces) {
        const types = [];
        const errors = [];
        try {
            const simpleTypeElements = this.extractElements(schemaRoot, 'simpleType');
            for (const element of simpleTypeElements) {
                try {
                    const simpleType = this.parseSimpleType(element, namespaces);
                    types.push(simpleType);
                }
                catch (error) {
                    errors.push({
                        code: 'SIMPLE_TYPE_PARSE_ERROR',
                        message: `단순 타입 파싱 실패: ${error.message}`,
                        severity: 'error'
                    });
                }
            }
        }
        catch (error) {
            errors.push({
                code: 'SIMPLE_TYPES_EXTRACTION_ERROR',
                message: `단순 타입 추출 실패: ${error.message}`,
                severity: 'error'
            });
        }
        return { types, errors };
    }
    /**
     * 단일 단순 타입 파싱
     */
    parseSimpleType(element, namespaces) {
        const attributes = element['@_'] || {};
        const name = attributes.name || '';
        const simpleType = {
            name,
            namespace: namespaces.targetNamespace,
            baseType: this.extractBaseType(element),
            restrictions: this.parseRestrictions(element),
            enumeration: this.parseEnumeration(element)
        };
        return simpleType;
    }
    /**
     * 요소 추출 (complexType, simpleType 등)
     */
    extractElements(parent, elementType) {
        const elements = [];
        if (!parent || typeof parent !== 'object') {
            return elements;
        }
        // 직접 키 매칭
        const directKey = `{http://www.w3.org/2001/XMLSchema}${elementType}`;
        if (parent[directKey]) {
            if (Array.isArray(parent[directKey])) {
                elements.push(...parent[directKey]);
            }
            else {
                elements.push(parent[directKey]);
            }
        }
        // 다른 형태의 키들도 검색
        const searchKeys = [
            elementType,
            `xs:${elementType}`,
            `xsd:${elementType}`
        ];
        for (const key of searchKeys) {
            if (parent[key]) {
                if (Array.isArray(parent[key])) {
                    elements.push(...parent[key]);
                }
                else {
                    elements.push(parent[key]);
                }
            }
        }
        return elements;
    }
    /**
     * 기본 타입 추출
     */
    extractBaseType(element) {
        // restriction 또는 extension에서 base 속성 찾기
        const restriction = element.restriction || element['xs:restriction'] || element['xsd:restriction'];
        const extension = element.extension || element['xs:extension'] || element['xsd:extension'];
        if (restriction && restriction['@_'] && restriction['@_'].base) {
            return restriction['@_'].base;
        }
        if (extension && extension['@_'] && extension['@_'].base) {
            return extension['@_'].base;
        }
        return undefined;
    }
    /**
     * 요소 파싱
     */
    parseElements(complexTypeElement) {
        // 구현 예정 - 복잡한 로직이므로 기본 구조만 제공
        return [];
    }
    /**
     * 속성 파싱
     */
    parseAttributes(element) {
        // 구현 예정 - 복잡한 로직이므로 기본 구조만 제공
        return [];
    }
    /**
     * 제약 조건 파싱
     */
    parseRestrictions(element) {
        const restrictions = [];
        const restriction = element.restriction || element['xs:restriction'] || element['xsd:restriction'];
        if (restriction) {
            // minLength, maxLength, pattern 등의 제약 조건 파싱
            const facets = ['minLength', 'maxLength', 'pattern', 'minInclusive', 'maxInclusive', 'totalDigits', 'fractionDigits'];
            for (const facet of facets) {
                const facetElement = restriction[facet] || restriction[`xs:${facet}`] || restriction[`xsd:${facet}`];
                if (facetElement) {
                    restrictions.push({
                        type: facet,
                        value: facetElement['@_']?.value || facetElement
                    });
                }
            }
        }
        return restrictions;
    }
    /**
     * 열거형 파싱
     */
    parseEnumeration(element) {
        const enumValues = [];
        const restriction = element.restriction || element['xs:restriction'] || element['xsd:restriction'];
        if (restriction) {
            const enumerations = restriction.enumeration || restriction['xs:enumeration'] || restriction['xsd:enumeration'];
            if (Array.isArray(enumerations)) {
                for (const enumElement of enumerations) {
                    const value = enumElement['@_']?.value;
                    if (value)
                        enumValues.push(value);
                }
            }
            else if (enumerations) {
                const value = enumerations['@_']?.value;
                if (value)
                    enumValues.push(value);
            }
        }
        return enumValues;
    }
    /**
     * import 파싱
     */
    parseImports(schemaRoot) {
        // 구현 예정
        return [];
    }
    /**
     * include 파싱
     */
    parseIncludes(schemaRoot) {
        // 구현 예정
        return [];
    }
    /**
     * 참조 해결
     */
    async resolveReferences(schema, complexTypes, simpleTypes) {
        const errors = [];
        const warnings = [];
        // 참조 해결 로직 구현 예정
        // 현재는 기본 구조만 제공
        return { errors, warnings };
    }
}
