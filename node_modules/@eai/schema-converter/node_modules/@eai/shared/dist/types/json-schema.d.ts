import { BaseSchema, SchemaType, ValidationResult } from './index';
export interface JSONSchemaDocument extends BaseSchema {
    type: SchemaType.JSON_SCHEMA;
    content: JSONSchemaContent;
}
export interface JSONSchemaContent {
    schema: JSONSchema;
    definitions?: Record<string, JSONSchema>;
    $defs?: Record<string, JSONSchema>;
}
export interface JSONSchema {
    $schema?: string;
    $id?: string;
    id?: string;
    $ref?: string;
    $comment?: string;
    title?: string;
    description?: string;
    default?: any;
    examples?: any[];
    readOnly?: boolean;
    writeOnly?: boolean;
    deprecated?: boolean;
    type?: JSONSchemaType | JSONSchemaType[];
    enum?: any[];
    const?: any;
    multipleOf?: number;
    maximum?: number;
    exclusiveMaximum?: number | boolean;
    minimum?: number;
    exclusiveMinimum?: number | boolean;
    maxLength?: number;
    minLength?: number;
    pattern?: string;
    format?: string;
    items?: JSONSchema | JSONSchema[];
    additionalItems?: JSONSchema | boolean;
    maxItems?: number;
    minItems?: number;
    uniqueItems?: boolean;
    contains?: JSONSchema;
    maxProperties?: number;
    minProperties?: number;
    required?: string[];
    properties?: Record<string, JSONSchema>;
    patternProperties?: Record<string, JSONSchema>;
    additionalProperties?: JSONSchema | boolean;
    dependencies?: Record<string, JSONSchema | string[]>;
    propertyNames?: JSONSchema;
    if?: JSONSchema;
    then?: JSONSchema;
    else?: JSONSchema;
    allOf?: JSONSchema[];
    anyOf?: JSONSchema[];
    oneOf?: JSONSchema[];
    not?: JSONSchema;
    $recursiveRef?: string;
    $anchor?: string;
    $recursiveAnchor?: boolean;
    unevaluatedItems?: JSONSchema | boolean;
    unevaluatedProperties?: JSONSchema | boolean;
    [key: string]: any;
}
export declare enum JSONSchemaType {
    NULL = "null",
    BOOLEAN = "boolean",
    OBJECT = "object",
    ARRAY = "array",
    NUMBER = "number",
    STRING = "string",
    INTEGER = "integer"
}
export declare enum JSONSchemaFormat {
    DATE_TIME = "date-time",
    DATE = "date",
    TIME = "time",
    DURATION = "duration",
    EMAIL = "email",
    IDN_EMAIL = "idn-email",
    HOSTNAME = "hostname",
    IDN_HOSTNAME = "idn-hostname",
    IPV4 = "ipv4",
    IPV6 = "ipv6",
    URI = "uri",
    URI_REFERENCE = "uri-reference",
    IRI = "iri",
    IRI_REFERENCE = "iri-reference",
    UUID = "uuid",
    URI_TEMPLATE = "uri-template",
    JSON_POINTER = "json-pointer",
    RELATIVE_JSON_POINTER = "relative-json-pointer",
    REGEX = "regex",
    INT32 = "int32",
    INT64 = "int64",
    FLOAT = "float",
    DOUBLE = "double",
    BYTE = "byte",
    BINARY = "binary",
    BASE64 = "base64",
    BASE64URL = "base64url",
    PASSWORD = "password"
}
export declare enum JSONSchemaDraft {
    DRAFT_04 = "http://json-schema.org/draft-04/schema#",
    DRAFT_06 = "http://json-schema.org/draft-06/schema#",
    DRAFT_07 = "http://json-schema.org/draft-07/schema#",
    DRAFT_2019_09 = "https://json-schema.org/draft/2019-09/schema",
    DRAFT_2020_12 = "https://json-schema.org/draft/2020-12/schema"
}
export interface JSONSchemaParseOptions {
    draft?: JSONSchemaDraft;
    resolveReferences: boolean;
    validateSchema: boolean;
    allowUnknownFormats: boolean;
    strictMode: boolean;
    maxDepth: number;
    timeout: number;
}
export interface JSONSchemaParseResult {
    schema: JSONSchemaDocument;
    validation: ValidationResult;
    metadata: JSONSchemaParseMetadata;
}
export interface JSONSchemaParseMetadata {
    draft: JSONSchemaDraft;
    schemaCount: number;
    definitionCount: number;
    referenceCount: number;
    maxDepth: number;
    externalReferences: string[];
    formats: string[];
}
export interface JSONSchemaValidationOptions {
    draft?: JSONSchemaDraft;
    checkReferences: boolean;
    validateFormats: boolean;
    allowUnknownKeywords: boolean;
    strictMode: boolean;
}
export interface JSONSchemaValidationError {
    code: JSONSchemaErrorCode;
    message: string;
    instancePath: string;
    schemaPath: string;
    keyword: string;
    params?: Record<string, any>;
    data?: any;
    schema?: any;
    parentSchema?: any;
}
export declare enum JSONSchemaErrorCode {
    INVALID_REFERENCE = "INVALID_REFERENCE",
    CIRCULAR_REFERENCE = "CIRCULAR_REFERENCE",
    INVALID_TYPE = "INVALID_TYPE",
    INVALID_FORMAT = "INVALID_FORMAT",
    CONSTRAINT_VIOLATION = "CONSTRAINT_VIOLATION",
    MISSING_REQUIRED_PROPERTY = "MISSING_REQUIRED_PROPERTY",
    ADDITIONAL_PROPERTIES_NOT_ALLOWED = "ADDITIONAL_PROPERTIES_NOT_ALLOWED",
    ENUM_MISMATCH = "ENUM_MISMATCH",
    CONST_MISMATCH = "CONST_MISMATCH",
    PATTERN_MISMATCH = "PATTERN_MISMATCH",
    MULTIPLE_OF_VIOLATION = "MULTIPLE_OF_VIOLATION",
    MINIMUM_VIOLATION = "MINIMUM_VIOLATION",
    MAXIMUM_VIOLATION = "MAXIMUM_VIOLATION",
    MIN_LENGTH_VIOLATION = "MIN_LENGTH_VIOLATION",
    MAX_LENGTH_VIOLATION = "MAX_LENGTH_VIOLATION",
    MIN_ITEMS_VIOLATION = "MIN_ITEMS_VIOLATION",
    MAX_ITEMS_VIOLATION = "MAX_ITEMS_VIOLATION",
    UNIQUE_ITEMS_VIOLATION = "UNIQUE_ITEMS_VIOLATION",
    MIN_PROPERTIES_VIOLATION = "MIN_PROPERTIES_VIOLATION",
    MAX_PROPERTIES_VIOLATION = "MAX_PROPERTIES_VIOLATION",
    DEPENDENCY_VIOLATION = "DEPENDENCY_VIOLATION",
    CONDITIONAL_SCHEMA_VIOLATION = "CONDITIONAL_SCHEMA_VIOLATION",
    COMPOSITION_VIOLATION = "COMPOSITION_VIOLATION"
}
export interface JSONSchemaConversionOptions {
    targetDraft?: JSONSchemaDraft;
    preserveExamples: boolean;
    preserveDescriptions: boolean;
    generateTitles: boolean;
    flattenDefinitions: boolean;
}
export interface JSONSchemaToEAIMapping {
    schemas: JSONSchemaMapping[];
    definitions: JSONSchemaDefinitionMapping[];
    properties: JSONSchemaPropertyMapping[];
}
export interface JSONSchemaMapping {
    jsonSchema: string;
    eaiEntity: string;
    propertyMappings: JSONSchemaPropertyMapping[];
    constraints: JSONSchemaConstraintMapping[];
}
export interface JSONSchemaDefinitionMapping {
    jsonDefinition: string;
    eaiType: string;
    properties: JSONSchemaPropertyMapping[];
}
export interface JSONSchemaPropertyMapping {
    jsonProperty: string;
    eaiProperty: string;
    typeMapping: JSONSchemaTypeMapping;
    constraints: JSONSchemaConstraintMapping[];
}
export interface JSONSchemaTypeMapping {
    jsonType: JSONSchemaType;
    eaiType: string;
    format?: string;
    conversionRule?: string;
}
export interface JSONSchemaConstraintMapping {
    jsonConstraint: string;
    eaiConstraint: string;
    value: any;
    transformation?: string;
}
export interface JSONSchemaReference {
    $ref: string;
    resolved?: JSONSchema;
    circular?: boolean;
}
export interface JSONSchemaContext {
    baseUri: string;
    currentPath: string[];
    definitions: Record<string, JSONSchema>;
    references: JSONSchemaReference[];
    draft: JSONSchemaDraft;
}
export interface JSONSchemaTraversalOptions {
    includeParentSchema: boolean;
    includeSchemaPath: boolean;
    followReferences: boolean;
    maxDepth: number;
}
export interface JSONSchemaNode {
    schema: JSONSchema;
    path: string[];
    parent?: JSONSchemaNode;
    key?: string;
    index?: number;
    isReference: boolean;
    depth: number;
}
export interface JSONSchemaMetaValidation {
    isValid: boolean;
    draft: JSONSchemaDraft;
    errors: JSONSchemaValidationError[];
    warnings: JSONSchemaValidationError[];
}
export interface JSONSchemaDocumentationOptions {
    includeExamples: boolean;
    includeDescriptions: boolean;
    includeConstraints: boolean;
    format: DocumentationFormat;
}
export declare enum DocumentationFormat {
    HTML = "html",
    MARKDOWN = "markdown",
    JSON = "json",
    YAML = "yaml"
}
export interface JSONSchemaDocumentation {
    title: string;
    description?: string;
    version?: string;
    schemas: SchemaDocumentation[];
    definitions: DefinitionDocumentation[];
}
export interface SchemaDocumentation {
    name: string;
    title?: string;
    description?: string;
    type: string;
    properties: PropertyDocumentation[];
    examples?: any[];
    constraints: ConstraintDocumentation[];
}
export interface PropertyDocumentation {
    name: string;
    type: string;
    description?: string;
    required: boolean;
    constraints: ConstraintDocumentation[];
    examples?: any[];
}
export interface DefinitionDocumentation {
    name: string;
    title?: string;
    description?: string;
    type: string;
    properties: PropertyDocumentation[];
    usedBy: string[];
}
export interface ConstraintDocumentation {
    type: string;
    value: any;
    description: string;
}
//# sourceMappingURL=json-schema.d.ts.map