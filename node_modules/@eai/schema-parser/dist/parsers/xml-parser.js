import { XMLParser as FastXMLParser, XMLBuilder, XMLValidator } from 'fast-xml-parser';
import { DOMParser } from 'xmldom';
import { NamespaceResolver } from '../utils/namespace-resolver';
import { ErrorHandler } from '../utils/error-handler';
/**
 * XML 파싱 엔진
 * fast-xml-parser를 사용하여 XML 문서를 파싱하고 네임스페이스를 처리합니다.
 */
export class XMLParser {
    fastParser;
    namespaceResolver;
    errorHandler;
    constructor() {
        // fast-xml-parser 설정
        this.fastParser = new FastXMLParser({
            ignoreAttributes: false,
            attributeNamePrefix: '@_',
            textNodeName: '#text',
            allowBooleanAttributes: true,
            parseAttributeValue: false, // 속성 값을 문자열로 유지
            trimValues: true,
            processEntities: false, // XXE 공격 방지
            ignoreDeclaration: false,
            ignorePiTags: false
        });
        this.namespaceResolver = new NamespaceResolver();
        this.errorHandler = new ErrorHandler();
    }
    /**
     * XML 문자열을 파싱합니다.
     * @param xmlContent XML 문자열
     * @param options 파싱 옵션
     * @returns 파싱 결과
     */
    async parse(xmlContent, options = {}) {
        const errors = [];
        const warnings = [];
        let data = null;
        let namespaces = {
            prefixToUri: new Map(),
            uriToPrefix: new Map()
        };
        try {
            // 입력 검증
            this.validateInput(xmlContent);
            // XML 구문 검증 (xmldom 사용)
            const syntaxErrors = this.validateSyntax(xmlContent);
            errors.push(...syntaxErrors);
            // 부분 실패 허용이 false이고 구문 에러가 있으면 중단
            if (!options.allowPartialFailure && syntaxErrors.length > 0) {
                throw new Error('XML 구문 에러로 인해 파싱을 중단합니다.');
            }
            // fast-xml-parser로 파싱
            const validationResult = XMLValidator.validate(xmlContent);
            if (validationResult === true) {
                data = this.fastParser.parse(xmlContent);
                // 네임스페이스 처리
                if (options.processNamespaces !== false) {
                    namespaces = this.namespaceResolver.extractNamespaces(xmlContent);
                    data = this.namespaceResolver.processNamespaces(data, namespaces);
                }
            }
            else {
                errors.push({
                    code: 'XML_PARSE_ERROR',
                    message: `XML 파싱 실패: ${validationResult.err?.msg || 'Unknown error'}`,
                    severity: 'error'
                });
            }
        }
        catch (error) {
            errors.push(this.errorHandler.createParseError(error));
        }
        return {
            data,
            errors,
            warnings,
            namespaces
        };
    }
    /**
     * 입력 검증
     */
    validateInput(xmlContent) {
        if (typeof xmlContent !== 'string') {
            throw new Error('유효하지 않은 XML 입력입니다.');
        }
        if (xmlContent.trim().length === 0) {
            throw new Error('빈 XML 문서입니다.');
        }
        // XXE 공격 패턴 검사
        if (this.containsXXEPatterns(xmlContent)) {
            throw new Error('보안상 위험한 XML 패턴이 감지되었습니다.');
        }
    }
    /**
     * XXE 공격 패턴 검사
     */
    containsXXEPatterns(xmlContent) {
        const xxePatterns = [
            /<!ENTITY\s+\w+\s+SYSTEM/i,
            /<!ENTITY\s+\w+\s+PUBLIC/i,
            /<!DOCTYPE[^>]*\[/i
        ];
        return xxePatterns.some(pattern => pattern.test(xmlContent));
    }
    /**
     * XML 구문 검증 (xmldom 사용)
     */
    validateSyntax(xmlContent) {
        const errors = [];
        try {
            const parser = new DOMParser({
                errorHandler: {
                    warning: (msg) => {
                        errors.push({
                            code: 'XML_WARNING',
                            message: msg,
                            severity: 'warning'
                        });
                    },
                    error: (msg) => {
                        errors.push({
                            code: 'XML_ERROR',
                            message: msg,
                            severity: 'error'
                        });
                    },
                    fatalError: (msg) => {
                        errors.push({
                            code: 'XML_FATAL_ERROR',
                            message: msg,
                            severity: 'error'
                        });
                    }
                }
            });
            const doc = parser.parseFromString(xmlContent, 'text/xml');
            // 파싱 에러가 있는지 확인 (parsererror 요소가 있으면 에러)
            const parserError = doc.getElementsByTagName('parsererror');
            if (parserError.length > 0) {
                errors.push({
                    code: 'XML_PARSE_ERROR',
                    message: parserError[0].textContent || 'XML 파싱 에러',
                    severity: 'error'
                });
            }
        }
        catch (error) {
            errors.push({
                code: 'XML_SYNTAX_ERROR',
                message: `XML 구문 에러: ${error.message}`,
                severity: 'error'
            });
        }
        return errors;
    }
    /**
     * 파싱된 객체를 XML 문자열로 변환
     */
    toXML(data, options = {}) {
        const builder = new XMLBuilder({
            ignoreAttributes: false,
            attributeNamePrefix: '@_',
            textNodeName: '#text',
            format: options.format || false,
            indentBy: '  ',
            suppressEmptyNode: false
        });
        return builder.build(data);
    }
}
