/**
 * 네임스페이스 해결기
 * XML/XSD 문서의 네임스페이스를 처리하고 참조를 해결합니다.
 */
export class NamespaceResolver {
    /**
     * XML 문서에서 네임스페이스 정보를 추출합니다.
     * @param xmlContent XML 문자열
     * @returns 네임스페이스 컨텍스트
     */
    extractNamespaces(xmlContent) {
        const prefixToUri = new Map();
        const uriToPrefix = new Map();
        let defaultNamespace;
        let targetNamespace;
        try {
            // xmlns 선언 패턴 매칭
            const namespacePattern = /xmlns(?::([^=\s]+))?\s*=\s*["']([^"']+)["']/g;
            let match;
            while ((match = namespacePattern.exec(xmlContent)) !== null) {
                const prefix = match[1] || ''; // 기본 네임스페이스인 경우 빈 문자열
                const uri = match[2];
                if (prefix === '') {
                    defaultNamespace = uri;
                    prefixToUri.set('', uri);
                }
                else {
                    prefixToUri.set(prefix, uri);
                }
                uriToPrefix.set(uri, prefix);
            }
            // targetNamespace 추출
            const targetNsPattern = /targetNamespace\s*=\s*["']([^"']+)["']/;
            const targetNsMatch = targetNsPattern.exec(xmlContent);
            if (targetNsMatch) {
                targetNamespace = targetNsMatch[1];
            }
        }
        catch (error) {
            console.warn('네임스페이스 추출 중 오류 발생:', error);
        }
        return {
            prefixToUri,
            uriToPrefix,
            defaultNamespace,
            targetNamespace
        };
    }
    /**
     * 파싱된 객체에 네임스페이스 정보를 적용합니다.
     * @param data 파싱된 XML 객체
     * @param namespaces 네임스페이스 컨텍스트
     * @returns 네임스페이스가 처리된 객체
     */
    processNamespaces(data, namespaces) {
        if (!data || typeof data !== 'object') {
            return data;
        }
        const processedData = {};
        for (const [key, value] of Object.entries(data)) {
            const processedKey = this.resolveNamespacedName(key, namespaces);
            if (typeof value === 'object' && value !== null) {
                if (Array.isArray(value)) {
                    processedData[processedKey] = value.map(item => this.processNamespaces(item, namespaces));
                }
                else {
                    processedData[processedKey] = this.processNamespaces(value, namespaces);
                }
            }
            else {
                processedData[processedKey] = value;
            }
        }
        return processedData;
    }
    /**
     * 네임스페이스가 포함된 이름을 해결합니다.
     * @param name 네임스페이스가 포함된 이름 (예: "xs:element")
     * @param namespaces 네임스페이스 컨텍스트
     * @returns 해결된 이름 정보
     */
    resolveNamespacedName(name, namespaces) {
        if (!name.includes(':')) {
            // 네임스페이스 접두사가 없는 경우
            return name;
        }
        const [prefix, localName] = name.split(':', 2);
        const uri = namespaces.prefixToUri.get(prefix);
        if (uri) {
            // 네임스페이스 URI가 있는 경우, 표준화된 형태로 반환
            return `{${uri}}${localName}`;
        }
        // 네임스페이스를 찾을 수 없는 경우 원본 반환
        return name;
    }
    /**
     * 네임스페이스 URI에서 접두사를 찾습니다.
     * @param uri 네임스페이스 URI
     * @param namespaces 네임스페이스 컨텍스트
     * @returns 접두사 (없으면 undefined)
     */
    findPrefixForUri(uri, namespaces) {
        return namespaces.uriToPrefix.get(uri);
    }
    /**
     * 접두사에서 네임스페이스 URI를 찾습니다.
     * @param prefix 접두사
     * @param namespaces 네임스페이스 컨텍스트
     * @returns 네임스페이스 URI (없으면 undefined)
     */
    findUriForPrefix(prefix, namespaces) {
        return namespaces.prefixToUri.get(prefix);
    }
    /**
     * 두 네임스페이스 컨텍스트를 병합합니다.
     * @param context1 첫 번째 컨텍스트
     * @param context2 두 번째 컨텍스트
     * @returns 병합된 컨텍스트
     */
    mergeNamespaceContexts(context1, context2) {
        const mergedPrefixToUri = new Map([...context1.prefixToUri, ...context2.prefixToUri]);
        const mergedUriToPrefix = new Map([...context1.uriToPrefix, ...context2.uriToPrefix]);
        return {
            prefixToUri: mergedPrefixToUri,
            uriToPrefix: mergedUriToPrefix,
            defaultNamespace: context2.defaultNamespace || context1.defaultNamespace,
            targetNamespace: context2.targetNamespace || context1.targetNamespace
        };
    }
    /**
     * 네임스페이스 충돌을 검사합니다.
     * @param namespaces 네임스페이스 컨텍스트
     * @returns 충돌 정보 배열
     */
    checkNamespaceConflicts(namespaces) {
        const conflicts = [];
        const prefixUsage = new Map();
        // 접두사별 URI 사용 현황 수집
        for (const [prefix, uri] of namespaces.prefixToUri) {
            if (!prefixUsage.has(prefix)) {
                prefixUsage.set(prefix, []);
            }
            prefixUsage.get(prefix).push(uri);
        }
        // 충돌 검사
        for (const [prefix, uris] of prefixUsage) {
            if (uris.length > 1) {
                conflicts.push({
                    prefix,
                    conflictingUris: [...new Set(uris)] // 중복 제거
                });
            }
        }
        return conflicts;
    }
    /**
     * 표준 XML 스키마 네임스페이스인지 확인합니다.
     * @param uri 네임스페이스 URI
     * @returns 표준 네임스페이스 여부
     */
    isStandardXMLSchemaNamespace(uri) {
        const standardNamespaces = [
            'http://www.w3.org/2001/XMLSchema',
            'http://www.w3.org/2001/XMLSchema-instance',
            'http://www.w3.org/XML/1998/namespace',
            'http://www.w3.org/2000/xmlns/'
        ];
        return standardNamespaces.includes(uri);
    }
    /**
     * 네임스페이스 매핑을 설정합니다.
     * @param namespaces 네임스페이스 매핑 객체
     */
    setNamespaces(namespaces) {
        this.currentContext = {
            prefixToUri: new Map(Object.entries(namespaces)),
            uriToPrefix: new Map(Object.entries(namespaces).map(([k, v]) => [v, k])),
            defaultNamespace: namespaces[''] || namespaces['default'],
            targetNamespace: undefined
        };
    }
    /**
     * QName을 해결합니다.
     * @param qname QName 문자열 (예: "tns:ElementName")
     * @returns 해결된 이름
     */
    resolveQName(qname) {
        if (!qname || !qname.includes(':')) {
            return qname;
        }
        const [prefix, localName] = qname.split(':', 2);
        const uri = this.currentContext?.prefixToUri.get(prefix);
        if (uri) {
            return `{${uri}}${localName}`;
        }
        return qname;
    }
    /**
     * 네임스페이스 컨텍스트를 문자열로 변환합니다 (디버깅용).
     * @param namespaces 네임스페이스 컨텍스트
     * @returns 문자열 표현
     */
    toString(namespaces) {
        const lines = [];
        lines.push('=== 네임스페이스 컨텍스트 ===');
        if (namespaces.defaultNamespace) {
            lines.push(`기본 네임스페이스: ${namespaces.defaultNamespace}`);
        }
        if (namespaces.targetNamespace) {
            lines.push(`타겟 네임스페이스: ${namespaces.targetNamespace}`);
        }
        lines.push('접두사 매핑:');
        for (const [prefix, uri] of namespaces.prefixToUri) {
            const displayPrefix = prefix === '' ? '(기본)' : prefix;
            lines.push(`  ${displayPrefix} -> ${uri}`);
        }
        return lines.join('\n');
    }
    currentContext;
}
