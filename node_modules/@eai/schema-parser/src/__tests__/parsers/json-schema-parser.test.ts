import { JSONSchemaParser } from '../../parsers/json-schema-parser';
import { JSONSchemaDraft } from '@eai/shared/types/json-schema';

describe('JSONSchemaParser', () => {
  let parser: JSONSchemaParser;

  beforeEach(() => {
    parser = new JSONSchemaParser();
  });

  afterEach(() => {
    parser.clearCache();
  });

  describe('기본 파싱', () => {
    it('간단한 JSON Schema를 파싱해야 함', async () => {
      const schema = {
        $schema: 'http://json-schema.org/draft-07/schema#',
        type: 'object',
        properties: {
          name: { type: 'string' },
          age: { type: 'number' }
        },
        required: ['name']
      };

      const result = await parser.parse(schema);

      expect(result.validation.isValid).toBe(true);
      expect(result.schema.type).toBe('JSON_SCHEMA');
      expect(result.schema.content.schema.type).toBe('object');
      expect(result.metadata.draft).toBe(JSONSchemaDraft.DRAFT_07);
    });

    it('JSON 문자열을 파싱해야 함', async () => {
      const schemaString = JSON.stringify({
        type: 'string',
        minLength: 1,
        maxLength: 100
      });

      const result = await parser.parse(schemaString);

      expect(result.validation.isValid).toBe(true);
      expect(result.schema.content.schema.type).toBe('string');
      expect(result.schema.content.schema.minLength).toBe(1);
      expect(result.schema.content.schema.maxLength).toBe(100);
    });

    it('잘못된 JSON을 처리해야 함', async () => {
      const invalidJson = '{ invalid json }';

      const result = await parser.parse(invalidJson);

      expect(result.validation.isValid).toBe(false);
      expect(result.validation.errors.length).toBeGreaterThan(0);
    });
  });

  describe('Draft 감지', () => {
    it('Draft 04를 감지해야 함', async () => {
      const schema = {
        $schema: 'http://json-schema.org/draft-04/schema#',
        type: 'object'
      };

      const result = await parser.parse(schema);

      expect(result.metadata.draft).toBe(JSONSchemaDraft.DRAFT_04);
    });

    it('Draft 2020-12를 감지해야 함', async () => {
      const schema = {
        $schema: 'https://json-schema.org/draft/2020-12/schema',
        type: 'object'
      };

      const result = await parser.parse(schema);

      expect(result.metadata.draft).toBe(JSONSchemaDraft.DRAFT_2020_12);
    });

    it('기본 Draft를 사용해야 함', async () => {
      const schema = {
        type: 'object'
      };

      const result = await parser.parse(schema);

      expect(result.metadata.draft).toBe(JSONSchemaDraft.DRAFT_07);
    });
  });

  describe('참조 해결', () => {
    it('로컬 참조를 처리해야 함', async () => {
      const schema = {
        definitions: {
          Person: {
            type: 'object',
            properties: {
              name: { type: 'string' }
            }
          }
        },
        type: 'object',
        properties: {
          person: { $ref: '#/definitions/Person' }
        }
      };

      const result = await parser.parse(schema, { resolveReferences: true });

      expect(result.validation.isValid).toBe(true);
      expect(result.metadata.referenceCount).toBe(1);
      expect(result.metadata.definitionCount).toBe(1);
    });

    it('순환 참조를 감지해야 함', async () => {
      const schema = {
        definitions: {
          Node: {
            type: 'object',
            properties: {
              value: { type: 'string' },
              child: { $ref: '#/definitions/Node' }
            }
          }
        },
        $ref: '#/definitions/Node'
      };

      const result = await parser.parse(schema, { resolveReferences: true });

      expect(result.validation.isValid).toBe(true);
      const circularRefs = parser.getCircularReferences();
      expect(circularRefs.length).toBeGreaterThan(0);
    });

    it('외부 참조를 식별해야 함', async () => {
      const schema = {
        type: 'object',
        properties: {
          external: { $ref: 'https://example.com/schema.json' }
        }
      };

      const result = await parser.parse(schema, { resolveReferences: false });

      expect(result.validation.isValid).toBe(true);
      expect(result.metadata.externalReferences).toContain('https://example.com/schema.json');
    });
  });

  describe('복합 스키마 처리', () => {
    it('oneOf 스키마를 처리해야 함', async () => {
      const schema = {
        oneOf: [
          { type: 'string' },
          { type: 'number' }
        ]
      };

      const result = await parser.parse(schema);
      const processed = parser.processCompositeSchemas(result.schema.content.schema);

      expect(processed.oneOf).toHaveLength(2);
      expect(processed.oneOf[0].type).toBe('string');
      expect(processed.oneOf[1].type).toBe('number');
    });

    it('anyOf 스키마를 처리해야 함', async () => {
      const schema = {
        anyOf: [
          { type: 'string', minLength: 5 },
          { type: 'string', pattern: '^[A-Z]' }
        ]
      };

      const result = await parser.parse(schema);
      const processed = parser.processCompositeSchemas(result.schema.content.schema);

      expect(processed.anyOf).toHaveLength(2);
      expect(processed.anyOf[0].minLength).toBe(5);
      expect(processed.anyOf[1].pattern).toBe('^[A-Z]');
    });

    it('allOf 스키마를 병합해야 함', async () => {
      const schema = {
        allOf: [
          {
            type: 'object',
            properties: {
              name: { type: 'string' }
            },
            required: ['name']
          },
          {
            type: 'object',
            properties: {
              age: { type: 'number' }
            },
            required: ['age']
          }
        ]
      };

      const result = await parser.parse(schema);
      const processed = parser.processCompositeSchemas(result.schema.content.schema);

      expect(processed.type).toBe('object');
      expect(processed.properties.name).toEqual({ type: 'string' });
      expect(processed.properties.age).toEqual({ type: 'number' });
      expect(processed.required).toEqual(['name', 'age']);
      expect(processed.allOf).toBeUndefined();
    });

    it('중첩된 복합 스키마를 처리해야 함', async () => {
      const schema = {
        oneOf: [
          {
            allOf: [
              { type: 'object' },
              { properties: { name: { type: 'string' } } }
            ]
          },
          { type: 'string' }
        ]
      };

      const result = await parser.parse(schema);
      const processed = parser.processCompositeSchemas(result.schema.content.schema);

      expect(processed.oneOf).toHaveLength(2);
      expect(processed.oneOf[0].type).toBe('object');
      expect(processed.oneOf[0].properties.name.type).toBe('string');
      expect(processed.oneOf[1].type).toBe('string');
    });
  });

  describe('메타데이터 생성', () => {
    it('스키마 메타데이터를 생성해야 함', async () => {
      const schema = {
        $schema: 'http://json-schema.org/draft-07/schema#',
        definitions: {
          Person: { type: 'object' },
          Address: { type: 'object' }
        },
        type: 'object',
        properties: {
          person: { $ref: '#/definitions/Person' },
          address: { $ref: '#/definitions/Address' },
          email: { type: 'string', format: 'email' },
          phone: { type: 'string', format: 'phone' }
        }
      };

      const result = await parser.parse(schema);

      expect(result.metadata.draft).toBe(JSONSchemaDraft.DRAFT_07);
      expect(result.metadata.schemaCount).toBe(1);
      expect(result.metadata.definitionCount).toBe(2);
      expect(result.metadata.referenceCount).toBe(2);
      expect(result.metadata.formats).toContain('email');
      expect(result.metadata.formats).toContain('phone');
    });

    it('최대 깊이를 계산해야 함', async () => {
      const schema = {
        type: 'object',
        properties: {
          level1: {
            type: 'object',
            properties: {
              level2: {
                type: 'object',
                properties: {
                  level3: { type: 'string' }
                }
              }
            }
          }
        }
      };

      const result = await parser.parse(schema);

      expect(result.metadata.maxDepth).toBeGreaterThan(0);
    });
  });

  describe('에러 처리', () => {
    it('빈 입력을 처리해야 함', async () => {
      const result = await parser.parse('');

      expect(result.validation.isValid).toBe(false);
      expect(result.validation.errors.length).toBeGreaterThan(0);
    });

    it('null 입력을 처리해야 함', async () => {
      const result = await parser.parse(null as any);

      expect(result.validation.isValid).toBe(false);
      expect(result.validation.errors.length).toBeGreaterThan(0);
    });

    it('최대 깊이 초과를 처리해야 함', async () => {
      const deepSchema = {
        type: 'object',
        properties: {
          deep: { $ref: '#' }
        }
      };

      const result = await parser.parse(deepSchema, { 
        resolveReferences: true, 
        maxDepth: 5 
      });

      // 깊이 제한으로 인한 처리 확인
      expect(result.validation.isValid).toBe(true); // 에러가 아닌 제한된 처리
    });
  });

  describe('파싱 옵션', () => {
    it('참조 해결을 비활성화할 수 있어야 함', async () => {
      const schema = {
        definitions: {
          Person: { type: 'object' }
        },
        $ref: '#/definitions/Person'
      };

      const result = await parser.parse(schema, { resolveReferences: false });

      expect(result.validation.isValid).toBe(true);
      expect(result.schema.content.schema.$ref).toBe('#/definitions/Person');
    });

    it('스키마 검증을 비활성화할 수 있어야 함', async () => {
      const invalidSchema = {
        type: 'invalid-type'
      };

      const result = await parser.parse(invalidSchema, { validateSchema: false });

      expect(result.validation.isValid).toBe(true);
    });

    it('엄격 모드를 활성화할 수 있어야 함', async () => {
      const schema = {
        type: 'object',
        unknownKeyword: 'value'
      };

      const result = await parser.parse(schema, { strictMode: true });

      // 엄격 모드에서는 알 수 없는 키워드에 대해 더 엄격하게 처리
      expect(result.validation.isValid).toBe(true); // 현재 구현에서는 허용
    });
  });

  describe('타입 교집합', () => {
    it('문자열 타입 교집합을 계산해야 함', async () => {
      const schema = {
        allOf: [
          { type: 'string' },
          { type: 'string' }
        ]
      };

      const result = await parser.parse(schema);
      const processed = parser.processCompositeSchemas(result.schema.content.schema);

      expect(processed.type).toBe('string');
    });

    it('배열 타입 교집합을 계산해야 함', async () => {
      const schema = {
        allOf: [
          { type: ['string', 'number'] },
          { type: ['string', 'boolean'] }
        ]
      };

      const result = await parser.parse(schema);
      const processed = parser.processCompositeSchemas(result.schema.content.schema);

      expect(processed.type).toBe('string');
    });

    it('빈 교집합을 처리해야 함', async () => {
      const schema = {
        allOf: [
          { type: 'string' },
          { type: 'number' }
        ]
      };

      const result = await parser.parse(schema);
      const processed = parser.processCompositeSchemas(result.schema.content.schema);

      expect(processed.type).toEqual([]);
    });
  });
});