import { WSDLParser } from '../../parsers/wsdl-parser';
import { WSDLVersion, WSDLStyle, WSDLUse, WSDLAddressType, SchemaType, OperationType } from '@eai/shared/types';

describe('WSDLParser', () => {
  let parser: WSDLParser;

  beforeEach(() => {
    parser = new WSDLParser();
  });

  describe('기본 WSDL 파싱', () => {
    const simpleWSDL = `<?xml version="1.0" encoding="UTF-8"?>
<wsdl:definitions 
  xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
  xmlns:tns="http://example.com/calculator"
  targetNamespace="http://example.com/calculator"
  name="CalculatorService">
  
  <wsdl:types>
    <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" 
               targetNamespace="http://example.com/calculator">
      <xs:element name="AddRequest">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="a" type="xs:int"/>
            <xs:element name="b" type="xs:int"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="AddResponse">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="result" type="xs:int"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:schema>
  </wsdl:types>

  <wsdl:message name="AddRequestMessage">
    <wsdl:part name="parameters" element="tns:AddRequest"/>
  </wsdl:message>
  
  <wsdl:message name="AddResponseMessage">
    <wsdl:part name="parameters" element="tns:AddResponse"/>
  </wsdl:message>

  <wsdl:portType name="CalculatorPortType">
    <wsdl:operation name="Add">
      <wsdl:input message="tns:AddRequestMessage"/>
      <wsdl:output message="tns:AddResponseMessage"/>
    </wsdl:operation>
  </wsdl:portType>

  <wsdl:binding name="CalculatorBinding" type="tns:CalculatorPortType">
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
    <wsdl:operation name="Add">
      <soap:operation soapAction="http://example.com/calculator/Add"/>
      <wsdl:input>
        <soap:body use="literal"/>
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal"/>
      </wsdl:output>
    </wsdl:operation>
  </wsdl:binding>

  <wsdl:service name="CalculatorService">
    <wsdl:port name="CalculatorPort" binding="tns:CalculatorBinding">
      <soap:address location="http://example.com/calculator"/>
    </wsdl:port>
  </wsdl:service>
</wsdl:definitions>`;

    it('유효한 WSDL을 성공적으로 파싱해야 합니다', async () => {
      const result = await parser.parse(simpleWSDL);

      expect(result).toBeDefined();
      expect(result.schema).toBeDefined();
      expect(result.schema.type).toBe(SchemaType.WSDL);
      expect(result.schema.name).toBe('CalculatorService');
      

      
      expect(result.validation.isValid).toBe(true);
    });

    it('WSDL 정의를 올바르게 파싱해야 합니다', async () => {
      const result = await parser.parse(simpleWSDL);
      const definitions = result.schema.content.definitions;

      expect(definitions.name).toBe('CalculatorService');
      expect(definitions.targetNamespace).toBe('http://example.com/calculator');
      expect(definitions.xmlns).toHaveProperty('wsdl');
      expect(definitions.xmlns).toHaveProperty('soap');
      expect(definitions.xmlns).toHaveProperty('tns');
    });

    it('서비스를 올바르게 파싱해야 합니다', async () => {
      const result = await parser.parse(simpleWSDL);
      const services = result.schema.content.services;

      expect(services).toHaveLength(1);
      expect(services[0].name).toBe('CalculatorService');
      expect(services[0].ports).toHaveLength(1);
      expect(services[0].ports[0].name).toBe('CalculatorPort');
      expect(services[0].ports[0].address.location).toBe('http://example.com/calculator');
      expect(services[0].ports[0].address.type).toBe(WSDLAddressType.SOAP);
    });

    it('바인딩을 올바르게 파싱해야 합니다', async () => {
      const result = await parser.parse(simpleWSDL);
      const bindings = result.schema.content.bindings;

      expect(bindings).toHaveLength(1);
      expect(bindings[0].name).toBe('CalculatorBinding');
      expect(bindings[0].style).toBe(WSDLStyle.DOCUMENT);
      expect(bindings[0].transport).toBe('http://schemas.xmlsoap.org/soap/http');
      expect(bindings[0].operations).toHaveLength(1);
      expect(bindings[0].operations[0].name).toBe('Add');
      expect(bindings[0].operations[0].soapAction).toBe('http://example.com/calculator/Add');
    });

    it('포트 타입을 올바르게 파싱해야 합니다', async () => {
      const result = await parser.parse(simpleWSDL);
      const portTypes = result.schema.content.portTypes;

      expect(portTypes).toHaveLength(1);
      expect(portTypes[0].name).toBe('CalculatorPortType');
      expect(portTypes[0].operations).toHaveLength(1);
      expect(portTypes[0].operations[0].name).toBe('Add');
      expect(portTypes[0].operations[0].type).toBe(OperationType.REQUEST_RESPONSE);
    });

    it('메시지를 올바르게 파싱해야 합니다', async () => {
      const result = await parser.parse(simpleWSDL);
      const messages = result.schema.content.messages;

      expect(messages).toHaveLength(2);
      
      const requestMessage = messages.find(m => m.name === 'AddRequestMessage');
      expect(requestMessage).toBeDefined();
      expect(requestMessage!.parts).toHaveLength(1);
      expect(requestMessage!.parts[0].name).toBe('parameters');
      expect(requestMessage!.parts[0].element).toContain('AddRequest');

      const responseMessage = messages.find(m => m.name === 'AddResponseMessage');
      expect(responseMessage).toBeDefined();
      expect(responseMessage!.parts).toHaveLength(1);
      expect(responseMessage!.parts[0].name).toBe('parameters');
      expect(responseMessage!.parts[0].element).toContain('AddResponse');
    });

    it('메타데이터를 올바르게 생성해야 합니다', async () => {
      const result = await parser.parse(simpleWSDL);
      const metadata = result.metadata;

      expect(metadata.version).toBe(WSDLVersion.WSDL_1_1);
      expect(metadata.serviceCount).toBe(1);
      expect(metadata.operationCount).toBe(1);
      expect(metadata.messageCount).toBe(2);
      expect(metadata.bindingCount).toBe(1);
      expect(metadata.namespaces).toContain('wsdl');
      expect(metadata.namespaces).toContain('soap');
      expect(metadata.namespaces).toContain('tns');
    });
  });

  describe('WSDL 버전 감지', () => {
    it('WSDL 1.1을 올바르게 감지해야 합니다', async () => {
      const wsdl11 = `<?xml version="1.0"?>
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" 
                  targetNamespace="http://example.com/test">
  <wsdl:service name="TestService">
    <wsdl:port name="TestPort" binding="tns:TestBinding">
      <soap:address location="http://example.com/test"/>
    </wsdl:port>
  </wsdl:service>
</wsdl:definitions>`;

      const result = await parser.parse(wsdl11);
      expect(result.metadata.version).toBe(WSDLVersion.WSDL_1_1);
    });

    it('WSDL 2.0을 올바르게 감지해야 합니다', async () => {
      const wsdl20 = `<?xml version="1.0"?>
<wsdl:description xmlns:wsdl="http://www.w3.org/ns/wsdl" 
                  targetNamespace="http://example.com/test">
  <wsdl:service name="TestService">
    <wsdl:endpoint name="TestEndpoint" binding="tns:TestBinding" 
                   address="http://example.com/test"/>
  </wsdl:service>
</wsdl:description>`;

      const result = await parser.parse(wsdl20);
      expect(result.metadata.version).toBe(WSDLVersion.WSDL_2_0);
    });
  });

  describe('오퍼레이션 타입 감지', () => {
    it('Request-Response 오퍼레이션을 올바르게 감지해야 합니다', async () => {
      const wsdl = `<?xml version="1.0"?>
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" 
                  targetNamespace="http://example.com/test">
  <wsdl:portType name="TestPortType">
    <wsdl:operation name="TestOperation">
      <wsdl:input message="tns:TestRequest"/>
      <wsdl:output message="tns:TestResponse"/>
    </wsdl:operation>
  </wsdl:portType>
</wsdl:definitions>`;

      const result = await parser.parse(wsdl);
      const operation = result.schema.content.portTypes[0].operations[0];
      expect(operation.type).toBe(OperationType.REQUEST_RESPONSE);
    });

    it('One-Way 오퍼레이션을 올바르게 감지해야 합니다', async () => {
      const wsdl = `<?xml version="1.0"?>
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" 
                  targetNamespace="http://example.com/test">
  <wsdl:portType name="TestPortType">
    <wsdl:operation name="TestOperation">
      <wsdl:input message="tns:TestRequest"/>
    </wsdl:operation>
  </wsdl:portType>
</wsdl:definitions>`;

      const result = await parser.parse(wsdl);
      const operation = result.schema.content.portTypes[0].operations[0];
      expect(operation.type).toBe(OperationType.ONE_WAY);
    });

    it('Notification 오퍼레이션을 올바르게 감지해야 합니다', async () => {
      const wsdl = `<?xml version="1.0"?>
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" 
                  targetNamespace="http://example.com/test">
  <wsdl:portType name="TestPortType">
    <wsdl:operation name="TestOperation">
      <wsdl:output message="tns:TestResponse"/>
    </wsdl:operation>
  </wsdl:portType>
</wsdl:definitions>`;

      const result = await parser.parse(wsdl);
      const operation = result.schema.content.portTypes[0].operations[0];
      expect(operation.type).toBe(OperationType.NOTIFICATION);
    });
  });

  describe('SOAP 바인딩 파싱', () => {
    it('SOAP 바인딩 스타일을 올바르게 파싱해야 합니다', async () => {
      const wsdl = `<?xml version="1.0"?>
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" 
                  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
                  targetNamespace="http://example.com/test">
  <wsdl:binding name="TestBinding" type="tns:TestPortType">
    <soap:binding style="rpc" transport="http://schemas.xmlsoap.org/soap/http"/>
    <wsdl:operation name="TestOperation">
      <soap:operation soapAction="test"/>
      <wsdl:input>
        <soap:body use="encoded"/>
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal"/>
      </wsdl:output>
    </wsdl:operation>
  </wsdl:binding>
</wsdl:definitions>`;

      const result = await parser.parse(wsdl);
      const binding = result.schema.content.bindings[0];
      
      expect(binding.style).toBe(WSDLStyle.RPC);
      expect(binding.operations[0].input?.use).toBe(WSDLUse.ENCODED);
      expect(binding.operations[0].output?.use).toBe(WSDLUse.LITERAL);
    });

    it('SOAP 헤더를 올바르게 처리해야 합니다', async () => {
      const wsdl = `<?xml version="1.0"?>
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" 
                  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
                  targetNamespace="http://example.com/test">
  <wsdl:binding name="TestBinding" type="tns:TestPortType">
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
    <wsdl:operation name="TestOperation">
      <wsdl:input>
        <soap:body use="literal"/>
        <soap:header message="tns:AuthHeader" part="credentials" use="literal"/>
      </wsdl:input>
    </wsdl:operation>
  </wsdl:binding>
</wsdl:definitions>`;

      const result = await parser.parse(wsdl);
      expect(result.schema.content.bindings).toHaveLength(1);
      expect(result.schema.content.bindings[0].operations).toHaveLength(1);
    });
  });

  describe('에러 처리', () => {
    it('잘못된 XML에 대해 에러를 발생시켜야 합니다', async () => {
      const invalidXML = '<invalid><xml>';
      
      await expect(parser.parse(invalidXML)).rejects.toThrow();
    });

    it('definitions 요소가 없는 경우 에러를 발생시켜야 합니다', async () => {
      const invalidWSDL = '<?xml version="1.0"?><root></root>';
      
      await expect(parser.parse(invalidWSDL)).rejects.toThrow('Invalid WSDL: definitions element not found');
    });
  });

  describe('검증', () => {
    it('참조 무결성 에러를 감지해야 합니다', async () => {
      const invalidWSDL = `<?xml version="1.0"?>
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" 
                  targetNamespace="http://example.com/test">
  <wsdl:binding name="TestBinding" type="tns:NonExistentPortType">
    <wsdl:operation name="TestOperation"/>
  </wsdl:binding>
</wsdl:definitions>`;

      const result = await parser.parse(invalidWSDL);
      expect(result.validation.isValid).toBe(false);
      expect(result.validation.errors.length).toBeGreaterThan(0);
      expect(result.validation.errors.some(e => e.message.includes('NonExistentPortType'))).toBe(true);
    });

    it('메시지 참조 에러를 감지해야 합니다', async () => {
      const invalidWSDL = `<?xml version="1.0"?>
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" 
                  targetNamespace="http://example.com/test">
  <wsdl:portType name="TestPortType">
    <wsdl:operation name="TestOperation">
      <wsdl:input message="tns:NonExistentMessage"/>
    </wsdl:operation>
  </wsdl:portType>
</wsdl:definitions>`;

      const result = await parser.parse(invalidWSDL);
      expect(result.validation.isValid).toBe(false);
      expect(result.validation.errors.some(e => e.message.includes('NonExistentMessage'))).toBe(true);
    });

    it('네임스페이스 경고를 생성해야 합니다', async () => {
      const wsdlWithoutNamespaces = `<?xml version="1.0"?>
<wsdl:definitions targetNamespace="http://example.com/test">
  <wsdl:service name="TestService"/>
</wsdl:definitions>`;

      const result = await parser.parse(wsdlWithoutNamespaces);
      expect(result.validation.warnings.length).toBeGreaterThan(0);
      expect(result.validation.warnings.some(w => w.message.includes('namespace'))).toBe(true);
    });
  });

  describe('문서화 추출', () => {
    it('문서화 정보를 올바르게 추출해야 합니다', async () => {
      const wsdlWithDocs = `<?xml version="1.0"?>
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" 
                  targetNamespace="http://example.com/test">
  <wsdl:documentation>This is a test service</wsdl:documentation>
  <wsdl:portType name="TestPortType">
    <wsdl:documentation>Test port type documentation</wsdl:documentation>
    <wsdl:operation name="TestOperation">
      <wsdl:documentation>Test operation documentation</wsdl:documentation>
    </wsdl:operation>
  </wsdl:portType>
</wsdl:definitions>`;

      const result = await parser.parse(wsdlWithDocs);
      expect(result.schema.metadata.documentation).toBe('This is a test service');
      expect(result.schema.content.portTypes[0].documentation).toBe('Test port type documentation');
      expect(result.schema.content.portTypes[0].operations[0].documentation).toBe('Test operation documentation');
    });
  });

  describe('복잡한 WSDL 구조', () => {
    it('여러 서비스와 바인딩을 가진 WSDL을 파싱해야 합니다', async () => {
      const complexWSDL = `<?xml version="1.0"?>
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" 
                  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
                  targetNamespace="http://example.com/test">
  
  <wsdl:portType name="PortType1">
    <wsdl:operation name="Operation1">
      <wsdl:input message="tns:Message1"/>
      <wsdl:output message="tns:Message2"/>
    </wsdl:operation>
  </wsdl:portType>
  
  <wsdl:portType name="PortType2">
    <wsdl:operation name="Operation2">
      <wsdl:input message="tns:Message3"/>
    </wsdl:operation>
  </wsdl:portType>
  
  <wsdl:binding name="Binding1" type="tns:PortType1">
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
  </wsdl:binding>
  
  <wsdl:binding name="Binding2" type="tns:PortType2">
    <soap:binding style="rpc" transport="http://schemas.xmlsoap.org/soap/http"/>
  </wsdl:binding>
  
  <wsdl:service name="Service1">
    <wsdl:port name="Port1" binding="tns:Binding1">
      <soap:address location="http://example.com/service1"/>
    </wsdl:port>
  </wsdl:service>
  
  <wsdl:service name="Service2">
    <wsdl:port name="Port2" binding="tns:Binding2">
      <soap:address location="http://example.com/service2"/>
    </wsdl:port>
  </wsdl:service>
</wsdl:definitions>`;

      const result = await parser.parse(complexWSDL);
      
      expect(result.schema.content.services).toHaveLength(2);
      expect(result.schema.content.bindings).toHaveLength(2);
      expect(result.schema.content.portTypes).toHaveLength(2);
      
      expect(result.metadata.serviceCount).toBe(2);
      expect(result.metadata.bindingCount).toBe(2);
      expect(result.metadata.operationCount).toBe(2);
    });
  });
});