import { OpenAPISchema, OpenAPIParseResult, OpenAPIParseOptions, OpenAPIValidationError, OpenAPIErrorCode } from '@eai/shared/types/openapi';
import { ParseError, ParseOptions } from '../types';
import { ErrorHandler } from '../utils/error-handler';
import { JSONSchemaParser } from './json-schema-parser';
import { BaseParser } from './base-parser';

/**
 * OpenAPI 파싱 엔진
 * OpenAPI 3.0/3.1 스펙을 파싱하고 $ref 참조 해결 및 컴포넌트 역참조를 제공합니다.
 */
export class OpenAPIParser extends BaseParser {
  private jsonSchemaParser: JSONSchemaParser;
  private errorHandler: ErrorHandler;
  private referenceCache: Map<string, any> = new Map();
  private componentCache: Map<string, any> = new Map();

  constructor() {
    super();
    this.jsonSchemaParser = new JSONSchemaParser();
    this.errorHandler = new ErrorHandler();
  }

  /**
   * OpenAPI 스펙을 파싱합니다.
   * @param content OpenAPI 스펙 문자열 또는 객체
   * @param options 파싱 옵션
   * @returns 파싱 결과
   */
  async parse(content: string | object, options: OpenAPIParseOptions = {}): Promise<OpenAPIParseResult> {
    const parseOptions = this.getDefaultOptions(options);
    const errors: ParseError[] = [];
    const warnings: ParseError[] = [];

    try {
      // 입력 검증 및 파싱
      let specObject: any;
      if (typeof content === 'string') {
        // YAML 또는 JSON 파싱
        specObject = this.parseContent(content);
      } else {
        specObject = content;
      }

      // OpenAPI 버전 검증
      const versionErrors = this.validateOpenAPIVersion(specObject);
      errors.push(...versionErrors);

      // 필수 필드 검증
      const requiredFieldErrors = this.validateRequiredFields(specObject);
      errors.push(...requiredFieldErrors);

      // 스키마 검증
      if (parseOptions.validateSchema) {
        const schemaErrors = await this.validateOpenAPISchema(specObject);
        errors.push(...schemaErrors);
      }

      // 참조 해결
      if (parseOptions.resolveReferences) {
        specObject = await this.resolveReferences(specObject, parseOptions);
      }

      // 컴포넌트 역참조
      if (parseOptions.dereferenceComponents) {
        specObject = this.dereferenceComponents(specObject);
      }

      // OpenAPI 스키마 문서 생성
      const schema: OpenAPISchema = {
        id: this.generateId(),
        name: specObject.info?.title || 'Untitled API',
        version: specObject.info?.version || '1.0.0',
        type: 'OPENAPI' as const,
        namespace: specObject.servers?.[0]?.url || '',
        content: specObject,
        metadata: {
          createdAt: new Date(),
          updatedAt: new Date(),
          source: 'parser'
        }
      };

      // 메타데이터 생성
      const metadata = this.generateMetadata(specObject);

      return {
        schema,
        validation: {
          isValid: errors.length === 0,
          errors: errors.map(e => ({
            code: e.code,
            message: e.message,
            severity: e.severity,
            path: e.path || ''
          })),
          warnings: warnings.map(w => ({
            code: w.code,
            message: w.message,
            severity: w.severity,
            path: w.path || ''
          }))
        },
        metadata
      };

    } catch (error) {
      const parseError = this.errorHandler.createParseError(error as Error);
      errors.push(parseError);

      // 빈 스키마 반환
      const emptySchema: OpenAPISchema = {
        id: this.generateId(),
        name: 'Error API',
        version: '1.0.0',
        type: 'OPENAPI' as const,
        content: {
          openapi: '3.0.0',
          info: { title: 'Error API', version: '1.0.0' },
          paths: {}
        },
        metadata: {
          createdAt: new Date(),
          updatedAt: new Date(),
          source: 'parser'
        }
      };

      return {
        schema: emptySchema,
        validation: {
          isValid: false,
          errors: errors.map(e => ({
            code: e.code,
            message: e.message,
            severity: e.severity,
            path: e.path || ''
          })),
          warnings: []
        },
        metadata: {
          version: '3.0.0',
          pathCount: 0,
          operationCount: 0,
          schemaCount: 0,
          componentCount: 0,
          externalReferences: []
        }
      };
    }
  }

  /**
   * 기본 파싱 옵션 설정
   */
  private getDefaultOptions(options: OpenAPIParseOptions): Required<OpenAPIParseOptions> {
    return {
      resolveReferences: options.resolveReferences ?? true,
      validateSchema: options.validateSchema ?? true,
      dereferenceComponents: options.dereferenceComponents ?? false,
      maxDepth: options.maxDepth || 100,
      timeout: options.timeout || 30000
    };
  }

  /**
   * 콘텐츠 파싱 (JSON/YAML)
   */
  private parseContent(content: string): any {
    const trimmedContent = content.trim();
    
    // JSON 시도
    if (trimmedContent.startsWith('{')) {
      try {
        return JSON.parse(content);
      } catch (error) {
        throw new Error(`JSON 파싱 실패: ${(error as Error).message}`);
      }
    }

    // YAML 시도 (간단한 YAML 파싱 - 실제로는 yaml 라이브러리 사용 권장)
    try {
      // 여기서는 간단한 YAML 파싱만 구현
      // 실제 프로덕션에서는 'js-yaml' 라이브러리 사용
      return this.parseSimpleYAML(content);
    } catch (error) {
      throw new Error(`YAML 파싱 실패: ${(error as Error).message}`);
    }
  }

  /**
   * 간단한 YAML 파싱 (제한적)
   */
  private parseSimpleYAML(content: string): any {
    // 실제로는 js-yaml 라이브러리를 사용해야 함
    // 여기서는 JSON으로 변환 시도
    try {
      // 매우 기본적인 YAML to JSON 변환
      const lines = content.split('\n');
      const result: any = {};
      let currentKey = '';
      
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed && !trimmed.startsWith('#')) {
          if (trimmed.includes(':')) {
            const [key, value] = trimmed.split(':', 2);
            currentKey = key.trim();
            const trimmedValue = value?.trim();
            if (trimmedValue) {
              result[currentKey] = this.parseYAMLValue(trimmedValue);
            } else {
              result[currentKey] = {};
            }
          }
        }
      }
      
      return result;
    } catch (error) {
      throw new Error('YAML 파싱은 현재 제한적으로 지원됩니다. JSON 형식을 사용해주세요.');
    }
  }

  /**
   * YAML 값 파싱
   */
  private parseYAMLValue(value: string): any {
    // 문자열 따옴표 제거
    if ((value.startsWith('"') && value.endsWith('"')) || 
        (value.startsWith("'") && value.endsWith("'"))) {
      return value.slice(1, -1);
    }
    
    // 숫자
    if (/^\d+$/.test(value)) {
      return parseInt(value, 10);
    }
    
    if (/^\d+\.\d+$/.test(value)) {
      return parseFloat(value);
    }
    
    // 불린
    if (value === 'true') return true;
    if (value === 'false') return false;
    if (value === 'null') return null;
    
    return value;
  }

  /**
   * OpenAPI 버전 검증
   */
  private validateOpenAPIVersion(spec: any): ParseError[] {
    const errors: ParseError[] = [];

    if (!spec.openapi) {
      errors.push({
        code: 'MISSING_OPENAPI_VERSION',
        message: 'OpenAPI 버전이 명시되지 않았습니다.',
        severity: 'error',
        path: 'openapi'
      });
      return errors;
    }

    const version = spec.openapi;
    if (!version.startsWith('3.0') && !version.startsWith('3.1')) {
      errors.push({
        code: 'UNSUPPORTED_OPENAPI_VERSION',
        message: `지원되지 않는 OpenAPI 버전입니다: ${version}. 3.0.x 또는 3.1.x를 사용해주세요.`,
        severity: 'error',
        path: 'openapi'
      });
    }

    return errors;
  }

  /**
   * 필수 필드 검증
   */
  private validateRequiredFields(spec: any): ParseError[] {
    const errors: ParseError[] = [];

    // info 필드 검증
    if (!spec.info) {
      errors.push({
        code: 'MISSING_INFO',
        message: 'info 필드가 필수입니다.',
        severity: 'error',
        path: 'info'
      });
    } else {
      if (!spec.info.title) {
        errors.push({
          code: 'MISSING_INFO_TITLE',
          message: 'info.title 필드가 필수입니다.',
          severity: 'error',
          path: 'info.title'
        });
      }
      if (!spec.info.version) {
        errors.push({
          code: 'MISSING_INFO_VERSION',
          message: 'info.version 필드가 필수입니다.',
          severity: 'error',
          path: 'info.version'
        });
      }
    }

    // paths 필드 검증
    if (!spec.paths) {
      errors.push({
        code: 'MISSING_PATHS',
        message: 'paths 필드가 필수입니다.',
        severity: 'error',
        path: 'paths'
      });
    }

    return errors;
  }

  /**
   * OpenAPI 스키마 검증
   */
  private async validateOpenAPISchema(spec: any): Promise<ParseError[]> {
    const errors: ParseError[] = [];

    try {
      // 경로 매개변수 검증
      if (spec.paths) {
        for (const [path, pathItem] of Object.entries(spec.paths)) {
          const pathErrors = this.validatePathItem(path, pathItem as any);
          errors.push(...pathErrors);
        }
      }

      // 컴포넌트 검증
      if (spec.components) {
        const componentErrors = await this.validateComponents(spec.components);
        errors.push(...componentErrors);
      }

    } catch (error) {
      errors.push({
        code: 'SCHEMA_VALIDATION_ERROR',
        message: `스키마 검증 중 오류: ${(error as Error).message}`,
        severity: 'error'
      });
    }

    return errors;
  }

  /**
   * 경로 항목 검증
   */
  private validatePathItem(path: string, pathItem: any): ParseError[] {
    const errors: ParseError[] = [];

    // 경로 매개변수 검증
    const pathParams = this.extractPathParameters(path);
    
    const methods = ['get', 'post', 'put', 'delete', 'options', 'head', 'patch', 'trace'];
    for (const method of methods) {
      if (pathItem[method]) {
        const operation = pathItem[method];
        const operationErrors = this.validateOperation(path, method, operation, pathParams);
        errors.push(...operationErrors);
      }
    }

    return errors;
  }

  /**
   * 경로에서 매개변수 추출
   */
  private extractPathParameters(path: string): string[] {
    const matches = path.match(/\{([^}]+)\}/g);
    return matches ? matches.map(match => match.slice(1, -1)) : [];
  }

  /**
   * 오퍼레이션 검증
   */
  private validateOperation(path: string, method: string, operation: any, pathParams: string[]): ParseError[] {
    const errors: ParseError[] = [];

    // 경로 매개변수와 오퍼레이션 매개변수 일치 검증
    if (operation.parameters) {
      const operationPathParams = operation.parameters
        .filter((p: any) => p.in === 'path')
        .map((p: any) => p.name);

      for (const pathParam of pathParams) {
        if (!operationPathParams.includes(pathParam)) {
          errors.push({
            code: 'MISSING_PATH_PARAMETER',
            message: `경로 매개변수 '${pathParam}'가 오퍼레이션에 정의되지 않았습니다.`,
            severity: 'error',
            path: `paths.${path}.${method}.parameters`
          });
        }
      }
    } else if (pathParams.length > 0) {
      errors.push({
        code: 'MISSING_PATH_PARAMETERS',
        message: `경로에 매개변수가 있지만 오퍼레이션에 정의되지 않았습니다: ${pathParams.join(', ')}`,
        severity: 'error',
        path: `paths.${path}.${method}`
      });
    }

    // responses 필드 검증
    if (!operation.responses) {
      errors.push({
        code: 'MISSING_RESPONSES',
        message: 'responses 필드가 필수입니다.',
        severity: 'error',
        path: `paths.${path}.${method}.responses`
      });
    }

    return errors;
  }

  /**
   * 컴포넌트 검증
   */
  private async validateComponents(components: any): Promise<ParseError[]> {
    const errors: ParseError[] = [];

    // 스키마 컴포넌트 검증
    if (components.schemas) {
      for (const [name, schema] of Object.entries(components.schemas)) {
        try {
          // JSON Schema 파서를 사용하여 스키마 검증
          const result = await this.jsonSchemaParser.parse(schema);
          if (!result.validation.isValid) {
            errors.push({
              code: 'INVALID_COMPONENT_SCHEMA',
              message: `컴포넌트 스키마 '${name}' 검증 실패`,
              severity: 'error',
              path: `components.schemas.${name}`
            });
          }
        } catch (error) {
          errors.push({
            code: 'COMPONENT_SCHEMA_ERROR',
            message: `컴포넌트 스키마 '${name}' 처리 중 오류: ${(error as Error).message}`,
            severity: 'error',
            path: `components.schemas.${name}`
          });
        }
      }
    }

    return errors;
  }

  /**
   * 참조 해결
   */
  private async resolveReferences(spec: any, options: Required<OpenAPIParseOptions>): Promise<any> {
    const resolved = JSON.parse(JSON.stringify(spec)); // 깊은 복사
    const context = {
      spec: resolved,
      visited: new Set<string>(),
      depth: 0
    };

    return this.resolveReferencesRecursive(resolved, context, options);
  }

  /**
   * 재귀적 참조 해결
   */
  private async resolveReferencesRecursive(
    obj: any,
    context: { spec: any; visited: Set<string>; depth: number },
    options: Required<OpenAPIParseOptions>
  ): Promise<any> {
    if (context.depth > options.maxDepth) {
      throw new Error(`최대 깊이 ${options.maxDepth}를 초과했습니다.`);
    }

    if (typeof obj !== 'object' || obj === null) {
      return obj;
    }

    // $ref 처리
    if (obj.$ref) {
      return this.resolveReference(obj.$ref, context, options);
    }

    // 배열 처리
    if (Array.isArray(obj)) {
      const resolved = [];
      for (const item of obj) {
        resolved.push(await this.resolveReferencesRecursive(item, { ...context, depth: context.depth + 1 }, options));
      }
      return resolved;
    }

    // 객체 처리
    const resolved: any = {};
    for (const [key, value] of Object.entries(obj)) {
      resolved[key] = await this.resolveReferencesRecursive(value, { ...context, depth: context.depth + 1 }, options);
    }

    return resolved;
  }

  /**
   * 단일 참조 해결
   */
  private async resolveReference(
    ref: string,
    context: { spec: any; visited: Set<string>; depth: number },
    options: Required<OpenAPIParseOptions>
  ): Promise<any> {
    // 순환 참조 검사
    if (context.visited.has(ref)) {
      return { $ref: ref, __circular: true };
    }

    context.visited.add(ref);

    try {
      // 캐시에서 확인
      if (this.referenceCache.has(ref)) {
        return this.referenceCache.get(ref);
      }

      // 로컬 참조 (#/components/...)
      if (ref.startsWith('#/')) {
        const resolved = this.resolveLocalReference(ref, context.spec);
        this.referenceCache.set(ref, resolved);
        return resolved;
      }

      // 외부 참조
      if (ref.startsWith('http://') || ref.startsWith('https://')) {
        const resolved = await this.loadExternalReference(ref);
        this.referenceCache.set(ref, resolved);
        return resolved;
      }

      // 상대 참조
      const resolved = await this.loadExternalReference(ref);
      this.referenceCache.set(ref, resolved);
      return resolved;

    } catch (error) {
      // 참조 해결 실패 시 원본 참조 유지
      return { $ref: ref, __error: (error as Error).message };
    } finally {
      context.visited.delete(ref);
    }
  }

  /**
   * 로컬 참조 해결
   */
  private resolveLocalReference(ref: string, spec: any): any {
    const path = ref.substring(2); // '#/' 제거
    const parts = path.split('/');
    
    let current = spec;
    for (const part of parts) {
      if (current && typeof current === 'object' && part in current) {
        current = current[part];
      } else {
        throw new Error(`참조를 찾을 수 없습니다: ${ref}`);
      }
    }

    return current;
  }

  /**
   * 외부 참조 로드
   */
  private async loadExternalReference(ref: string): Promise<any> {
    // 실제 구현에서는 HTTP 요청을 통해 외부 참조를 로드해야 함
    throw new Error(`외부 참조 로드는 아직 구현되지 않았습니다: ${ref}`);
  }

  /**
   * 컴포넌트 역참조
   */
  private dereferenceComponents(spec: any): any {
    const dereferenced = JSON.parse(JSON.stringify(spec));

    if (dereferenced.components) {
      // 컴포넌트를 인라인으로 확장
      this.inlineComponents(dereferenced, dereferenced.components);
      
      // 컴포넌트 섹션 제거 (선택적)
      // delete dereferenced.components;
    }

    return dereferenced;
  }

  /**
   * 컴포넌트 인라인 확장
   */
  private inlineComponents(obj: any, components: any): void {
    if (typeof obj !== 'object' || obj === null) {
      return;
    }

    if (Array.isArray(obj)) {
      obj.forEach(item => this.inlineComponents(item, components));
      return;
    }

    // $ref를 실제 컴포넌트로 교체
    if (obj.$ref && obj.$ref.startsWith('#/components/')) {
      const componentRef = this.resolveLocalReference(obj.$ref, { components });
      Object.assign(obj, componentRef);
      delete obj.$ref;
    }

    // 재귀적으로 처리
    Object.values(obj).forEach(value => {
      this.inlineComponents(value, components);
    });
  }

  /**
   * 메타데이터 생성
   */
  private generateMetadata(spec: any): any {
    const metadata = {
      version: spec.openapi || '3.0.0',
      pathCount: 0,
      operationCount: 0,
      schemaCount: 0,
      componentCount: 0,
      externalReferences: [] as string[]
    };

    // 경로 및 오퍼레이션 개수
    if (spec.paths) {
      metadata.pathCount = Object.keys(spec.paths).length;
      
      for (const pathItem of Object.values(spec.paths)) {
        const methods = ['get', 'post', 'put', 'delete', 'options', 'head', 'patch', 'trace'];
        for (const method of methods) {
          if ((pathItem as any)[method]) {
            metadata.operationCount++;
          }
        }
      }
    }

    // 컴포넌트 개수
    if (spec.components) {
      if (spec.components.schemas) {
        metadata.schemaCount = Object.keys(spec.components.schemas).length;
      }
      
      const componentTypes = ['schemas', 'responses', 'parameters', 'examples', 'requestBodies', 'headers', 'securitySchemes', 'links', 'callbacks'];
      metadata.componentCount = componentTypes.reduce((count, type) => {
        return count + (spec.components[type] ? Object.keys(spec.components[type]).length : 0);
      }, 0);
    }

    // 외부 참조 수집
    this.collectExternalReferences(spec, metadata.externalReferences);

    return metadata;
  }

  /**
   * 외부 참조 수집
   */
  private collectExternalReferences(obj: any, externalRefs: string[]): void {
    if (typeof obj !== 'object' || obj === null) {
      return;
    }

    if (Array.isArray(obj)) {
      obj.forEach(item => this.collectExternalReferences(item, externalRefs));
      return;
    }

    // $ref가 외부 참조인지 확인
    if (obj.$ref && !obj.$ref.startsWith('#/')) {
      if (!externalRefs.includes(obj.$ref)) {
        externalRefs.push(obj.$ref);
      }
    }

    // 재귀적으로 처리
    Object.values(obj).forEach(value => {
      this.collectExternalReferences(value, externalRefs);
    });
  }

  /**
   * 고유 ID 생성
   */
  private generateId(): string {
    return `openapi-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * 캐시 정리
   */
  clearCache(): void {
    this.referenceCache.clear();
    this.componentCache.clear();
    this.jsonSchemaParser.clearCache();
  }
}