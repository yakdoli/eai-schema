// SAP OData 메타데이터 파싱 어댑터
import { XMLParser } from 'fast-xml-parser';
import {
  SAPODataSchema,
  SAPODataContent,
  EntitySet,
  EntityType,
  ComplexType,
  Association,
  FunctionImport,
  EntityContainer,
  ODataProperty,
  NavigationProperty,
  Multiplicity,
  ParameterMode,
} from '@eai/shared/types/sap';
import { SchemaType } from '@eai/shared/types';
import {
  SAPAdapter,
  SAPParseOptions,
  SAPParseResult,
  SAPValidationResult,
  SAPMetadata,
  SAPParseError,
  SAPParseWarning,
  SAPValidationError,
  SAPValidationWarning,
} from '../types';

export class ODataAdapter implements SAPAdapter<SAPODataSchema> {
  private xmlParser: XMLParser;

  constructor() {
    this.xmlParser = new XMLParser({
      ignoreAttributes: false,
      attributeNamePrefix: '@_',
      textNodeName: '#text',
      parseAttributeValue: true,
      trimValues: true,
    });
  }

  async parse(
    content: string,
    options: SAPParseOptions = {}
  ): Promise<SAPParseResult<SAPODataSchema>> {
    const startTime = Date.now();
    const errors: SAPParseError[] = [];
    const warnings: SAPParseError[] = [];

    try {
      // XML 파싱
      const xmlData = this.xmlParser.parse(content);
      
      // EDMX 루트 요소 확인
      const edmx = xmlData['edmx:Edmx'] || xmlData.Edmx;
      if (!edmx) {
        throw new Error('유효하지 않은 OData 메타데이터: EDMX 루트 요소를 찾을 수 없습니다.');
      }

      // DataServices 추출
      const dataServices = edmx['edmx:DataServices'] || edmx.DataServices;
      if (!dataServices) {
        throw new Error('DataServices 요소를 찾을 수 없습니다.');
      }

      // Schema 추출
      const schemas = Array.isArray(dataServices.Schema) 
        ? dataServices.Schema 
        : [dataServices.Schema];

      if (!schemas || schemas.length === 0) {
        throw new Error('Schema 요소를 찾을 수 없습니다.');
      }

      // 첫 번째 스키마 처리 (다중 스키마 지원은 향후 확장)
      const schemaData = schemas[0];
      const parsedContent = await this.parseSchema(schemaData, options);

      const metadata: SAPMetadata = {
        version: edmx['@_Version'] || '1.0',
        namespace: schemaData['@_Namespace'],
        createdAt: new Date(),
        parsedAt: new Date(),
      };

      const processingTime = Date.now() - startTime;

      const result: SAPODataSchema = {
        id: this.generateId(),
        name: schemaData['@_Namespace'] || 'Unknown',
        version: metadata.version,
        type: SchemaType.SAP_ODATA,
        originalFormat: 'EDMX',
        metadata: {
          namespace: metadata.namespace,
          targetNamespace: metadata.namespace,
          imports: [],
          annotations: [],
        },
        content: parsedContent,
        createdAt: metadata.createdAt,
        updatedAt: metadata.parsedAt,
      };

      return {
        schema: result,
        metadata,
        errors,
        warnings: warnings.filter(w => w.severity === 'warning') as SAPParseWarning[],
        statistics: {
          totalElements: this.countElements(parsedContent),
          parsedElements: this.countElements(parsedContent) - errors.length,
          errorCount: errors.length,
          warningCount: warnings.length,
          processingTime,
        },
      };
    } catch (error) {
      errors.push({
        code: 'PARSE_ERROR',
        message: error instanceof Error ? error.message : '알 수 없는 파싱 오류',
        severity: 'error',
      });

      throw error;
    }
  }

  private async parseSchema(
    schema: any,
    options: SAPParseOptions
  ): Promise<SAPODataContent> {
    const entityTypes = await this.parseEntityTypes(schema.EntityType || []);
    const complexTypes = await this.parseComplexTypes(schema.ComplexType || []);
    const associations = await this.parseAssociations(schema.Association || []);
    const entityContainer = await this.parseEntityContainer(schema.EntityContainer);

    return {
      entitySets: entityContainer.entitySets,
      entityTypes,
      complexTypes,
      associations,
      functionImports: entityContainer.functionImports,
      entityContainer,
    };
  }

  private async parseEntityTypes(entityTypesData: any[]): Promise<EntityType[]> {
    if (!Array.isArray(entityTypesData)) {
      entityTypesData = entityTypesData ? [entityTypesData] : [];
    }

    return entityTypesData.map((entityType) => ({
      name: entityType['@_Name'],
      key: this.parseEntityKey(entityType.Key),
      properties: this.parseProperties(entityType.Property || []),
      navigationProperties: this.parseNavigationProperties(
        entityType.NavigationProperty || []
      ),
      annotations: this.parseAnnotations(entityType.Annotation || []),
    }));
  }

  private parseEntityKey(keyData: any): any {
    if (!keyData || !keyData.PropertyRef) {
      return { propertyRefs: [] };
    }

    const propertyRefs = Array.isArray(keyData.PropertyRef)
      ? keyData.PropertyRef
      : [keyData.PropertyRef];

    return {
      propertyRefs: propertyRefs.map((ref: any) => ({
        name: ref['@_Name'],
      })),
    };
  }

  private parseProperties(propertiesData: any[]): ODataProperty[] {
    if (!Array.isArray(propertiesData)) {
      propertiesData = propertiesData ? [propertiesData] : [];
    }

    return propertiesData.map((prop) => ({
      name: prop['@_Name'],
      type: prop['@_Type'],
      isRequired: prop['@_Nullable'] === 'false',
      isArray: false,
      nullable: prop['@_Nullable'] !== 'false',
      maxLength: prop['@_MaxLength'] ? parseInt(prop['@_MaxLength']) : undefined,
      precision: prop['@_Precision'] ? parseInt(prop['@_Precision']) : undefined,
      scale: prop['@_Scale'] ? parseInt(prop['@_Scale']) : undefined,
      unicode: prop['@_Unicode'] === 'true',
      fixedLength: prop['@_FixedLength'] === 'true',
      collation: prop['@_Collation'],
      srid: prop['@_SRID'],
      constraints: [],
      annotations: [],
    }));
  }

  private parseNavigationProperties(navPropsData: any[]): NavigationProperty[] {
    if (!Array.isArray(navPropsData)) {
      navPropsData = navPropsData ? [navPropsData] : [];
    }

    return navPropsData.map((navProp) => ({
      name: navProp['@_Name'],
      relationship: navProp['@_Relationship'],
      fromRole: navProp['@_FromRole'],
      toRole: navProp['@_ToRole'],
    }));
  }

  private async parseComplexTypes(complexTypesData: any[]): Promise<ComplexType[]> {
    if (!Array.isArray(complexTypesData)) {
      complexTypesData = complexTypesData ? [complexTypesData] : [];
    }

    return complexTypesData.map((complexType) => ({
      name: complexType['@_Name'],
      properties: this.parseProperties(complexType.Property || []),
      annotations: this.parseAnnotations(complexType.Annotation || []),
    }));
  }

  private async parseAssociations(associationsData: any[]): Promise<Association[]> {
    if (!Array.isArray(associationsData)) {
      associationsData = associationsData ? [associationsData] : [];
    }

    return associationsData.map((association) => ({
      name: association['@_Name'],
      ends: this.parseAssociationEnds(association.End || []),
      referentialConstraint: this.parseReferentialConstraint(
        association.ReferentialConstraint
      ),
    }));
  }

  private parseAssociationEnds(endsData: any[]): any[] {
    if (!Array.isArray(endsData)) {
      endsData = endsData ? [endsData] : [];
    }

    return endsData.map((end) => ({
      role: end['@_Role'],
      type: end['@_Type'],
      multiplicity: this.parseMultiplicity(end['@_Multiplicity']),
    }));
  }

  private parseMultiplicity(multiplicity: string): Multiplicity {
    switch (multiplicity) {
      case '0..1':
        return Multiplicity.ZERO_OR_ONE;
      case '1':
        return Multiplicity.ONE;
      case '*':
        return Multiplicity.MANY;
      default:
        return Multiplicity.ZERO_OR_ONE;
    }
  }

  private parseReferentialConstraint(constraintData: any): any {
    if (!constraintData) return undefined;

    return {
      principal: {
        role: constraintData.Principal['@_Role'],
        propertyRefs: this.parsePropertyRefs(constraintData.Principal.PropertyRef),
      },
      dependent: {
        role: constraintData.Dependent['@_Role'],
        propertyRefs: this.parsePropertyRefs(constraintData.Dependent.PropertyRef),
      },
    };
  }

  private parsePropertyRefs(propertyRefsData: any): any[] {
    if (!propertyRefsData) return [];
    
    const refs = Array.isArray(propertyRefsData) ? propertyRefsData : [propertyRefsData];
    return refs.map((ref) => ({ name: ref['@_Name'] }));
  }

  private async parseEntityContainer(containerData: any): Promise<EntityContainer> {
    if (!containerData) {
      throw new Error('EntityContainer를 찾을 수 없습니다.');
    }

    const entitySets = this.parseEntitySets(containerData.EntitySet || []);
    const functionImports = this.parseFunctionImports(containerData.FunctionImport || []);

    return {
      name: containerData['@_Name'],
      isDefaultEntityContainer: containerData['@_IsDefaultEntityContainer'] === 'true',
      entitySets,
      functionImports,
    };
  }

  private parseEntitySets(entitySetsData: any[]): EntitySet[] {
    if (!Array.isArray(entitySetsData)) {
      entitySetsData = entitySetsData ? [entitySetsData] : [];
    }

    return entitySetsData.map((entitySet) => ({
      name: entitySet['@_Name'],
      entityType: entitySet['@_EntityType'],
      annotations: this.parseAnnotations(entitySet.Annotation || []),
    }));
  }

  private parseFunctionImports(functionImportsData: any[]): FunctionImport[] {
    if (!Array.isArray(functionImportsData)) {
      functionImportsData = functionImportsData ? [functionImportsData] : [];
    }

    return functionImportsData.map((funcImport) => ({
      name: funcImport['@_Name'],
      returnType: funcImport['@_ReturnType'],
      entitySet: funcImport['@_EntitySet'],
      httpMethod: funcImport['@_HttpMethod'] || 'GET',
      parameters: this.parseFunctionParameters(funcImport.Parameter || []),
    }));
  }

  private parseFunctionParameters(parametersData: any[]): any[] {
    if (!Array.isArray(parametersData)) {
      parametersData = parametersData ? [parametersData] : [];
    }

    return parametersData.map((param) => ({
      name: param['@_Name'],
      type: param['@_Type'],
      mode: this.parseParameterMode(param['@_Mode']),
      nullable: param['@_Nullable'] !== 'false',
    }));
  }

  private parseParameterMode(mode: string): ParameterMode {
    switch (mode) {
      case 'In':
        return ParameterMode.IN;
      case 'Out':
        return ParameterMode.OUT;
      case 'InOut':
        return ParameterMode.INOUT;
      default:
        return ParameterMode.IN;
    }
  }

  private parseAnnotations(annotationsData: any[]): any[] {
    if (!Array.isArray(annotationsData)) {
      annotationsData = annotationsData ? [annotationsData] : [];
    }

    return annotationsData.map((annotation) => ({
      term: annotation['@_Term'],
      qualifier: annotation['@_Qualifier'],
      value: annotation['@_Value'] || annotation['#text'],
      target: annotation['@_Target'],
    }));
  }

  async validate(schema: SAPODataSchema): Promise<SAPValidationResult> {
    const errors: SAPValidationError[] = [];
    const warnings: SAPValidationError[] = [];

    // EntityContainer 검증
    if (!schema.content.entityContainer) {
      errors.push({
        rule: 'ENTITY_CONTAINER_REQUIRED',
        message: 'EntityContainer가 필요합니다.',
        severity: 'error',
      });
    }

    // EntityType 검증
    for (const entityType of schema.content.entityTypes) {
      if (!entityType.key || entityType.key.propertyRefs.length === 0) {
        warnings.push({
          rule: 'ENTITY_KEY_MISSING',
          message: `EntityType '${entityType.name}'에 키가 정의되지 않았습니다.`,
          element: entityType.name,
          severity: 'warning',
        });
      }
    }

    // EntitySet과 EntityType 매핑 검증
    for (const entitySet of schema.content.entitySets) {
      const entityType = schema.content.entityTypes.find(
        (et) => `${schema.metadata.namespace}.${et.name}` === entitySet.entityType
      );
      
      if (!entityType) {
        errors.push({
          rule: 'ENTITY_TYPE_NOT_FOUND',
          message: `EntitySet '${entitySet.name}'이 참조하는 EntityType '${entitySet.entityType}'을 찾을 수 없습니다.`,
          element: entitySet.name,
          severity: 'error',
        });
      }
    }

    // Association 검증
    for (const association of schema.content.associations) {
      if (association.ends.length !== 2) {
        errors.push({
          rule: 'ASSOCIATION_ENDS_INVALID',
          message: `Association '${association.name}'은 정확히 2개의 End를 가져야 합니다.`,
          element: association.name,
          severity: 'error',
        });
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings: warnings.filter(w => w.severity === 'warning') as SAPValidationWarning[],
      summary: {
        totalRules: 4,
        passedRules: 4 - errors.length - warnings.length,
        failedRules: errors.length,
        warningRules: warnings.length,
      },
    };
  }

  getMetadata(schema: SAPODataSchema): SAPMetadata {
    return {
      version: schema.version,
      namespace: schema.metadata.namespace,
      createdAt: schema.createdAt,
      parsedAt: new Date(),
    };
  }

  private generateId(): string {
    return `odata_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private countElements(content: SAPODataContent): number {
    return (
      content.entityTypes.length +
      content.complexTypes.length +
      content.associations.length +
      content.entitySets.length +
      content.functionImports.length
    );
  }
}