// SAP IDoc 구조 파싱 어댑터
import { XMLParser } from 'fast-xml-parser';
import {
  SAPIDocSchema,
  SAPIDocContent,
  IDocSegment,
  IDocField,
  SegmentHierarchy,
  ControlRecord,
  DataRecord,
  SegmentStatus,
} from '@eai/shared/types/sap';
import { SchemaType } from '@eai/shared/types';
import {
  SAPAdapter,
  SAPParseOptions,
  SAPParseResult,
  SAPValidationResult,
  SAPMetadata,
  SAPParseError,
  SAPParseWarning,
  SAPValidationError,
  SAPValidationWarning,
} from '../types';

export class IDocAdapter implements SAPAdapter<SAPIDocSchema> {
  private xmlParser: XMLParser;

  constructor() {
    this.xmlParser = new XMLParser({
      ignoreAttributes: false,
      attributeNamePrefix: '@_',
      textNodeName: '#text',
      parseAttributeValue: true,
      trimValues: true,
      parseTagValue: false,
    });
  }

  async parse(
    content: string,
    options: SAPParseOptions = {}
  ): Promise<SAPParseResult<SAPIDocSchema>> {
    const startTime = Date.now();
    const errors: SAPParseError[] = [];
    const warnings: SAPParseError[] = [];

    try {
      // IDoc 형식 감지 (XML 또는 플랫 파일)
      const isXML = content.trim().startsWith('<');
      
      let parsedContent: SAPIDocContent;
      
      if (isXML) {
        parsedContent = await this.parseXMLIDoc(content, options);
      } else {
        parsedContent = await this.parseFlatFileIDoc(content, options);
      }

      const metadata: SAPMetadata = {
        version: '1.0',
        createdAt: new Date(),
        parsedAt: new Date(),
      };

      const processingTime = Date.now() - startTime;

      const result: SAPIDocSchema = {
        id: this.generateId(),
        name: parsedContent.idocType,
        version: parsedContent.release,
        type: SchemaType.SAP_IDOC,
        originalFormat: isXML ? 'XML' : 'FLAT',
        metadata: {
          namespace: `SAP.IDoc.${parsedContent.idocType}`,
          targetNamespace: `SAP.IDoc.${parsedContent.idocType}`,
          imports: [],
          annotations: [],
        },
        content: parsedContent,
        createdAt: metadata.createdAt,
        updatedAt: metadata.parsedAt,
      };

      return {
        schema: result,
        metadata,
        errors,
        warnings: warnings.filter(w => w.severity === 'warning') as SAPParseWarning[],
        statistics: {
          totalElements: this.countElements(parsedContent),
          parsedElements: this.countElements(parsedContent) - errors.length,
          errorCount: errors.length,
          warningCount: warnings.length,
          processingTime,
        },
      };
    } catch (error) {
      errors.push({
        code: 'IDOC_PARSE_ERROR',
        message: error instanceof Error ? error.message : '알 수 없는 IDoc 파싱 오류',
        severity: 'error',
      });

      throw error;
    }
  }

  private async parseXMLIDoc(
    content: string,
    options: SAPParseOptions
  ): Promise<SAPIDocContent> {
    const xmlData = this.xmlParser.parse(content);
    
    // IDoc 루트 요소 찾기
    const idocRoot = xmlData.IDOC || xmlData.idoc || xmlData.IDoc;
    if (!idocRoot) {
      throw new Error('유효하지 않은 IDoc XML: 루트 요소를 찾을 수 없습니다.');
    }

    // 컨트롤 레코드 파싱
    const controlRecord = this.parseControlRecord(idocRoot.EDI_DC40 || idocRoot.EDI_DC);
    
    // 데이터 레코드 파싱
    const dataRecords = this.parseDataRecords(idocRoot);
    
    // 세그먼트 구조 파싱
    const segments = await this.parseSegments(idocRoot, options);
    
    // 계층 구조 생성
    const hierarchy = this.buildHierarchy(segments);

    return {
      idocType: controlRecord.idoctyp,
      release: controlRecord.docrel,
      segments,
      hierarchy,
      controlRecord,
      dataRecords,
    };
  }

  private async parseFlatFileIDoc(
    content: string,
    options: SAPParseOptions
  ): Promise<SAPIDocContent> {
    const lines = content.split('\n').filter(line => line.trim());
    
    if (lines.length === 0) {
      throw new Error('빈 IDoc 파일입니다.');
    }

    // 첫 번째 라인은 컨트롤 레코드
    const controlLine = lines[0];
    const controlRecord = this.parseControlRecordFromFlat(controlLine);
    
    // 나머지 라인들은 데이터 레코드
    const dataRecords = lines.slice(1).map((line, index) => 
      this.parseDataRecordFromFlat(line, index + 2)
    );

    // 세그먼트 구조 추출
    const segments = await this.extractSegmentsFromDataRecords(dataRecords, options);
    
    // 계층 구조 생성
    const hierarchy = this.buildHierarchy(segments);

    return {
      idocType: controlRecord.idoctyp,
      release: controlRecord.docrel,
      segments,
      hierarchy,
      controlRecord,
      dataRecords,
    };
  }

  private parseControlRecord(controlData: any): ControlRecord {
    return {
      tabnam: controlData['@_TABNAM'] || controlData.TABNAM || 'EDI_DC40',
      mandt: controlData['@_MANDT'] || controlData.MANDT || '',
      docnum: controlData['@_DOCNUM'] || controlData.DOCNUM || '',
      docrel: controlData['@_DOCREL'] || controlData.DOCREL || '',
      status: controlData['@_STATUS'] || controlData.STATUS || '',
      direct: controlData['@_DIRECT'] || controlData.DIRECT || '',
      outmod: controlData['@_OUTMOD'] || controlData.OUTMOD || '',
      idoctyp: controlData['@_IDOCTYP'] || controlData.IDOCTYP || '',
      mestyp: controlData['@_MESTYP'] || controlData.MESTYP || '',
      sndpor: controlData['@_SNDPOR'] || controlData.SNDPOR || '',
      sndprt: controlData['@_SNDPRT'] || controlData.SNDPRT || '',
      sndprn: controlData['@_SNDPRN'] || controlData.SNDPRN || '',
      rcvpor: controlData['@_RCVPOR'] || controlData.RCVPOR || '',
      rcvprt: controlData['@_RCVPRT'] || controlData.RCVPRT || '',
      rcvprn: controlData['@_RCVPRN'] || controlData.RCVPRN || '',
    };
  }

  private parseControlRecordFromFlat(line: string): ControlRecord {
    // IDoc 플랫 파일 형식: 고정 길이 필드
    // 예: EDI_DC40800000000000001...
    
    if (line.length < 100) {
      throw new Error('유효하지 않은 컨트롤 레코드 형식입니다.');
    }

    return {
      tabnam: line.substring(0, 10).trim(),
      mandt: line.substring(10, 13).trim(),
      docnum: line.substring(13, 29).trim(),
      docrel: line.substring(29, 33).trim(),
      status: line.substring(33, 35).trim(),
      direct: line.substring(35, 36).trim(),
      outmod: line.substring(36, 37).trim(),
      idoctyp: line.substring(37, 67).trim(),
      mestyp: line.substring(67, 97).trim(),
      sndpor: line.substring(97, 127).trim(),
      sndprt: line.substring(127, 129).trim(),
      sndprn: line.substring(129, 159).trim(),
      rcvpor: line.substring(159, 189).trim(),
      rcvprt: line.substring(189, 191).trim(),
      rcvprn: line.substring(191, 221).trim(),
    };
  }

  private parseDataRecords(idocRoot: any): DataRecord[] {
    const dataRecords: DataRecord[] = [];
    
    // XML에서 모든 세그먼트 데이터 추출
    this.extractDataRecordsRecursive(idocRoot, dataRecords);
    
    return dataRecords;
  }

  private extractDataRecordsRecursive(node: any, dataRecords: DataRecord[], level = 0): void {
    if (typeof node !== 'object' || node === null) return;

    for (const [key, value] of Object.entries(node)) {
      if (key.startsWith('@_') || key === '#text') continue;
      
      if (Array.isArray(value)) {
        value.forEach((item, index) => {
          if (typeof item === 'object' && item !== null) {
            dataRecords.push({
              segnam: key,
              mandt: '',
              docnum: '',
              segnum: (dataRecords.length + 1).toString().padStart(6, '0'),
              psgnum: '000000',
              hlevel: level.toString().padStart(2, '0'),
              sdata: JSON.stringify(item),
            });
            
            this.extractDataRecordsRecursive(item, dataRecords, level + 1);
          }
        });
      } else if (typeof value === 'object' && value !== null) {
        dataRecords.push({
          segnam: key,
          mandt: '',
          docnum: '',
          segnum: (dataRecords.length + 1).toString().padStart(6, '0'),
          psgnum: '000000',
          hlevel: level.toString().padStart(2, '0'),
          sdata: JSON.stringify(value),
        });
        
        this.extractDataRecordsRecursive(value, dataRecords, level + 1);
      }
    }
  }

  private parseDataRecordFromFlat(line: string, lineNumber: number): DataRecord {
    if (line.length < 60) {
      throw new Error(`라인 ${lineNumber}: 유효하지 않은 데이터 레코드 형식입니다.`);
    }

    return {
      segnam: line.substring(0, 27).trim(),
      mandt: line.substring(27, 30).trim(),
      docnum: line.substring(30, 46).trim(),
      segnum: line.substring(46, 52).trim(),
      psgnum: line.substring(52, 58).trim(),
      hlevel: line.substring(58, 60).trim(),
      sdata: line.substring(60).trim(),
    };
  }

  private async parseSegments(
    idocRoot: any,
    options: SAPParseOptions
  ): Promise<IDocSegment[]> {
    const segments: IDocSegment[] = [];
    
    // 세그먼트 정의 추출 (실제 구현에서는 SAP 시스템에서 메타데이터를 가져와야 함)
    await this.extractSegmentsRecursive(idocRoot, segments, 0);
    
    return segments;
  }

  private async extractSegmentsRecursive(
    node: any,
    segments: IDocSegment[],
    level: number,
    parent?: string
  ): Promise<void> {
    if (typeof node !== 'object' || node === null) return;

    for (const [key, value] of Object.entries(node)) {
      if (key.startsWith('@_') || key === '#text') continue;
      
      // 세그먼트로 간주되는 키 (대문자로 시작하고 특정 패턴)
      if (this.isSegmentKey(key)) {
        const segment: IDocSegment = {
          name: key,
          definition: `세그먼트 ${key}`,
          level,
          status: this.determineSegmentStatus(key),
          fields: await this.extractFieldsFromSegment(value),
          children: [],
          parent,
          minOccurs: 0,
          maxOccurs: Array.isArray(value) ? value.length : 1,
        };

        segments.push(segment);

        // 자식 세그먼트 처리
        if (Array.isArray(value)) {
          for (const item of value) {
            await this.extractSegmentsRecursive(item, segments, level + 1, key);
          }
        } else {
          await this.extractSegmentsRecursive(value, segments, level + 1, key);
        }
      }
    }
  }

  private async extractSegmentsFromDataRecords(
    dataRecords: DataRecord[],
    options: SAPParseOptions
  ): Promise<IDocSegment[]> {
    const segmentMap = new Map<string, IDocSegment>();
    
    for (const record of dataRecords) {
      if (!segmentMap.has(record.segnam)) {
        const segment: IDocSegment = {
          name: record.segnam,
          definition: `세그먼트 ${record.segnam}`,
          level: parseInt(record.hlevel),
          status: this.determineSegmentStatus(record.segnam),
          fields: await this.extractFieldsFromData(record.sdata),
          children: [],
          minOccurs: 0,
          maxOccurs: 1,
        };
        
        segmentMap.set(record.segnam, segment);
      }
    }
    
    return Array.from(segmentMap.values());
  }

  private isSegmentKey(key: string): boolean {
    // SAP IDoc 세그먼트 명명 규칙
    return /^[A-Z][A-Z0-9_]{2,}$/.test(key) && key !== 'EDI_DC40' && key !== 'EDI_DC';
  }

  private determineSegmentStatus(segmentName: string): SegmentStatus {
    // 실제 구현에서는 SAP 메타데이터에서 가져와야 함
    // 여기서는 기본값으로 설정
    if (segmentName.includes('HDR') || segmentName.includes('HEADER')) {
      return SegmentStatus.MANDATORY;
    } else if (segmentName.includes('ITM') || segmentName.includes('ITEM')) {
      return SegmentStatus.CONDITIONAL;
    }
    return SegmentStatus.OPTIONAL;
  }

  private async extractFieldsFromSegment(segmentData: any): Promise<IDocField[]> {
    const fields: IDocField[] = [];
    
    if (typeof segmentData !== 'object' || segmentData === null) {
      return fields;
    }

    let position = 1;
    for (const [key, value] of Object.entries(segmentData)) {
      if (key.startsWith('@_') || key === '#text') continue;
      
      fields.push({
        name: key,
        dataElement: key.toUpperCase(),
        dataType: this.inferDataType(value),
        length: this.inferLength(value),
        position: position++,
        description: `필드 ${key}`,
        constraints: [],
      });
    }
    
    return fields;
  }

  private async extractFieldsFromData(sdata: string): Promise<IDocField[]> {
    try {
      const data = JSON.parse(sdata);
      return this.extractFieldsFromSegment(data);
    } catch {
      // JSON 파싱 실패 시 플랫 데이터로 처리
      return [{
        name: 'DATA',
        dataElement: 'CHAR',
        dataType: 'CHAR',
        length: sdata.length,
        position: 1,
        description: '세그먼트 데이터',
        constraints: [],
      }];
    }
  }

  private inferDataType(value: any): string {
    if (typeof value === 'number') {
      return Number.isInteger(value) ? 'INT' : 'DEC';
    } else if (typeof value === 'boolean') {
      return 'CHAR';
    } else if (typeof value === 'string') {
      // 날짜 형식 확인
      if (/^\d{4}-\d{2}-\d{2}/.test(value)) {
        return 'DATS';
      } else if (/^\d{2}:\d{2}:\d{2}/.test(value)) {
        return 'TIMS';
      }
      return 'CHAR';
    }
    return 'CHAR';
  }

  private inferLength(value: any): number {
    if (typeof value === 'string') {
      return value.length || 1;
    } else if (typeof value === 'number') {
      return value.toString().length;
    }
    return 1;
  }

  private buildHierarchy(segments: IDocSegment[]): SegmentHierarchy {
    const levelMap = new Map<number, string[]>();
    let rootSegment = '';

    for (const segment of segments) {
      if (!levelMap.has(segment.level)) {
        levelMap.set(segment.level, []);
      }
      levelMap.get(segment.level)!.push(segment.name);
      
      if (segment.level === 0 || (segment.level === 1 && !rootSegment)) {
        rootSegment = segment.name;
      }
    }

    const levels = Array.from(levelMap.entries())
      .sort(([a], [b]) => a - b)
      .map(([level, segmentNames]) => ({
        level,
        segments: segmentNames,
      }));

    return {
      root: rootSegment,
      levels,
    };
  }

  async validate(schema: SAPIDocSchema): Promise<SAPValidationResult> {
    const errors: SAPValidationError[] = [];
    const warnings: SAPValidationError[] = [];

    // IDoc 타입 검증
    if (!schema.content.idocType) {
      errors.push({
        rule: 'IDOC_TYPE_REQUIRED',
        message: 'IDoc 타입이 필요합니다.',
        severity: 'error',
      });
    }

    // 컨트롤 레코드 검증
    if (!schema.content.controlRecord.docnum) {
      warnings.push({
        rule: 'DOCUMENT_NUMBER_MISSING',
        message: '문서 번호가 누락되었습니다.',
        severity: 'warning',
      });
    }

    // 세그먼트 계층 구조 검증
    if (!schema.content.hierarchy.root) {
      errors.push({
        rule: 'ROOT_SEGMENT_MISSING',
        message: '루트 세그먼트가 정의되지 않았습니다.',
        severity: 'error',
      });
    }

    // 필수 세그먼트 검증
    const mandatorySegments = schema.content.segments.filter(
      s => s.status === SegmentStatus.MANDATORY
    );
    
    if (mandatorySegments.length === 0) {
      warnings.push({
        rule: 'NO_MANDATORY_SEGMENTS',
        message: '필수 세그먼트가 정의되지 않았습니다.',
        severity: 'warning',
      });
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings: warnings.filter(w => w.severity === 'warning') as SAPValidationWarning[],
      summary: {
        totalRules: 4,
        passedRules: 4 - errors.length - warnings.length,
        failedRules: errors.length,
        warningRules: warnings.length,
      },
    };
  }

  getMetadata(schema: SAPIDocSchema): SAPMetadata {
    return {
      version: schema.version,
      namespace: schema.metadata.namespace,
      systemInfo: {
        release: schema.content.release,
        version: schema.version,
      },
      createdAt: schema.createdAt,
      parsedAt: new Date(),
    };
  }

  private generateId(): string {
    return `idoc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private countElements(content: SAPIDocContent): number {
    return content.segments.length + content.dataRecords.length;
  }
}