// SAP 검증기 단위 테스트
import { describe, it, expect, beforeEach } from '@jest/globals';
import { SAPValidator } from '../../validators/sap-validator';
import { 
  SchemaType, 
  SegmentStatus, 
  RFCParameterType,
  Multiplicity 
} from '@eai/shared/types/sap';

describe('SAPValidator', () => {
  let validator: SAPValidator;

  beforeEach(() => {
    validator = new SAPValidator();
  });

  describe('validateODataSchema', () => {
    it('should validate valid OData schema', async () => {
      const schema = {
        id: 'test',
        name: 'TestService',
        version: '1.0',
        type: SchemaType.SAP_ODATA,
        originalFormat: 'EDMX',
        metadata: {
          namespace: 'TestService',
          targetNamespace: 'TestService',
          imports: [],
          annotations: [],
        },
        content: {
          entityTypes: [{
            name: 'Product',
            key: { propertyRefs: [{ name: 'ProductID' }] },
            properties: [
              { name: 'ProductID', type: 'Edm.Int32', nullable: false, constraints: [] },
              { name: 'ProductName', type: 'Edm.String', nullable: true, constraints: [] }
            ],
            navigationProperties: [],
            annotations: [],
          }],
          entitySets: [{
            name: 'Products',
            entityType: 'TestService.Product',
            annotations: [],
          }],
          complexTypes: [],
          associations: [],
          functionImports: [],
          entityContainer: {
            name: 'TestContainer',
            isDefaultEntityContainer: true,
            entitySets: [{
              name: 'Products',
              entityType: 'TestService.Product',
              annotations: [],
            }],
            functionImports: [],
          },
        },
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const result = await validator.validateODataSchema(schema);

      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should detect invalid association ends', async () => {
      const schema = {
        id: 'test',
        name: 'TestService',
        version: '1.0',
        type: SchemaType.SAP_ODATA,
        originalFormat: 'EDMX',
        metadata: {
          namespace: 'TestService',
          targetNamespace: 'TestService',
          imports: [],
          annotations: [],
        },
        content: {
          entityTypes: [],
          entitySets: [],
          complexTypes: [],
          associations: [{
            name: 'InvalidAssociation',
            ends: [{ // 하나의 End만 있음 (2개여야 함)
              role: 'Product',
              type: 'TestService.Product',
              multiplicity: Multiplicity.ONE,
            }],
          }],
          functionImports: [],
          entityContainer: {
            name: 'TestContainer',
            isDefaultEntityContainer: true,
            entitySets: [],
            functionImports: [],
          },
        },
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const result = await validator.validateODataSchema(schema);

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.rule === 'ASSOCIATION_INVALID_ENDS')).toBe(true);
    });
  });

  describe('validateIDocSchema', () => {
    it('should validate valid IDoc schema', async () => {
      const schema = {
        id: 'test',
        name: 'ORDERS05',
        version: '700',
        type: SchemaType.SAP_IDOC,
        originalFormat: 'XML',
        metadata: {
          namespace: 'SAP.IDoc.ORDERS05',
          targetNamespace: 'SAP.IDoc.ORDERS05',
          imports: [],
          annotations: [],
        },
        content: {
          idocType: 'ORDERS05',
          release: '700',
          segments: [{
            name: 'E1EDK01',
            definition: '세그먼트 E1EDK01',
            level: 1,
            status: SegmentStatus.MANDATORY,
            fields: [{
              name: 'BELNR',
              dataElement: 'BELNR',
              dataType: 'CHAR',
              length: 35,
              position: 1,
              description: '문서 번호',
              constraints: [],
            }],
            children: [],
            minOccurs: 1,
            maxOccurs: 1,
          }],
          hierarchy: {
            root: 'E1EDK01',
            levels: [{
              level: 1,
              segments: ['E1EDK01'],
            }],
          },
          controlRecord: {
            tabnam: 'EDI_DC40',
            mandt: '100',
            docnum: '0000000001',
            docrel: '700',
            status: '30',
            direct: '2',
            outmod: '2',
            idoctyp: 'ORDERS05',
            mestyp: 'ORDERS',
            sndpor: 'SAPCLNT100',
            sndprt: 'LS',
            sndprn: 'CLNT100',
            rcvpor: 'PARTNER',
            rcvprt: 'LS',
            rcvprn: 'PARTNER',
          },
          dataRecords: [],
        },
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const result = await validator.validateIDocSchema(schema);

      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should detect duplicate field positions', async () => {
      const schema = {
        id: 'test',
        name: 'ORDERS05',
        version: '700',
        type: SchemaType.SAP_IDOC,
        originalFormat: 'XML',
        metadata: {
          namespace: 'SAP.IDoc.ORDERS05',
          targetNamespace: 'SAP.IDoc.ORDERS05',
          imports: [],
          annotations: [],
        },
        content: {
          idocType: 'ORDERS05',
          release: '700',
          segments: [{
            name: 'E1EDK01',
            definition: '세그먼트 E1EDK01',
            level: 1,
            status: SegmentStatus.MANDATORY,
            fields: [
              {
                name: 'FIELD1',
                dataElement: 'FIELD1',
                dataType: 'CHAR',
                length: 10,
                position: 1, // 중복된 위치
                description: '필드 1',
                constraints: [],
              },
              {
                name: 'FIELD2',
                dataElement: 'FIELD2',
                dataType: 'CHAR',
                length: 10,
                position: 1, // 중복된 위치
                description: '필드 2',
                constraints: [],
              },
            ],
            children: [],
            minOccurs: 1,
            maxOccurs: 1,
          }],
          hierarchy: {
            root: 'E1EDK01',
            levels: [{
              level: 1,
              segments: ['E1EDK01'],
            }],
          },
          controlRecord: {
            tabnam: 'EDI_DC40',
            mandt: '100',
            docnum: '0000000001',
            docrel: '700',
            status: '30',
            direct: '2',
            outmod: '2',
            idoctyp: 'ORDERS05',
            mestyp: 'ORDERS',
            sndpor: 'SAPCLNT100',
            sndprt: 'LS',
            sndprn: 'CLNT100',
            rcvpor: 'PARTNER',
            rcvprt: 'LS',
            rcvprn: 'PARTNER',
          },
          dataRecords: [],
        },
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const result = await validator.validateIDocSchema(schema);

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.rule === 'DUPLICATE_FIELD_POSITION')).toBe(true);
    });
  });

  describe('validateRFCSchema', () => {
    it('should validate valid RFC schema', async () => {
      const schema = {
        id: 'test',
        name: 'BAPI_CUSTOMER_GETLIST',
        version: '1.0',
        type: SchemaType.SAP_RFC,
        originalFormat: 'JSON',
        metadata: {
          namespace: 'SAP.RFC.BAPI_CUSTOMER_GETLIST',
          targetNamespace: 'SAP.RFC.BAPI_CUSTOMER_GETLIST',
          imports: [],
          annotations: [],
        },
        content: {
          functionName: 'BAPI_CUSTOMER_GETLIST',
          functionGroup: 'BUS1006',
          shortText: 'Get Customer List',
          importing: [{
            name: 'MAXROWS',
            type: RFCParameterType.ELEMENTARY,
            dataType: 'INT4',
            optional: true,
            description: 'Maximum number of rows',
          }],
          exporting: [{
            name: 'RETURN',
            type: RFCParameterType.STRUCTURE,
            dataType: 'BAPIRET2',
            optional: false,
            description: 'Return parameter',
          }],
          changing: [],
          tables: [{
            name: 'CUSTOMERLIST',
            type: 'BAPICUSTOMER',
            description: 'Customer list table',
            optional: false,
            structure: {
              name: 'BAPICUSTOMER',
              fields: [{
                name: 'CUSTOMER',
                dataType: 'CHAR',
                length: 10,
                description: 'Customer number',
                offset: 0,
              }],
            },
          }],
          exceptions: [{
            name: 'NOT_FOUND',
            description: 'Customer not found',
          }],
          documentation: {
            shortText: 'Get Customer List',
            longText: '',
            parameters: [],
            exceptions: [],
          },
        },
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const result = await validator.validateRFCSchema(schema);

      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should detect performance issues with too many parameters', async () => {
      const manyParams = Array.from({ length: 60 }, (_, i) => ({
        name: `PARAM_${i}`,
        type: RFCParameterType.ELEMENTARY,
        dataType: 'CHAR',
        optional: false,
        description: `Parameter ${i}`,
      }));

      const schema = {
        id: 'test',
        name: 'FUNCTION_WITH_MANY_PARAMS',
        version: '1.0',
        type: SchemaType.SAP_RFC,
        originalFormat: 'JSON',
        metadata: {
          namespace: 'SAP.RFC.FUNCTION_WITH_MANY_PARAMS',
          targetNamespace: 'SAP.RFC.FUNCTION_WITH_MANY_PARAMS',
          imports: [],
          annotations: [],
        },
        content: {
          functionName: 'FUNCTION_WITH_MANY_PARAMS',
          functionGroup: 'TEST',
          shortText: 'Function with many parameters',
          importing: manyParams,
          exporting: [],
          changing: [],
          tables: [],
          exceptions: [],
          documentation: {
            shortText: 'Function with many parameters',
            longText: '',
            parameters: [],
            exceptions: [],
          },
        },
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const result = await validator.validateRFCSchema(schema);

      expect(result.warnings.some(w => w.rule === 'TOO_MANY_PARAMETERS')).toBe(true);
    });
  });
});