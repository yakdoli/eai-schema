import { ParseError } from '../types';

/**
 * 파싱 에러 처리기
 * 다양한 종류의 파싱 에러를 표준화된 형태로 변환하고 관리합니다.
 */
export class ErrorHandler {

  /**
   * 일반적인 Error 객체를 ParseError로 변환합니다.
   * @param error Error 객체
   * @param context 추가 컨텍스트 정보
   * @returns ParseError 객체
   */
  createParseError(error: Error, context?: {
    line?: number;
    column?: number;
    path?: string;
    code?: string;
  }): ParseError {
    return {
      code: context?.code || 'PARSE_ERROR',
      message: error.message,
      line: context?.line,
      column: context?.column,
      path: context?.path,
      severity: 'error'
    };
  }

  /**
   * XML 구문 에러를 ParseError로 변환합니다.
   * @param message 에러 메시지
   * @param line 라인 번호
   * @param column 컬럼 번호
   * @returns ParseError 객체
   */
  createXMLSyntaxError(message: string, line?: number, column?: number): ParseError {
    return {
      code: 'XML_SYNTAX_ERROR',
      message: `XML 구문 에러: ${message}`,
      line,
      column,
      severity: 'error'
    };
  }

  /**
   * XSD 스키마 에러를 ParseError로 변환합니다.
   * @param message 에러 메시지
   * @param elementPath 요소 경로
   * @returns ParseError 객체
   */
  createXSDSchemaError(message: string, elementPath?: string): ParseError {
    return {
      code: 'XSD_SCHEMA_ERROR',
      message: `XSD 스키마 에러: ${message}`,
      path: elementPath,
      severity: 'error'
    };
  }

  /**
   * 네임스페이스 에러를 ParseError로 변환합니다.
   * @param message 에러 메시지
   * @param namespace 문제가 된 네임스페이스
   * @returns ParseError 객체
   */
  createNamespaceError(message: string, namespace?: string): ParseError {
    return {
      code: 'NAMESPACE_ERROR',
      message: `네임스페이스 에러: ${message}${namespace ? ` (${namespace})` : ''}`,
      severity: 'error'
    };
  }

  /**
   * 타입 정의 에러를 ParseError로 변환합니다.
   * @param message 에러 메시지
   * @param typeName 타입 이름
   * @returns ParseError 객체
   */
  createTypeDefinitionError(message: string, typeName?: string): ParseError {
    return {
      code: 'TYPE_DEFINITION_ERROR',
      message: `타입 정의 에러: ${message}${typeName ? ` (타입: ${typeName})` : ''}`,
      severity: 'error'
    };
  }

  /**
   * 참조 해결 에러를 ParseError로 변환합니다.
   * @param message 에러 메시지
   * @param reference 참조 정보
   * @returns ParseError 객체
   */
  createReferenceError(message: string, reference?: string): ParseError {
    return {
      code: 'REFERENCE_ERROR',
      message: `참조 해결 에러: ${message}${reference ? ` (참조: ${reference})` : ''}`,
      severity: 'error'
    };
  }

  /**
   * 경고를 ParseError로 생성합니다.
   * @param message 경고 메시지
   * @param code 경고 코드
   * @param context 추가 컨텍스트
   * @returns ParseError 객체 (severity: 'warning')
   */
  createWarning(message: string, code: string = 'PARSE_WARNING', context?: {
    line?: number;
    column?: number;
    path?: string;
  }): ParseError {
    return {
      code,
      message,
      line: context?.line,
      column: context?.column,
      path: context?.path,
      severity: 'warning'
    };
  }

  /**
   * 정보성 메시지를 ParseError로 생성합니다.
   * @param message 정보 메시지
   * @param code 정보 코드
   * @param context 추가 컨텍스트
   * @returns ParseError 객체 (severity: 'info')
   */
  createInfo(message: string, code: string = 'PARSE_INFO', context?: {
    line?: number;
    column?: number;
    path?: string;
  }): ParseError {
    return {
      code,
      message,
      line: context?.line,
      column: context?.column,
      path: context?.path,
      severity: 'info'
    };
  }

  /**
   * 에러 목록을 심각도별로 분류합니다.
   * @param errors 에러 목록
   * @returns 심각도별로 분류된 에러
   */
  categorizeErrors(errors: ParseError[]): {
    errors: ParseError[];
    warnings: ParseError[];
    infos: ParseError[];
  } {
    return {
      errors: errors.filter(e => e.severity === 'error'),
      warnings: errors.filter(e => e.severity === 'warning'),
      infos: errors.filter(e => e.severity === 'info')
    };
  }

  /**
   * 에러 목록을 코드별로 그룹화합니다.
   * @param errors 에러 목록
   * @returns 코드별로 그룹화된 에러
   */
  groupErrorsByCode(errors: ParseError[]): Map<string, ParseError[]> {
    const grouped = new Map<string, ParseError[]>();
    
    for (const error of errors) {
      if (!grouped.has(error.code)) {
        grouped.set(error.code, []);
      }
      grouped.get(error.code)!.push(error);
    }
    
    return grouped;
  }

  /**
   * 에러 요약 정보를 생성합니다.
   * @param errors 에러 목록
   * @returns 에러 요약
   */
  createErrorSummary(errors: ParseError[]): {
    total: number;
    errorCount: number;
    warningCount: number;
    infoCount: number;
    codeBreakdown: Record<string, number>;
  } {
    const categorized = this.categorizeErrors(errors);
    const codeBreakdown: Record<string, number> = {};
    
    for (const error of errors) {
      codeBreakdown[error.code] = (codeBreakdown[error.code] || 0) + 1;
    }
    
    return {
      total: errors.length,
      errorCount: categorized.errors.length,
      warningCount: categorized.warnings.length,
      infoCount: categorized.infos.length,
      codeBreakdown
    };
  }

  /**
   * 에러를 사용자 친화적인 메시지로 변환합니다.
   * @param error ParseError 객체
   * @returns 사용자 친화적인 메시지
   */
  formatUserFriendlyMessage(error: ParseError): string {
    const location = this.formatLocation(error);
    const severity = this.formatSeverity(error.severity);
    
    return `${severity}${location}: ${error.message}`;
  }

  /**
   * 위치 정보를 포맷합니다.
   * @param error ParseError 객체
   * @returns 포맷된 위치 정보
   */
  private formatLocation(error: ParseError): string {
    const parts: string[] = [];
    
    if (error.path) {
      parts.push(`경로: ${error.path}`);
    }
    
    if (error.line !== undefined) {
      parts.push(`라인: ${error.line}`);
      
      if (error.column !== undefined) {
        parts.push(`컬럼: ${error.column}`);
      }
    }
    
    return parts.length > 0 ? ` (${parts.join(', ')})` : '';
  }

  /**
   * 심각도를 한국어로 포맷합니다.
   * @param severity 심각도
   * @returns 한국어 심각도
   */
  private formatSeverity(severity: 'error' | 'warning' | 'info'): string {
    switch (severity) {
      case 'error':
        return '에러';
      case 'warning':
        return '경고';
      case 'info':
        return '정보';
      default:
        return '알 수 없음';
    }
  }

  /**
   * 파싱 에러를 처리하고 표준화된 에러를 반환합니다.
   * @param error 원본 에러
   * @param parserType 파서 타입
   * @returns 표준화된 에러
   */
  handleParsingError(error: any, parserType: string): Error {
    if (error instanceof Error) {
      return new Error(`${parserType} 파싱 에러: ${error.message}`);
    }
    
    return new Error(`${parserType} 파싱 중 알 수 없는 에러가 발생했습니다: ${String(error)}`);
  }

  /**
   * 에러 목록을 콘솔에 출력합니다 (디버깅용).
   * @param errors 에러 목록
   * @param title 제목
   */
  logErrors(errors: ParseError[], title: string = '파싱 결과'): void {
    if (errors.length === 0) {
      console.log(`${title}: 에러 없음`);
      return;
    }

    console.log(`\n=== ${title} ===`);
    const summary = this.createErrorSummary(errors);
    
    console.log(`총 ${summary.total}개 (에러: ${summary.errorCount}, 경고: ${summary.warningCount}, 정보: ${summary.infoCount})`);
    
    const categorized = this.categorizeErrors(errors);
    
    if (categorized.errors.length > 0) {
      console.log('\n[에러]');
      categorized.errors.forEach(error => {
        console.log(`  ${this.formatUserFriendlyMessage(error)}`);
      });
    }
    
    if (categorized.warnings.length > 0) {
      console.log('\n[경고]');
      categorized.warnings.forEach(warning => {
        console.log(`  ${this.formatUserFriendlyMessage(warning)}`);
      });
    }
    
    if (categorized.infos.length > 0) {
      console.log('\n[정보]');
      categorized.infos.forEach(info => {
        console.log(`  ${this.formatUserFriendlyMessage(info)}`);
      });
    }
  }
}