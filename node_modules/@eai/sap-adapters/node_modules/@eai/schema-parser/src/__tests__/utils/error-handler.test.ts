import { ErrorHandler } from '../../utils/error-handler';
import { ParseError } from '../../types';

describe('ErrorHandler', () => {
  let errorHandler: ErrorHandler;

  beforeEach(() => {
    errorHandler = new ErrorHandler();
  });

  describe('에러 생성', () => {
    it('일반 Error를 ParseError로 변환해야 함', () => {
      const error = new Error('테스트 에러');
      const parseError = errorHandler.createParseError(error);

      expect(parseError.code).toBe('PARSE_ERROR');
      expect(parseError.message).toBe('테스트 에러');
      expect(parseError.severity).toBe('error');
    });

    it('컨텍스트 정보와 함께 ParseError를 생성해야 함', () => {
      const error = new Error('테스트 에러');
      const context = {
        line: 10,
        column: 5,
        path: '/root/element',
        code: 'CUSTOM_ERROR'
      };

      const parseError = errorHandler.createParseError(error, context);

      expect(parseError.code).toBe('CUSTOM_ERROR');
      expect(parseError.message).toBe('테스트 에러');
      expect(parseError.line).toBe(10);
      expect(parseError.column).toBe(5);
      expect(parseError.path).toBe('/root/element');
      expect(parseError.severity).toBe('error');
    });

    it('XML 구문 에러를 생성해야 함', () => {
      const parseError = errorHandler.createXMLSyntaxError('잘못된 태그', 5, 10);

      expect(parseError.code).toBe('XML_SYNTAX_ERROR');
      expect(parseError.message).toBe('XML 구문 에러: 잘못된 태그');
      expect(parseError.line).toBe(5);
      expect(parseError.column).toBe(10);
      expect(parseError.severity).toBe('error');
    });

    it('XSD 스키마 에러를 생성해야 함', () => {
      const parseError = errorHandler.createXSDSchemaError('잘못된 타입 정의', '/schema/complexType');

      expect(parseError.code).toBe('XSD_SCHEMA_ERROR');
      expect(parseError.message).toBe('XSD 스키마 에러: 잘못된 타입 정의');
      expect(parseError.path).toBe('/schema/complexType');
      expect(parseError.severity).toBe('error');
    });

    it('네임스페이스 에러를 생성해야 함', () => {
      const parseError = errorHandler.createNamespaceError('알 수 없는 접두사', 'unknown');

      expect(parseError.code).toBe('NAMESPACE_ERROR');
      expect(parseError.message).toBe('네임스페이스 에러: 알 수 없는 접두사 (unknown)');
      expect(parseError.severity).toBe('error');
    });

    it('타입 정의 에러를 생성해야 함', () => {
      const parseError = errorHandler.createTypeDefinitionError('순환 참조 발견', 'PersonType');

      expect(parseError.code).toBe('TYPE_DEFINITION_ERROR');
      expect(parseError.message).toBe('타입 정의 에러: 순환 참조 발견 (타입: PersonType)');
      expect(parseError.severity).toBe('error');
    });

    it('참조 해결 에러를 생성해야 함', () => {
      const parseError = errorHandler.createReferenceError('참조를 찾을 수 없음', 'AddressType');

      expect(parseError.code).toBe('REFERENCE_ERROR');
      expect(parseError.message).toBe('참조 해결 에러: 참조를 찾을 수 없음 (참조: AddressType)');
      expect(parseError.severity).toBe('error');
    });

    it('경고를 생성해야 함', () => {
      const warning = errorHandler.createWarning('사용되지 않는 타입', 'UNUSED_TYPE', {
        line: 20,
        path: '/schema/complexType[@name="UnusedType"]'
      });

      expect(warning.code).toBe('UNUSED_TYPE');
      expect(warning.message).toBe('사용되지 않는 타입');
      expect(warning.line).toBe(20);
      expect(warning.path).toBe('/schema/complexType[@name="UnusedType"]');
      expect(warning.severity).toBe('warning');
    });

    it('정보성 메시지를 생성해야 함', () => {
      const info = errorHandler.createInfo('파싱 완료', 'PARSE_COMPLETE');

      expect(info.code).toBe('PARSE_COMPLETE');
      expect(info.message).toBe('파싱 완료');
      expect(info.severity).toBe('info');
    });
  });

  describe('에러 분류', () => {
    let errors: ParseError[];

    beforeEach(() => {
      errors = [
        { code: 'ERROR1', message: '에러1', severity: 'error' },
        { code: 'WARNING1', message: '경고1', severity: 'warning' },
        { code: 'ERROR2', message: '에러2', severity: 'error' },
        { code: 'INFO1', message: '정보1', severity: 'info' },
        { code: 'WARNING2', message: '경고2', severity: 'warning' }
      ];
    });

    it('에러를 심각도별로 분류해야 함', () => {
      const categorized = errorHandler.categorizeErrors(errors);

      expect(categorized.errors).toHaveLength(2);
      expect(categorized.warnings).toHaveLength(2);
      expect(categorized.infos).toHaveLength(1);

      expect(categorized.errors[0].code).toBe('ERROR1');
      expect(categorized.warnings[0].code).toBe('WARNING1');
      expect(categorized.infos[0].code).toBe('INFO1');
    });

    it('에러를 코드별로 그룹화해야 함', () => {
      const duplicateErrors: ParseError[] = [
        { code: 'XML_ERROR', message: '에러1', severity: 'error' },
        { code: 'XML_ERROR', message: '에러2', severity: 'error' },
        { code: 'TYPE_ERROR', message: '타입 에러', severity: 'error' }
      ];

      const grouped = errorHandler.groupErrorsByCode(duplicateErrors);

      expect(grouped.size).toBe(2);
      expect(grouped.get('XML_ERROR')).toHaveLength(2);
      expect(grouped.get('TYPE_ERROR')).toHaveLength(1);
    });

    it('에러 요약을 생성해야 함', () => {
      const summary = errorHandler.createErrorSummary(errors);

      expect(summary.total).toBe(5);
      expect(summary.errorCount).toBe(2);
      expect(summary.warningCount).toBe(2);
      expect(summary.infoCount).toBe(1);
      expect(summary.codeBreakdown['ERROR1']).toBe(1);
      expect(summary.codeBreakdown['WARNING1']).toBe(1);
    });
  });

  describe('메시지 포맷팅', () => {
    it('사용자 친화적인 메시지를 생성해야 함', () => {
      const error: ParseError = {
        code: 'XML_SYNTAX_ERROR',
        message: '잘못된 태그',
        line: 10,
        column: 5,
        path: '/root/element',
        severity: 'error'
      };

      const formatted = errorHandler.formatUserFriendlyMessage(error);

      expect(formatted).toContain('에러');
      expect(formatted).toContain('경로: /root/element');
      expect(formatted).toContain('라인: 10');
      expect(formatted).toContain('컬럼: 5');
      expect(formatted).toContain('잘못된 태그');
    });

    it('위치 정보가 없는 에러도 포맷팅해야 함', () => {
      const error: ParseError = {
        code: 'GENERAL_ERROR',
        message: '일반 에러',
        severity: 'error'
      };

      const formatted = errorHandler.formatUserFriendlyMessage(error);

      expect(formatted).toBe('에러: 일반 에러');
    });

    it('경고와 정보 메시지도 올바르게 포맷팅해야 함', () => {
      const warning: ParseError = {
        code: 'WARNING',
        message: '경고 메시지',
        severity: 'warning'
      };

      const info: ParseError = {
        code: 'INFO',
        message: '정보 메시지',
        severity: 'info'
      };

      expect(errorHandler.formatUserFriendlyMessage(warning)).toContain('경고');
      expect(errorHandler.formatUserFriendlyMessage(info)).toContain('정보');
    });
  });

  describe('에러 로깅', () => {
    let consoleSpy: jest.SpyInstance;

    beforeEach(() => {
      consoleSpy = jest.spyOn(console, 'log').mockImplementation();
    });

    afterEach(() => {
      consoleSpy.mockRestore();
    });

    it('에러가 없을 때 적절한 메시지를 출력해야 함', () => {
      errorHandler.logErrors([], '테스트 결과');

      expect(consoleSpy).toHaveBeenCalledWith('테스트 결과: 에러 없음');
    });

    it('에러가 있을 때 상세 정보를 출력해야 함', () => {
      const errors: ParseError[] = [
        { code: 'ERROR1', message: '에러1', severity: 'error' },
        { code: 'WARNING1', message: '경고1', severity: 'warning' }
      ];

      errorHandler.logErrors(errors, '테스트 결과');

      expect(consoleSpy).toHaveBeenCalledWith('\n=== 테스트 결과 ===');
      expect(consoleSpy).toHaveBeenCalledWith('총 2개 (에러: 1, 경고: 1, 정보: 0)');
      expect(consoleSpy).toHaveBeenCalledWith('\n[에러]');
      expect(consoleSpy).toHaveBeenCalledWith('\n[경고]');
    });

    it('기본 제목을 사용할 수 있어야 함', () => {
      const errors: ParseError[] = [
        { code: 'ERROR1', message: '에러1', severity: 'error' }
      ];

      errorHandler.logErrors(errors);

      expect(consoleSpy).toHaveBeenCalledWith('\n=== 파싱 결과 ===');
    });
  });

  describe('특수 케이스', () => {
    it('빈 에러 배열을 처리해야 함', () => {
      const categorized = errorHandler.categorizeErrors([]);
      const summary = errorHandler.createErrorSummary([]);
      const grouped = errorHandler.groupErrorsByCode([]);

      expect(categorized.errors).toHaveLength(0);
      expect(categorized.warnings).toHaveLength(0);
      expect(categorized.infos).toHaveLength(0);

      expect(summary.total).toBe(0);
      expect(summary.errorCount).toBe(0);
      expect(summary.warningCount).toBe(0);
      expect(summary.infoCount).toBe(0);

      expect(grouped.size).toBe(0);
    });

    it('null 또는 undefined 값들을 안전하게 처리해야 함', () => {
      const error = new Error('테스트');
      const parseError = errorHandler.createParseError(error, {
        line: undefined,
        column: undefined,
        path: undefined
      });

      expect(parseError.line).toBeUndefined();
      expect(parseError.column).toBeUndefined();
      expect(parseError.path).toBeUndefined();

      const formatted = errorHandler.formatUserFriendlyMessage(parseError);
      expect(formatted).toBe('에러: 테스트');
    });
  });
});