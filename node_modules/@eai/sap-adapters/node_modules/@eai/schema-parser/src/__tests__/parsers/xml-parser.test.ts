import { XMLParser } from '../../parsers/xml-parser';
import { ParseOptions } from '../../types';

describe('XMLParser', () => {
  let parser: XMLParser;

  beforeEach(() => {
    parser = new XMLParser();
  });

  describe('기본 XML 파싱', () => {
    it('간단한 XML을 올바르게 파싱해야 함', async () => {
      const xmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<root>
  <element>value</element>
  <number>123</number>
</root>`;

      const result = await parser.parse(xmlContent);

      expect(result.data).toBeDefined();
      expect(result.errors).toHaveLength(0);
      expect(result.data.root).toBeDefined();
      expect(result.data.root.element).toBe('value');
      expect(result.data.root.number).toBe(123);
    });

    it('속성이 있는 XML을 올바르게 파싱해야 함', async () => {
      const xmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<root id="123" name="test">
  <element attr="value">content</element>
</root>`;

      const result = await parser.parse(xmlContent);

      expect(result.data).toBeDefined();
      expect(result.errors).toHaveLength(0);
      expect(result.data.root['@_id']).toBe('123');
      expect(result.data.root['@_name']).toBe('test');
      expect(result.data.root.element['@_attr']).toBe('value');
      expect(result.data.root.element['#text']).toBe('content');
    });

    it('네임스페이스가 있는 XML을 파싱해야 함', async () => {
      const xmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="http://example.com/test">
  <xs:element name="testElement" type="xs:string"/>
</xs:schema>`;

      const result = await parser.parse(xmlContent, { processNamespaces: true });

      expect(result.data).toBeDefined();
      expect(result.errors).toHaveLength(0);
      expect(result.namespaces.prefixToUri.get('xs')).toBe('http://www.w3.org/2001/XMLSchema');
      expect(result.namespaces.targetNamespace).toBe('http://example.com/test');
    });
  });

  describe('에러 처리', () => {
    it('잘못된 XML 구문에 대해 에러를 반환해야 함', async () => {
      const invalidXml = `<?xml version="1.0" encoding="UTF-8"?>
<root>
  <unclosed-element>
  <another-element>value</another-element>
</root>`;

      const result = await parser.parse(invalidXml);

      expect(result.errors.length).toBeGreaterThan(0);
      expect(result.errors[0].severity).toMatch(/error|warning/);
      expect(result.errors[0].code).toContain('XML');
    });

    it('빈 문자열에 대해 에러를 반환해야 함', async () => {
      const result = await parser.parse('');

      expect(result.errors.length).toBeGreaterThan(0);
      expect(result.errors[0].message).toContain('빈 XML');
    });

    it('XXE 공격 패턴을 감지해야 함', async () => {
      const xxeXml = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>&xxe;</root>`;

      const result = await parser.parse(xxeXml);

      expect(result.errors.length).toBeGreaterThan(0);
      expect(result.errors.some(e => e.message.includes('보안상 위험한'))).toBe(true);
    });

    it('부분 실패 허용 모드에서 일부 에러가 있어도 파싱을 계속해야 함', async () => {
      const partiallyValidXml = `
        <?xml version="1.0" encoding="UTF-8"?>
        <root>
          <valid>content</valid>
          <invalid-unclosed>
          <another-valid>more content</another-valid>
        </root>
      `;

      const result = await parser.parse(partiallyValidXml, { allowPartialFailure: true });

      // 에러가 있지만 일부 데이터는 파싱되어야 함
      expect(result.errors.length).toBeGreaterThan(0);
      // 부분 실패 허용 모드에서는 가능한 한 파싱을 시도
    });
  });

  describe('네임스페이스 처리', () => {
    it('네임스페이스 정보를 올바르게 추출해야 함', async () => {
      const xmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:tns="http://example.com/test" xmlns="http://example.com/default" targetNamespace="http://example.com/test">
  <xs:element name="test"/>
</xs:schema>`;

      const result = await parser.parse(xmlContent, { processNamespaces: true });

      expect(result.namespaces.prefixToUri.get('xs')).toBe('http://www.w3.org/2001/XMLSchema');
      expect(result.namespaces.prefixToUri.get('tns')).toBe('http://example.com/test');
      expect(result.namespaces.defaultNamespace).toBe('http://example.com/default');
      expect(result.namespaces.targetNamespace).toBe('http://example.com/test');
    });

    it('네임스페이스 처리를 비활성화할 수 있어야 함', async () => {
      const xmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="test"/>
</xs:schema>`;

      const result = await parser.parse(xmlContent, { processNamespaces: false });

      expect(result.namespaces.prefixToUri.size).toBe(0);
    });
  });

  describe('XML 생성', () => {
    it('파싱된 객체를 XML로 변환할 수 있어야 함', () => {
      const data = {
        root: {
          '@_id': '123',
          element: 'value',
          number: 456
        }
      };

      const xml = parser.toXML(data);

      expect(xml).toContain('<root id="123">');
      expect(xml).toContain('<element>value</element>');
      expect(xml).toContain('<number>456</number>');
    });

    it('포맷팅 옵션을 적용할 수 있어야 함', () => {
      const data = {
        root: {
          element: 'value'
        }
      };

      const formattedXml = parser.toXML(data, { format: true });
      const unformattedXml = parser.toXML(data, { format: false });

      expect(formattedXml).toContain('\n');
      expect(unformattedXml).not.toContain('\n');
    });
  });

  describe('성능 및 제한', () => {
    it('null 또는 undefined 입력에 대해 적절히 처리해야 함', async () => {
      const result1 = await parser.parse(null as any);
      const result2 = await parser.parse(undefined as any);

      expect(result1.errors.length).toBeGreaterThan(0);
      expect(result2.errors.length).toBeGreaterThan(0);
    });

    it('매우 긴 XML 문서를 처리할 수 있어야 함', async () => {
      const largeXml = `<?xml version="1.0" encoding="UTF-8"?>
<root>
${Array.from({ length: 1000 }, (_, i) => `  <item${i}>value${i}</item${i}>`).join('\n')}
</root>`;

      const result = await parser.parse(largeXml);

      expect(result.data).toBeDefined();
      expect(result.errors).toHaveLength(0);
    });
  });
});