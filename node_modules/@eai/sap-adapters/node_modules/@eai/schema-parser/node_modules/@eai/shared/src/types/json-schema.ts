// JSON Schema 타입 정의
import { BaseSchema, SchemaType, ValidationResult } from './index';

export interface JSONSchemaDocument extends BaseSchema {
  type: SchemaType.JSON_SCHEMA;
  content: JSONSchemaContent;
}

export interface JSONSchemaContent {
  schema: JSONSchema;
  definitions?: Record<string, JSONSchema>;
  $defs?: Record<string, JSONSchema>;
}

export interface JSONSchema {
  // Core
  $schema?: string;
  $id?: string;
  id?: string; // Draft 4 compatibility
  $ref?: string;
  $comment?: string;
  
  // Metadata
  title?: string;
  description?: string;
  default?: any;
  examples?: any[];
  readOnly?: boolean;
  writeOnly?: boolean;
  deprecated?: boolean;
  
  // Type
  type?: JSONSchemaType | JSONSchemaType[];
  enum?: any[];
  const?: any;
  
  // Numeric constraints
  multipleOf?: number;
  maximum?: number;
  exclusiveMaximum?: number | boolean;
  minimum?: number;
  exclusiveMinimum?: number | boolean;
  
  // String constraints
  maxLength?: number;
  minLength?: number;
  pattern?: string;
  format?: string;
  
  // Array constraints
  items?: JSONSchema | JSONSchema[];
  additionalItems?: JSONSchema | boolean;
  maxItems?: number;
  minItems?: number;
  uniqueItems?: boolean;
  contains?: JSONSchema;
  
  // Object constraints
  maxProperties?: number;
  minProperties?: number;
  required?: string[];
  properties?: Record<string, JSONSchema>;
  patternProperties?: Record<string, JSONSchema>;
  additionalProperties?: JSONSchema | boolean;
  dependencies?: Record<string, JSONSchema | string[]>;
  propertyNames?: JSONSchema;
  
  // Conditional schemas
  if?: JSONSchema;
  then?: JSONSchema;
  else?: JSONSchema;
  
  // Schema composition
  allOf?: JSONSchema[];
  anyOf?: JSONSchema[];
  oneOf?: JSONSchema[];
  not?: JSONSchema;
  
  // Draft 7 specific
  $recursiveRef?: string;
  
  // Draft 2019-09 / 2020-12 specific
  $anchor?: string;
  $recursiveAnchor?: boolean;
  unevaluatedItems?: JSONSchema | boolean;
  unevaluatedProperties?: JSONSchema | boolean;
  
  // Custom extensions
  [key: string]: any;
}

export enum JSONSchemaType {
  NULL = 'null',
  BOOLEAN = 'boolean',
  OBJECT = 'object',
  ARRAY = 'array',
  NUMBER = 'number',
  STRING = 'string',
  INTEGER = 'integer',
}

export enum JSONSchemaFormat {
  // String formats
  DATE_TIME = 'date-time',
  DATE = 'date',
  TIME = 'time',
  DURATION = 'duration',
  EMAIL = 'email',
  IDN_EMAIL = 'idn-email',
  HOSTNAME = 'hostname',
  IDN_HOSTNAME = 'idn-hostname',
  IPV4 = 'ipv4',
  IPV6 = 'ipv6',
  URI = 'uri',
  URI_REFERENCE = 'uri-reference',
  IRI = 'iri',
  IRI_REFERENCE = 'iri-reference',
  UUID = 'uuid',
  URI_TEMPLATE = 'uri-template',
  JSON_POINTER = 'json-pointer',
  RELATIVE_JSON_POINTER = 'relative-json-pointer',
  REGEX = 'regex',
  
  // Numeric formats
  INT32 = 'int32',
  INT64 = 'int64',
  FLOAT = 'float',
  DOUBLE = 'double',
  
  // Binary formats
  BYTE = 'byte',
  BINARY = 'binary',
  BASE64 = 'base64',
  BASE64URL = 'base64url',
  
  // Password
  PASSWORD = 'password',
}

export enum JSONSchemaDraft {
  DRAFT_04 = 'http://json-schema.org/draft-04/schema#',
  DRAFT_06 = 'http://json-schema.org/draft-06/schema#',
  DRAFT_07 = 'http://json-schema.org/draft-07/schema#',
  DRAFT_2019_09 = 'https://json-schema.org/draft/2019-09/schema',
  DRAFT_2020_12 = 'https://json-schema.org/draft/2020-12/schema',
}

// JSON Schema 파싱 관련 타입
export interface JSONSchemaParseOptions {
  draft?: JSONSchemaDraft;
  resolveReferences: boolean;
  validateSchema: boolean;
  allowUnknownFormats: boolean;
  strictMode: boolean;
  maxDepth: number;
  timeout: number;
}

export interface JSONSchemaParseResult {
  schema: JSONSchemaDocument;
  validation: ValidationResult;
  metadata: JSONSchemaParseMetadata;
}

export interface JSONSchemaParseMetadata {
  draft: JSONSchemaDraft;
  schemaCount: number;
  definitionCount: number;
  referenceCount: number;
  maxDepth: number;
  externalReferences: string[];
  formats: string[];
}

// JSON Schema 검증 관련 타입
export interface JSONSchemaValidationOptions {
  draft?: JSONSchemaDraft;
  checkReferences: boolean;
  validateFormats: boolean;
  allowUnknownKeywords: boolean;
  strictMode: boolean;
}

export interface JSONSchemaValidationError {
  code: JSONSchemaErrorCode;
  message: string;
  instancePath: string;
  schemaPath: string;
  keyword: string;
  params?: Record<string, any>;
  data?: any;
  schema?: any;
  parentSchema?: any;
}

export enum JSONSchemaErrorCode {
  INVALID_REFERENCE = 'INVALID_REFERENCE',
  CIRCULAR_REFERENCE = 'CIRCULAR_REFERENCE',
  INVALID_TYPE = 'INVALID_TYPE',
  INVALID_FORMAT = 'INVALID_FORMAT',
  CONSTRAINT_VIOLATION = 'CONSTRAINT_VIOLATION',
  MISSING_REQUIRED_PROPERTY = 'MISSING_REQUIRED_PROPERTY',
  ADDITIONAL_PROPERTIES_NOT_ALLOWED = 'ADDITIONAL_PROPERTIES_NOT_ALLOWED',
  ENUM_MISMATCH = 'ENUM_MISMATCH',
  CONST_MISMATCH = 'CONST_MISMATCH',
  PATTERN_MISMATCH = 'PATTERN_MISMATCH',
  MULTIPLE_OF_VIOLATION = 'MULTIPLE_OF_VIOLATION',
  MINIMUM_VIOLATION = 'MINIMUM_VIOLATION',
  MAXIMUM_VIOLATION = 'MAXIMUM_VIOLATION',
  MIN_LENGTH_VIOLATION = 'MIN_LENGTH_VIOLATION',
  MAX_LENGTH_VIOLATION = 'MAX_LENGTH_VIOLATION',
  MIN_ITEMS_VIOLATION = 'MIN_ITEMS_VIOLATION',
  MAX_ITEMS_VIOLATION = 'MAX_ITEMS_VIOLATION',
  UNIQUE_ITEMS_VIOLATION = 'UNIQUE_ITEMS_VIOLATION',
  MIN_PROPERTIES_VIOLATION = 'MIN_PROPERTIES_VIOLATION',
  MAX_PROPERTIES_VIOLATION = 'MAX_PROPERTIES_VIOLATION',
  DEPENDENCY_VIOLATION = 'DEPENDENCY_VIOLATION',
  CONDITIONAL_SCHEMA_VIOLATION = 'CONDITIONAL_SCHEMA_VIOLATION',
  COMPOSITION_VIOLATION = 'COMPOSITION_VIOLATION',
}

// JSON Schema 변환 관련 타입
export interface JSONSchemaConversionOptions {
  targetDraft?: JSONSchemaDraft;
  preserveExamples: boolean;
  preserveDescriptions: boolean;
  generateTitles: boolean;
  flattenDefinitions: boolean;
}

export interface JSONSchemaToEAIMapping {
  schemas: JSONSchemaMapping[];
  definitions: JSONSchemaDefinitionMapping[];
  properties: JSONSchemaPropertyMapping[];
}

export interface JSONSchemaMapping {
  jsonSchema: string;
  eaiEntity: string;
  propertyMappings: JSONSchemaPropertyMapping[];
  constraints: JSONSchemaConstraintMapping[];
}

export interface JSONSchemaDefinitionMapping {
  jsonDefinition: string;
  eaiType: string;
  properties: JSONSchemaPropertyMapping[];
}

export interface JSONSchemaPropertyMapping {
  jsonProperty: string;
  eaiProperty: string;
  typeMapping: JSONSchemaTypeMapping;
  constraints: JSONSchemaConstraintMapping[];
}

export interface JSONSchemaTypeMapping {
  jsonType: JSONSchemaType;
  eaiType: string;
  format?: string;
  conversionRule?: string;
}

export interface JSONSchemaConstraintMapping {
  jsonConstraint: string;
  eaiConstraint: string;
  value: any;
  transformation?: string;
}

// JSON Schema 유틸리티 타입
export interface JSONSchemaReference {
  $ref: string;
  resolved?: JSONSchema;
  circular?: boolean;
}

export interface JSONSchemaContext {
  baseUri: string;
  currentPath: string[];
  definitions: Record<string, JSONSchema>;
  references: JSONSchemaReference[];
  draft: JSONSchemaDraft;
}

export interface JSONSchemaTraversalOptions {
  includeParentSchema: boolean;
  includeSchemaPath: boolean;
  followReferences: boolean;
  maxDepth: number;
}

export interface JSONSchemaNode {
  schema: JSONSchema;
  path: string[];
  parent?: JSONSchemaNode;
  key?: string;
  index?: number;
  isReference: boolean;
  depth: number;
}

// JSON Schema 메타스키마 검증
export interface JSONSchemaMetaValidation {
  isValid: boolean;
  draft: JSONSchemaDraft;
  errors: JSONSchemaValidationError[];
  warnings: JSONSchemaValidationError[];
}

// JSON Schema 문서 생성
export interface JSONSchemaDocumentationOptions {
  includeExamples: boolean;
  includeDescriptions: boolean;
  includeConstraints: boolean;
  format: DocumentationFormat;
}

export enum DocumentationFormat {
  HTML = 'html',
  MARKDOWN = 'markdown',
  JSON = 'json',
  YAML = 'yaml',
}

export interface JSONSchemaDocumentation {
  title: string;
  description?: string;
  version?: string;
  schemas: SchemaDocumentation[];
  definitions: DefinitionDocumentation[];
}

export interface SchemaDocumentation {
  name: string;
  title?: string;
  description?: string;
  type: string;
  properties: PropertyDocumentation[];
  examples?: any[];
  constraints: ConstraintDocumentation[];
}

export interface PropertyDocumentation {
  name: string;
  type: string;
  description?: string;
  required: boolean;
  constraints: ConstraintDocumentation[];
  examples?: any[];
}

export interface DefinitionDocumentation {
  name: string;
  title?: string;
  description?: string;
  type: string;
  properties: PropertyDocumentation[];
  usedBy: string[];
}

export interface ConstraintDocumentation {
  type: string;
  value: any;
  description: string;
}