import { SOAPAdapter } from '../adapters/soap-adapter';
export class SAPValidator {
    soapAdapter;
    constructor() {
        this.soapAdapter = new SOAPAdapter();
    }
    async validateODataSchema(schema) {
        const errors = [];
        const warnings = [];
        // OData 버전 검증
        this.validateODataVersion(schema, errors, warnings);
        // EntityContainer 검증
        this.validateEntityContainer(schema, errors, warnings);
        // EntityType 검증
        this.validateEntityTypes(schema, errors, warnings);
        // Association 검증
        this.validateAssociations(schema, errors, warnings);
        // 네이밍 규칙 검증
        this.validateODataNamingConventions(schema, errors, warnings);
        // 성능 관련 검증
        this.validateODataPerformance(schema, errors, warnings);
        return this.createValidationResult(errors, warnings, 'OData');
    }
    async validateIDocSchema(schema) {
        const errors = [];
        const warnings = [];
        // IDoc 구조 검증
        this.validateIDocStructure(schema, errors, warnings);
        // 세그먼트 계층 검증
        this.validateSegmentHierarchy(schema, errors, warnings);
        // 필드 정의 검증
        this.validateIDocFields(schema, errors, warnings);
        // 컨트롤 레코드 검증
        this.validateControlRecord(schema, errors, warnings);
        // IDoc 네이밍 규칙 검증
        this.validateIDocNamingConventions(schema, errors, warnings);
        return this.createValidationResult(errors, warnings, 'IDoc');
    }
    async validateRFCSchema(schema) {
        const errors = [];
        const warnings = [];
        // RFC 함수 시그니처 검증
        this.validateRFCSignature(schema, errors, warnings);
        // 파라미터 검증
        this.validateRFCParameters(schema, errors, warnings);
        // 테이블 파라미터 검증
        this.validateRFCTables(schema, errors, warnings);
        // 예외 검증
        this.validateRFCExceptions(schema, errors, warnings);
        // RFC 네이밍 규칙 검증
        this.validateRFCNamingConventions(schema, errors, warnings);
        // 성능 관련 검증
        this.validateRFCPerformance(schema, errors, warnings);
        return this.createValidationResult(errors, warnings, 'RFC');
    }
    async validateSOAPSchema(schema) {
        // SOAP 어댑터의 검증 로직 사용
        return this.soapAdapter.validate(schema);
    }
    // OData 검증 메서드들
    validateODataVersion(schema, errors, warnings) {
        const version = schema.version;
        if (!version) {
            errors.push({
                rule: 'ODATA_VERSION_MISSING',
                message: 'OData 버전이 정의되지 않았습니다.',
                severity: 'error',
            });
        }
        else if (!['1.0', '2.0', '3.0', '4.0'].includes(version)) {
            warnings.push({
                rule: 'ODATA_VERSION_UNSUPPORTED',
                message: `지원되지 않는 OData 버전: ${version}`,
                severity: 'warning',
            });
        }
    }
    validateEntityContainer(schema, errors, warnings) {
        const container = schema.content.entityContainer;
        if (!container) {
            errors.push({
                rule: 'ENTITY_CONTAINER_MISSING',
                message: 'EntityContainer가 정의되지 않았습니다.',
                severity: 'error',
            });
            return;
        }
        if (!container.name) {
            errors.push({
                rule: 'ENTITY_CONTAINER_NAME_MISSING',
                message: 'EntityContainer 이름이 정의되지 않았습니다.',
                severity: 'error',
            });
        }
        if (container.entitySets.length === 0) {
            warnings.push({
                rule: 'ENTITY_CONTAINER_EMPTY',
                message: 'EntityContainer에 EntitySet이 정의되지 않았습니다.',
                severity: 'warning',
            });
        }
    }
    validateEntityTypes(schema, errors, warnings) {
        for (const entityType of schema.content.entityTypes) {
            // 키 검증
            if (!entityType.key || entityType.key.propertyRefs.length === 0) {
                errors.push({
                    rule: 'ENTITY_TYPE_KEY_MISSING',
                    message: `EntityType '${entityType.name}'에 키가 정의되지 않았습니다.`,
                    element: entityType.name,
                    severity: 'error',
                });
            }
            // 속성 검증
            if (entityType.properties.length === 0) {
                warnings.push({
                    rule: 'ENTITY_TYPE_NO_PROPERTIES',
                    message: `EntityType '${entityType.name}'에 속성이 정의되지 않았습니다.`,
                    element: entityType.name,
                    severity: 'warning',
                });
            }
            // 키 속성 존재 확인
            for (const keyRef of entityType.key?.propertyRefs || []) {
                const keyProperty = entityType.properties.find(p => p.name === keyRef.name);
                if (!keyProperty) {
                    errors.push({
                        rule: 'KEY_PROPERTY_NOT_FOUND',
                        message: `키 속성 '${keyRef.name}'이 EntityType '${entityType.name}'에서 찾을 수 없습니다.`,
                        element: `${entityType.name}.${keyRef.name}`,
                        severity: 'error',
                    });
                }
                else if (keyProperty.nullable) {
                    warnings.push({
                        rule: 'KEY_PROPERTY_NULLABLE',
                        message: `키 속성 '${keyRef.name}'이 nullable로 정의되었습니다.`,
                        element: `${entityType.name}.${keyRef.name}`,
                        severity: 'warning',
                    });
                }
            }
        }
    }
    validateAssociations(schema, errors, warnings) {
        for (const association of schema.content.associations) {
            if (association.ends.length !== 2) {
                errors.push({
                    rule: 'ASSOCIATION_INVALID_ENDS',
                    message: `Association '${association.name}'은 정확히 2개의 End를 가져야 합니다.`,
                    element: association.name,
                    severity: 'error',
                });
            }
            // End 타입 검증
            for (const end of association.ends) {
                const entityType = schema.content.entityTypes.find(et => `${schema.metadata.namespace}.${et.name}` === end.type);
                if (!entityType) {
                    errors.push({
                        rule: 'ASSOCIATION_END_TYPE_NOT_FOUND',
                        message: `Association End 타입 '${end.type}'을 찾을 수 없습니다.`,
                        element: `${association.name}.${end.role}`,
                        severity: 'error',
                    });
                }
            }
        }
    }
    validateODataNamingConventions(schema, errors, warnings) {
        // EntityType 네이밍 검증
        for (const entityType of schema.content.entityTypes) {
            if (!/^[A-Z][a-zA-Z0-9]*$/.test(entityType.name)) {
                warnings.push({
                    rule: 'ENTITY_TYPE_NAMING_CONVENTION',
                    message: `EntityType '${entityType.name}'이 네이밍 규칙을 따르지 않습니다. (PascalCase 권장)`,
                    element: entityType.name,
                    severity: 'warning',
                });
            }
        }
        // EntitySet 네이밍 검증
        for (const entitySet of schema.content.entitySets) {
            if (!/^[A-Z][a-zA-Z0-9]*$/.test(entitySet.name)) {
                warnings.push({
                    rule: 'ENTITY_SET_NAMING_CONVENTION',
                    message: `EntitySet '${entitySet.name}'이 네이밍 규칙을 따르지 않습니다. (PascalCase 권장)`,
                    element: entitySet.name,
                    severity: 'warning',
                });
            }
        }
    }
    validateODataPerformance(schema, errors, warnings) {
        // 너무 많은 EntityType 경고
        if (schema.content.entityTypes.length > 100) {
            warnings.push({
                rule: 'TOO_MANY_ENTITY_TYPES',
                message: `EntityType이 너무 많습니다 (${schema.content.entityTypes.length}개). 성능에 영향을 줄 수 있습니다.`,
                severity: 'warning',
            });
        }
        // 너무 많은 속성을 가진 EntityType 경고
        for (const entityType of schema.content.entityTypes) {
            if (entityType.properties.length > 50) {
                warnings.push({
                    rule: 'TOO_MANY_PROPERTIES',
                    message: `EntityType '${entityType.name}'의 속성이 너무 많습니다 (${entityType.properties.length}개).`,
                    element: entityType.name,
                    severity: 'warning',
                });
            }
        }
    }
    // IDoc 검증 메서드들
    validateIDocStructure(schema, errors, warnings) {
        if (!schema.content.idocType) {
            errors.push({
                rule: 'IDOC_TYPE_MISSING',
                message: 'IDoc 타입이 정의되지 않았습니다.',
                severity: 'error',
            });
        }
        if (!schema.content.release) {
            warnings.push({
                rule: 'IDOC_RELEASE_MISSING',
                message: 'IDoc 릴리즈 정보가 누락되었습니다.',
                severity: 'warning',
            });
        }
        if (schema.content.segments.length === 0) {
            errors.push({
                rule: 'IDOC_NO_SEGMENTS',
                message: 'IDoc에 세그먼트가 정의되지 않았습니다.',
                severity: 'error',
            });
        }
    }
    validateSegmentHierarchy(schema, errors, warnings) {
        const hierarchy = schema.content.hierarchy;
        if (!hierarchy.root) {
            errors.push({
                rule: 'IDOC_ROOT_SEGMENT_MISSING',
                message: '루트 세그먼트가 정의되지 않았습니다.',
                severity: 'error',
            });
        }
        // 계층 레벨 검증
        for (const level of hierarchy.levels) {
            if (level.segments.length === 0) {
                warnings.push({
                    rule: 'EMPTY_HIERARCHY_LEVEL',
                    message: `계층 레벨 ${level.level}에 세그먼트가 없습니다.`,
                    severity: 'warning',
                });
            }
        }
        // 세그먼트 참조 무결성 검증
        for (const segment of schema.content.segments) {
            if (segment.parent) {
                const parentExists = schema.content.segments.some(s => s.name === segment.parent);
                if (!parentExists) {
                    errors.push({
                        rule: 'SEGMENT_PARENT_NOT_FOUND',
                        message: `세그먼트 '${segment.name}'의 부모 세그먼트 '${segment.parent}'를 찾을 수 없습니다.`,
                        element: segment.name,
                        severity: 'error',
                    });
                }
            }
        }
    }
    validateIDocFields(schema, errors, warnings) {
        for (const segment of schema.content.segments) {
            if (segment.fields.length === 0) {
                warnings.push({
                    rule: 'SEGMENT_NO_FIELDS',
                    message: `세그먼트 '${segment.name}'에 필드가 정의되지 않았습니다.`,
                    element: segment.name,
                    severity: 'warning',
                });
            }
            // 필드 위치 중복 검증
            const positions = new Set();
            for (const field of segment.fields) {
                if (positions.has(field.position)) {
                    errors.push({
                        rule: 'DUPLICATE_FIELD_POSITION',
                        message: `세그먼트 '${segment.name}'에서 필드 위치 ${field.position}이 중복됩니다.`,
                        element: `${segment.name}.${field.name}`,
                        severity: 'error',
                    });
                }
                positions.add(field.position);
            }
        }
    }
    validateControlRecord(schema, errors, warnings) {
        const control = schema.content.controlRecord;
        if (!control.idoctyp) {
            errors.push({
                rule: 'CONTROL_IDOCTYP_MISSING',
                message: '컨트롤 레코드에 IDoc 타입이 정의되지 않았습니다.',
                severity: 'error',
            });
        }
        if (!control.mestyp) {
            warnings.push({
                rule: 'CONTROL_MESTYP_MISSING',
                message: '컨트롤 레코드에 메시지 타입이 정의되지 않았습니다.',
                severity: 'warning',
            });
        }
    }
    validateIDocNamingConventions(schema, errors, warnings) {
        // IDoc 타입 네이밍 검증
        if (schema.content.idocType && !/^[A-Z][A-Z0-9_]*$/.test(schema.content.idocType)) {
            warnings.push({
                rule: 'IDOC_TYPE_NAMING_CONVENTION',
                message: `IDoc 타입 '${schema.content.idocType}'이 네이밍 규칙을 따르지 않습니다.`,
                severity: 'warning',
            });
        }
        // 세그먼트 네이밍 검증
        for (const segment of schema.content.segments) {
            if (!/^[A-Z][A-Z0-9_]*$/.test(segment.name)) {
                warnings.push({
                    rule: 'SEGMENT_NAMING_CONVENTION',
                    message: `세그먼트 '${segment.name}'이 네이밍 규칙을 따르지 않습니다.`,
                    element: segment.name,
                    severity: 'warning',
                });
            }
        }
    }
    // RFC 검증 메서드들
    validateRFCSignature(schema, errors, warnings) {
        if (!schema.content.functionName) {
            errors.push({
                rule: 'RFC_FUNCTION_NAME_MISSING',
                message: 'RFC 함수명이 정의되지 않았습니다.',
                severity: 'error',
            });
        }
        if (!schema.content.functionGroup) {
            warnings.push({
                rule: 'RFC_FUNCTION_GROUP_MISSING',
                message: 'RFC 함수 그룹이 정의되지 않았습니다.',
                severity: 'warning',
            });
        }
    }
    validateRFCParameters(schema, errors, warnings) {
        const allParams = [
            ...schema.content.importing,
            ...schema.content.exporting,
            ...schema.content.changing,
        ];
        // 파라미터명 중복 검증
        const paramNames = new Set();
        for (const param of allParams) {
            if (paramNames.has(param.name)) {
                errors.push({
                    rule: 'DUPLICATE_PARAMETER_NAME',
                    message: `중복된 파라미터명: ${param.name}`,
                    element: param.name,
                    severity: 'error',
                });
            }
            paramNames.add(param.name);
        }
        // 파라미터 타입 검증
        for (const param of allParams) {
            if (!param.dataType) {
                errors.push({
                    rule: 'PARAMETER_TYPE_MISSING',
                    message: `파라미터 '${param.name}'의 데이터 타입이 정의되지 않았습니다.`,
                    element: param.name,
                    severity: 'error',
                });
            }
        }
    }
    validateRFCTables(schema, errors, warnings) {
        for (const table of schema.content.tables) {
            if (!table.structure || table.structure.fields.length === 0) {
                warnings.push({
                    rule: 'TABLE_STRUCTURE_EMPTY',
                    message: `테이블 '${table.name}'의 구조가 정의되지 않았습니다.`,
                    element: table.name,
                    severity: 'warning',
                });
            }
        }
    }
    validateRFCExceptions(schema, errors, warnings) {
        const exceptionNames = new Set();
        for (const exception of schema.content.exceptions) {
            if (exceptionNames.has(exception.name)) {
                errors.push({
                    rule: 'DUPLICATE_EXCEPTION_NAME',
                    message: `중복된 예외명: ${exception.name}`,
                    element: exception.name,
                    severity: 'error',
                });
            }
            exceptionNames.add(exception.name);
        }
    }
    validateRFCNamingConventions(schema, errors, warnings) {
        // 함수명 네이밍 검증
        if (schema.content.functionName &&
            !/^[A-Z][A-Z0-9_]*$/.test(schema.content.functionName)) {
            warnings.push({
                rule: 'RFC_FUNCTION_NAMING_CONVENTION',
                message: `RFC 함수명 '${schema.content.functionName}'이 네이밍 규칙을 따르지 않습니다.`,
                element: schema.content.functionName,
                severity: 'warning',
            });
        }
    }
    validateRFCPerformance(schema, errors, warnings) {
        const totalParams = schema.content.importing.length +
            schema.content.exporting.length +
            schema.content.changing.length;
        if (totalParams > 50) {
            warnings.push({
                rule: 'TOO_MANY_PARAMETERS',
                message: `RFC 함수의 파라미터가 너무 많습니다 (${totalParams}개). 성능에 영향을 줄 수 있습니다.`,
                severity: 'warning',
            });
        }
        if (schema.content.tables.length > 20) {
            warnings.push({
                rule: 'TOO_MANY_TABLES',
                message: `RFC 함수의 테이블 파라미터가 너무 많습니다 (${schema.content.tables.length}개).`,
                severity: 'warning',
            });
        }
    }
    createValidationResult(errors, warnings, schemaType) {
        const totalRules = this.getTotalRulesCount(schemaType);
        return {
            isValid: errors.length === 0,
            errors,
            warnings,
            summary: {
                totalRules,
                passedRules: totalRules - errors.length - warnings.length,
                failedRules: errors.length,
                warningRules: warnings.length,
            },
        };
    }
    getTotalRulesCount(schemaType) {
        switch (schemaType) {
            case 'OData':
                return 15;
            case 'IDoc':
                return 12;
            case 'RFC':
                return 10;
            case 'SOAP':
                return 8;
            default:
                return 10;
        }
    }
}
