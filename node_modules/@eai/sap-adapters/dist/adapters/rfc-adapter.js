// SAP RFC 메타데이터 파싱 어댑터
import { XMLParser } from 'fast-xml-parser';
import { RFCParameterType, } from '@eai/shared/types/sap';
import { SchemaType } from '@eai/shared/types';
export class RFCAdapter {
    xmlParser;
    constructor() {
        this.xmlParser = new XMLParser({
            ignoreAttributes: false,
            attributeNamePrefix: '@_',
            textNodeName: '#text',
            parseAttributeValue: true,
            trimValues: true,
        });
    }
    async parse(content, options = {}) {
        const startTime = Date.now();
        const errors = [];
        const warnings = [];
        try {
            // RFC 메타데이터 형식 감지 (XML, JSON, 또는 텍스트)
            let parsedContent;
            if (content.trim().startsWith('<')) {
                parsedContent = await this.parseXMLRFC(content, options);
            }
            else if (content.trim().startsWith('{')) {
                parsedContent = await this.parseJSONRFC(content, options);
            }
            else {
                parsedContent = await this.parseTextRFC(content, options);
            }
            const metadata = {
                version: '1.0',
                namespace: `SAP.RFC.${parsedContent.functionName}`,
                createdAt: new Date(),
                parsedAt: new Date(),
            };
            const processingTime = Date.now() - startTime;
            const result = {
                id: this.generateId(),
                name: parsedContent.functionName,
                version: metadata.version,
                type: SchemaType.SAP_RFC,
                originalFormat: this.detectFormat(content),
                metadata: {
                    namespace: metadata.namespace,
                    targetNamespace: metadata.namespace,
                    imports: [],
                    annotations: [],
                },
                content: parsedContent,
                createdAt: metadata.createdAt,
                updatedAt: metadata.parsedAt,
            };
            return {
                schema: result,
                metadata,
                errors,
                warnings: warnings.filter(w => w.severity === 'warning'),
                statistics: {
                    totalElements: this.countElements(parsedContent),
                    parsedElements: this.countElements(parsedContent) - errors.length,
                    errorCount: errors.length,
                    warningCount: warnings.length,
                    processingTime,
                },
            };
        }
        catch (error) {
            errors.push({
                code: 'RFC_PARSE_ERROR',
                message: error instanceof Error ? error.message : '알 수 없는 RFC 파싱 오류',
                severity: 'error',
            });
            throw error;
        }
    }
    async parseXMLRFC(content, options) {
        const xmlData = this.xmlParser.parse(content);
        // RFC 루트 요소 찾기
        const rfcRoot = xmlData.RFC || xmlData.rfc || xmlData.FunctionModule;
        if (!rfcRoot) {
            throw new Error('유효하지 않은 RFC XML: 루트 요소를 찾을 수 없습니다.');
        }
        return {
            functionName: rfcRoot['@_name'] || rfcRoot.name || 'UNKNOWN_FUNCTION',
            functionGroup: rfcRoot['@_group'] || rfcRoot.group || '',
            shortText: rfcRoot['@_shortText'] || rfcRoot.shortText || '',
            importing: await this.parseParameters(rfcRoot.importing || rfcRoot.IMPORTING || []),
            exporting: await this.parseParameters(rfcRoot.exporting || rfcRoot.EXPORTING || []),
            changing: await this.parseParameters(rfcRoot.changing || rfcRoot.CHANGING || []),
            tables: await this.parseTables(rfcRoot.tables || rfcRoot.TABLES || []),
            exceptions: await this.parseExceptions(rfcRoot.exceptions || rfcRoot.EXCEPTIONS || []),
            documentation: await this.parseDocumentation(rfcRoot.documentation || {}),
        };
    }
    async parseJSONRFC(content, options) {
        const jsonData = JSON.parse(content);
        if (!jsonData.functionName && !jsonData.FUNCNAME) {
            throw new Error('유효하지 않은 RFC JSON: 함수명을 찾을 수 없습니다.');
        }
        return {
            functionName: jsonData.functionName || jsonData.FUNCNAME,
            functionGroup: jsonData.functionGroup || jsonData.FUNCGROUP || '',
            shortText: jsonData.shortText || jsonData.SHORT_TEXT || '',
            importing: await this.parseParameters(jsonData.importing || jsonData.IMPORTING || []),
            exporting: await this.parseParameters(jsonData.exporting || jsonData.EXPORTING || []),
            changing: await this.parseParameters(jsonData.changing || jsonData.CHANGING || []),
            tables: await this.parseTables(jsonData.tables || jsonData.TABLES || []),
            exceptions: await this.parseExceptions(jsonData.exceptions || jsonData.EXCEPTIONS || []),
            documentation: await this.parseDocumentation(jsonData.documentation || {}),
        };
    }
    async parseTextRFC(content, options) {
        const lines = content.split('\n').map(line => line.trim()).filter(line => line);
        let functionName = '';
        let functionGroup = '';
        let shortText = '';
        const importing = [];
        const exporting = [];
        const changing = [];
        const tables = [];
        const exceptions = [];
        let currentSection = '';
        for (const line of lines) {
            if (line.startsWith('FUNCTION ')) {
                functionName = line.replace('FUNCTION ', '').replace('.', '').trim();
            }
            else if (line.startsWith('*"')) {
                // 주석 처리
                if (line.includes('Function Group:')) {
                    functionGroup = line.split('Function Group:')[1].trim();
                }
                else if (line.includes('Short Text:')) {
                    shortText = line.split('Short Text:')[1].trim();
                }
            }
            else if (line === 'IMPORTING' || line === 'EXPORTING' ||
                line === 'CHANGING' || line === 'TABLES' || line === 'EXCEPTIONS') {
                currentSection = line;
            }
            else if (currentSection && line.includes('TYPE') || line.includes('LIKE')) {
                const param = this.parseParameterFromText(line);
                switch (currentSection) {
                    case 'IMPORTING':
                        importing.push(param);
                        break;
                    case 'EXPORTING':
                        exporting.push(param);
                        break;
                    case 'CHANGING':
                        changing.push(param);
                        break;
                    case 'TABLES':
                        tables.push(this.convertParameterToTable(param));
                        break;
                    case 'EXCEPTIONS':
                        exceptions.push({
                            name: param.name,
                            description: param.description,
                        });
                        break;
                }
            }
        }
        return {
            functionName,
            functionGroup,
            shortText,
            importing,
            exporting,
            changing,
            tables,
            exceptions,
            documentation: {
                shortText,
                longText: '',
                parameters: [],
                exceptions: [],
            },
        };
    }
    async parseParameters(parametersData) {
        if (!Array.isArray(parametersData)) {
            parametersData = parametersData ? [parametersData] : [];
        }
        return parametersData.map((param) => ({
            name: param.name || param.NAME || param['@_name'],
            type: this.parseParameterType(param.type || param.TYPE),
            dataType: param.dataType || param.DATA_TYPE || param.type || 'CHAR',
            length: param.length ? parseInt(param.length) : undefined,
            decimals: param.decimals ? parseInt(param.decimals) : undefined,
            defaultValue: param.defaultValue || param.DEFAULT_VALUE,
            optional: param.optional === true || param.OPTIONAL === 'X',
            description: param.description || param.DESCRIPTION || '',
            structure: param.structure ? this.parseStructure(param.structure) : undefined,
        }));
    }
    parseParameterType(type) {
        if (!type)
            return RFCParameterType.ELEMENTARY;
        const upperType = type.toUpperCase();
        if (upperType.includes('STRUCTURE') || upperType.includes('STRUCT')) {
            return RFCParameterType.STRUCTURE;
        }
        else if (upperType.includes('TABLE') || upperType.includes('ITAB')) {
            return RFCParameterType.TABLE;
        }
        return RFCParameterType.ELEMENTARY;
    }
    parseStructure(structureData) {
        return {
            name: structureData.name || structureData.NAME || 'UNKNOWN_STRUCTURE',
            fields: this.parseFields(structureData.fields || structureData.FIELDS || []),
        };
    }
    parseFields(fieldsData) {
        if (!Array.isArray(fieldsData)) {
            fieldsData = fieldsData ? [fieldsData] : [];
        }
        return fieldsData.map((field, index) => ({
            name: field.name || field.NAME || field.FIELDNAME,
            dataType: field.dataType || field.DATA_TYPE || field.DATATYPE || 'CHAR',
            length: field.length ? parseInt(field.length) : 0,
            decimals: field.decimals ? parseInt(field.decimals) : undefined,
            description: field.description || field.DESCRIPTION || field.FIELDTEXT || '',
            offset: field.offset ? parseInt(field.offset) : index * 10,
        }));
    }
    async parseTables(tablesData) {
        if (!Array.isArray(tablesData)) {
            tablesData = tablesData ? [tablesData] : [];
        }
        return tablesData.map((table) => ({
            name: table.name || table.NAME || table.PARAMETER,
            type: table.type || table.TYPE || table.TABNAME || 'TABLE',
            description: table.description || table.DESCRIPTION || '',
            structure: this.parseStructure(table.structure || table.STRUCTURE || {}),
            optional: table.optional === true || table.OPTIONAL === 'X',
        }));
    }
    async parseExceptions(exceptionsData) {
        if (!Array.isArray(exceptionsData)) {
            exceptionsData = exceptionsData ? [exceptionsData] : [];
        }
        return exceptionsData.map((exception) => ({
            name: exception.name || exception.NAME || exception.EXCEPTION,
            description: exception.description || exception.DESCRIPTION || '',
        }));
    }
    async parseDocumentation(docData) {
        return {
            shortText: docData.shortText || docData.SHORT_TEXT || '',
            longText: docData.longText || docData.LONG_TEXT || '',
            parameters: docData.parameters || [],
            exceptions: docData.exceptions || [],
        };
    }
    parseParameterFromText(line) {
        // 예: "    VALUE(IV_PARAM) TYPE STRING OPTIONAL"
        const parts = line.trim().split(/\s+/);
        let name = '';
        let dataType = 'CHAR';
        let optional = false;
        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            if (part.includes('VALUE(') || part.includes('REFERENCE(')) {
                name = part.replace(/VALUE\(|\)|REFERENCE\(/g, '');
            }
            else if (part === 'TYPE' || part === 'LIKE') {
                dataType = parts[i + 1] || 'CHAR';
                i++; // 다음 파트 스킵
            }
            else if (part === 'OPTIONAL') {
                optional = true;
            }
            else if (!name && part && !part.includes('*')) {
                name = part;
            }
        }
        return {
            name,
            type: RFCParameterType.ELEMENTARY,
            dataType,
            optional,
            description: '',
        };
    }
    convertParameterToTable(param) {
        return {
            name: param.name,
            type: param.dataType,
            description: param.description,
            structure: param.structure || {
                name: param.name + '_STRUCTURE',
                fields: [],
            },
            optional: param.optional,
        };
    }
    detectFormat(content) {
        const trimmed = content.trim();
        if (trimmed.startsWith('<'))
            return 'XML';
        if (trimmed.startsWith('{'))
            return 'JSON';
        return 'TEXT';
    }
    async validate(schema) {
        const errors = [];
        const warnings = [];
        // 함수명 검증
        if (!schema.content.functionName) {
            errors.push({
                rule: 'FUNCTION_NAME_REQUIRED',
                message: 'RFC 함수명이 필요합니다.',
                severity: 'error',
            });
        }
        // 함수명 명명 규칙 검증
        if (schema.content.functionName &&
            !/^[A-Z][A-Z0-9_]*$/.test(schema.content.functionName)) {
            warnings.push({
                rule: 'FUNCTION_NAME_CONVENTION',
                message: 'RFC 함수명이 SAP 명명 규칙을 따르지 않습니다.',
                element: schema.content.functionName,
                severity: 'warning',
            });
        }
        // 파라미터 검증
        const allParameters = [
            ...schema.content.importing,
            ...schema.content.exporting,
            ...schema.content.changing,
        ];
        const parameterNames = new Set();
        for (const param of allParameters) {
            if (parameterNames.has(param.name)) {
                errors.push({
                    rule: 'DUPLICATE_PARAMETER_NAME',
                    message: `중복된 파라미터명: ${param.name}`,
                    element: param.name,
                    severity: 'error',
                });
            }
            parameterNames.add(param.name);
            // 파라미터명 명명 규칙 검증
            if (!/^[A-Z][A-Z0-9_]*$/.test(param.name)) {
                warnings.push({
                    rule: 'PARAMETER_NAME_CONVENTION',
                    message: `파라미터명 '${param.name}'이 SAP 명명 규칙을 따르지 않습니다.`,
                    element: param.name,
                    severity: 'warning',
                });
            }
        }
        // 테이블 파라미터 검증
        for (const table of schema.content.tables) {
            if (!table.structure || table.structure.fields.length === 0) {
                warnings.push({
                    rule: 'TABLE_STRUCTURE_EMPTY',
                    message: `테이블 '${table.name}'의 구조가 정의되지 않았습니다.`,
                    element: table.name,
                    severity: 'warning',
                });
            }
        }
        // 예외 검증
        const exceptionNames = new Set();
        for (const exception of schema.content.exceptions) {
            if (exceptionNames.has(exception.name)) {
                errors.push({
                    rule: 'DUPLICATE_EXCEPTION_NAME',
                    message: `중복된 예외명: ${exception.name}`,
                    element: exception.name,
                    severity: 'error',
                });
            }
            exceptionNames.add(exception.name);
        }
        return {
            isValid: errors.length === 0,
            errors,
            warnings: warnings.filter(w => w.severity === 'warning'),
            summary: {
                totalRules: 6,
                passedRules: 6 - errors.length - warnings.length,
                failedRules: errors.length,
                warningRules: warnings.length,
            },
        };
    }
    getMetadata(schema) {
        return {
            version: schema.version,
            namespace: schema.metadata.namespace,
            systemInfo: {
                release: '1.0',
                version: schema.version,
            },
            createdAt: schema.createdAt,
            parsedAt: new Date(),
        };
    }
    generateId() {
        return `rfc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    countElements(content) {
        return (content.importing.length +
            content.exporting.length +
            content.changing.length +
            content.tables.length +
            content.exceptions.length);
    }
}
