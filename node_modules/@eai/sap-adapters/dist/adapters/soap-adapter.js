// SAP PI/PO WSDL 확장 처리 어댑터
import { WSDLParser } from '@eai/schema-parser/parsers/wsdl-parser';
export var SAPQualityOfService;
(function (SAPQualityOfService) {
    SAPQualityOfService["EXACTLY_ONCE"] = "ExactlyOnce";
    SAPQualityOfService["EXACTLY_ONCE_IN_ORDER"] = "ExactlyOnceInOrder";
    SAPQualityOfService["BEST_EFFORT"] = "BestEffort";
})(SAPQualityOfService || (SAPQualityOfService = {}));
export class SOAPAdapter {
    wsdlParser;
    constructor() {
        this.wsdlParser = new WSDLParser();
    }
    async parse(content, options = {}) {
        const startTime = Date.now();
        const errors = [];
        const warnings = [];
        try {
            // 기본 WSDL 파싱
            const wsdlResult = await this.wsdlParser.parse(content);
            // SAP PI/PO 확장 요소 추출
            const sapExtensions = await this.extractSAPExtensions(content, options);
            const metadata = {
                version: wsdlResult.schema.version,
                namespace: wsdlResult.schema.metadata.targetNamespace,
                systemInfo: {
                    release: 'PI/PO',
                    version: '7.5',
                },
                createdAt: new Date(),
                parsedAt: new Date(),
            };
            const processingTime = Date.now() - startTime;
            // SAP SOAP 스키마로 확장
            const result = {
                ...wsdlResult.schema,
                type: 'SAP_SOAP',
                sapExtensions,
            };
            // 기존 에러와 경고를 SAP 형식으로 변환 (임시로 주석 처리)
            // if (wsdlResult.errors) {
            //   errors.push(...wsdlResult.errors.map((err: any) => ({
            //     code: err.code,
            //     message: err.message,
            //     line: err.line,
            //     column: err.column,
            //     element: err.element,
            //     severity: 'error' as const,
            //   })));
            // }
            // if (wsdlResult.warnings) {
            //   warnings.push(...wsdlResult.warnings.map((warn: any) => ({
            //     code: warn.code,
            //     message: warn.message,
            //     line: warn.line,
            //     column: warn.column,
            //     element: warn.element,
            //     severity: 'warning' as const,
            //   })));
            // }
            return {
                schema: result,
                metadata,
                errors,
                warnings: warnings.filter(w => w.severity === 'warning'),
                statistics: {
                    totalElements: this.countElements(result),
                    parsedElements: this.countElements(result) - errors.length,
                    errorCount: errors.length,
                    warningCount: warnings.length,
                    processingTime,
                },
            };
        }
        catch (error) {
            errors.push({
                code: 'SAP_SOAP_PARSE_ERROR',
                message: error instanceof Error ? error.message : '알 수 없는 SAP SOAP 파싱 오류',
                severity: 'error',
            });
            throw error;
        }
    }
    async extractSAPExtensions(content, options) {
        const extensions = {};
        try {
            // SAP PI/PO 네임스페이스 추출
            const piNamespaceMatch = content.match(/xmlns:sap[^=]*="([^"]*sap[^"]*)"/i);
            if (piNamespaceMatch) {
                extensions.piNamespace = piNamespaceMatch[1];
            }
            // 메시지 타입 추출
            const messageTypeMatch = content.match(/<sap:MessageType[^>]*>([^<]*)</i);
            if (messageTypeMatch) {
                extensions.messageType = messageTypeMatch[1];
            }
            // 인터페이스 정보 추출
            const interfaceMatch = content.match(/<sap:Interface[^>]*name="([^"]*)"[^>]*namespace="([^"]*)"/i);
            if (interfaceMatch) {
                extensions.interfaceName = interfaceMatch[1];
                extensions.interfaceNamespace = interfaceMatch[2];
            }
            // 서비스 정보 추출
            const senderServiceMatch = content.match(/<sap:SenderService[^>]*>([^<]*)</i);
            if (senderServiceMatch) {
                extensions.senderService = senderServiceMatch[1];
            }
            const receiverServiceMatch = content.match(/<sap:ReceiverService[^>]*>([^<]*)</i);
            if (receiverServiceMatch) {
                extensions.receiverService = receiverServiceMatch[1];
            }
            // 파티 정보 추출
            const senderPartyMatch = content.match(/<sap:SenderParty[^>]*>([^<]*)</i);
            if (senderPartyMatch) {
                extensions.senderParty = senderPartyMatch[1];
            }
            const receiverPartyMatch = content.match(/<sap:ReceiverParty[^>]*>([^<]*)</i);
            if (receiverPartyMatch) {
                extensions.receiverParty = receiverPartyMatch[1];
            }
            // QoS 추출
            const qosMatch = content.match(/<sap:QualityOfService[^>]*>([^<]*)</i);
            if (qosMatch) {
                extensions.qualityOfService = this.parseQualityOfService(qosMatch[1]);
            }
            // 메시지 프로토콜 추출
            const protocolMatch = content.match(/<sap:MessageProtocol[^>]*>([^<]*)</i);
            if (protocolMatch) {
                extensions.messageProtocol = protocolMatch[1];
            }
            // 어댑터 타입 추출
            const adapterMatch = content.match(/<sap:AdapterType[^>]*>([^<]*)</i);
            if (adapterMatch) {
                extensions.adapterType = adapterMatch[1];
            }
            // 라우팅 규칙 추출
            extensions.routingRules = this.extractRoutingRules(content);
            // 변환 규칙 추출
            extensions.transformationRules = this.extractTransformationRules(content);
            // 에러 처리 설정 추출
            extensions.errorHandling = this.extractErrorHandling(content);
        }
        catch (error) {
            // SAP 확장 추출 실패는 경고로 처리
            console.warn('SAP 확장 요소 추출 중 오류:', error);
        }
        return extensions;
    }
    parseQualityOfService(qos) {
        switch (qos.toLowerCase()) {
            case 'exactlyonce':
                return SAPQualityOfService.EXACTLY_ONCE;
            case 'exactlyonceinorder':
                return SAPQualityOfService.EXACTLY_ONCE_IN_ORDER;
            case 'besteffort':
                return SAPQualityOfService.BEST_EFFORT;
            default:
                return SAPQualityOfService.BEST_EFFORT;
        }
    }
    extractRoutingRules(content) {
        const rules = [];
        const routingRegex = /<sap:RoutingRule[^>]*condition="([^"]*)"[^>]*receiver="([^"]*)"/gi;
        let match;
        while ((match = routingRegex.exec(content)) !== null) {
            rules.push({
                condition: match[1],
                receiver: match[2],
            });
        }
        return rules;
    }
    extractTransformationRules(content) {
        const rules = [];
        const transformRegex = /<sap:TransformationRule[^>]*name="([^"]*)"[^>]*type="([^"]*)"[^>]*source="([^"]*)"[^>]*target="([^"]*)"/gi;
        let match;
        while ((match = transformRegex.exec(content)) !== null) {
            rules.push({
                name: match[1],
                type: match[2],
                source: match[3],
                target: match[4],
            });
        }
        return rules;
    }
    extractErrorHandling(content) {
        const errorHandlingMatch = content.match(/<sap:ErrorHandling[^>]*strategy="([^"]*)"[^>]*>/i);
        if (!errorHandlingMatch)
            return undefined;
        const strategy = errorHandlingMatch[1];
        const maxRetriesMatch = content.match(/maxRetries="(\d+)"/i);
        const retryIntervalMatch = content.match(/retryInterval="(\d+)"/i);
        const errorQueueMatch = content.match(/errorQueue="([^"]*)"/i);
        return {
            strategy,
            maxRetries: maxRetriesMatch ? parseInt(maxRetriesMatch[1]) : undefined,
            retryInterval: retryIntervalMatch ? parseInt(retryIntervalMatch[1]) : undefined,
            errorQueue: errorQueueMatch ? errorQueueMatch[1] : undefined,
        };
    }
    async validate(schema) {
        const errors = [];
        const warnings = [];
        // 기본 WSDL 검증 (임시로 주석 처리)
        // const wsdlValidation = await this.wsdlParser.validate(schema);
        // WSDL 검증 결과를 SAP 형식으로 변환
        // errors.push(...wsdlValidation.errors.map((err: any) => ({
        //   rule: err.rule,
        //   message: err.message,
        //   element: err.element,
        //   path: err.path,
        //   severity: 'error' as const,
        // })));
        // warnings.push(...wsdlValidation.warnings.map((warn: any) => ({
        //   rule: warn.rule,
        //   message: warn.message,
        //   element: warn.element,
        //   path: warn.path,
        //   severity: 'warning' as const,
        // })));
        // SAP 특화 검증
        if (!schema.sapExtensions.piNamespace) {
            warnings.push({
                rule: 'SAP_PI_NAMESPACE_MISSING',
                message: 'SAP PI/PO 네임스페이스가 정의되지 않았습니다.',
                severity: 'warning',
            });
        }
        if (!schema.sapExtensions.messageType) {
            warnings.push({
                rule: 'SAP_MESSAGE_TYPE_MISSING',
                message: 'SAP 메시지 타입이 정의되지 않았습니다.',
                severity: 'warning',
            });
        }
        if (!schema.sapExtensions.interfaceName) {
            warnings.push({
                rule: 'SAP_INTERFACE_NAME_MISSING',
                message: 'SAP 인터페이스명이 정의되지 않았습니다.',
                severity: 'warning',
            });
        }
        // QoS 검증
        if (schema.sapExtensions.qualityOfService === SAPQualityOfService.EXACTLY_ONCE_IN_ORDER &&
            !schema.sapExtensions.routingRules?.length) {
            warnings.push({
                rule: 'SAP_QOS_ROUTING_MISMATCH',
                message: 'ExactlyOnceInOrder QoS에는 라우팅 규칙이 필요합니다.',
                severity: 'warning',
            });
        }
        // 변환 규칙 검증
        for (const rule of schema.sapExtensions.transformationRules || []) {
            if (!rule.source || !rule.target) {
                errors.push({
                    rule: 'SAP_TRANSFORMATION_RULE_INCOMPLETE',
                    message: `변환 규칙 '${rule.name}'에 소스 또는 타겟이 누락되었습니다.`,
                    element: rule.name,
                    severity: 'error',
                });
            }
        }
        // 에러 처리 검증
        if (schema.sapExtensions.errorHandling?.strategy === 'Retry' &&
            !schema.sapExtensions.errorHandling.maxRetries) {
            warnings.push({
                rule: 'SAP_RETRY_CONFIG_INCOMPLETE',
                message: 'Retry 전략에 최대 재시도 횟수가 설정되지 않았습니다.',
                severity: 'warning',
            });
        }
        return {
            isValid: errors.length === 0,
            errors,
            warnings: warnings.filter(w => w.severity === 'warning'),
            summary: {
                totalRules: 7,
                passedRules: 7 - errors.length - warnings.length,
                failedRules: errors.length,
                warningRules: warnings.length,
            },
        };
    }
    getMetadata(schema) {
        return {
            version: schema.version,
            namespace: schema.metadata.targetNamespace,
            systemInfo: {
                release: 'PI/PO',
                version: schema.version,
            },
            createdAt: schema.createdAt,
            parsedAt: new Date(),
        };
    }
    countElements(schema) {
        const baseCount = (schema.content.services.length +
            schema.content.bindings.length +
            schema.content.portTypes.length +
            schema.content.messages.length +
            (schema.content.types ? Object.keys(schema.content.types).length : 0));
        const sapExtensionCount = ((schema.sapExtensions.routingRules?.length || 0) +
            (schema.sapExtensions.transformationRules?.length || 0) +
            (schema.sapExtensions.errorHandling ? 1 : 0));
        return baseCount + sapExtensionCount;
    }
}
