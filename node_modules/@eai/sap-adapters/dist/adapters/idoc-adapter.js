// SAP IDoc 구조 파싱 어댑터
import { XMLParser } from 'fast-xml-parser';
import { SegmentStatus, } from '@eai/shared/types/sap';
import { SchemaType } from '@eai/shared/types';
export class IDocAdapter {
    xmlParser;
    constructor() {
        this.xmlParser = new XMLParser({
            ignoreAttributes: false,
            attributeNamePrefix: '@_',
            textNodeName: '#text',
            parseAttributeValue: true,
            trimValues: true,
            parseTagValue: false,
        });
    }
    async parse(content, options = {}) {
        const startTime = Date.now();
        const errors = [];
        const warnings = [];
        try {
            // IDoc 형식 감지 (XML 또는 플랫 파일)
            const isXML = content.trim().startsWith('<');
            let parsedContent;
            if (isXML) {
                parsedContent = await this.parseXMLIDoc(content, options);
            }
            else {
                parsedContent = await this.parseFlatFileIDoc(content, options);
            }
            const metadata = {
                version: '1.0',
                createdAt: new Date(),
                parsedAt: new Date(),
            };
            const processingTime = Date.now() - startTime;
            const result = {
                id: this.generateId(),
                name: parsedContent.idocType,
                version: parsedContent.release,
                type: SchemaType.SAP_IDOC,
                originalFormat: isXML ? 'XML' : 'FLAT',
                metadata: {
                    namespace: `SAP.IDoc.${parsedContent.idocType}`,
                    targetNamespace: `SAP.IDoc.${parsedContent.idocType}`,
                    imports: [],
                    annotations: [],
                },
                content: parsedContent,
                createdAt: metadata.createdAt,
                updatedAt: metadata.parsedAt,
            };
            return {
                schema: result,
                metadata,
                errors,
                warnings: warnings.filter(w => w.severity === 'warning'),
                statistics: {
                    totalElements: this.countElements(parsedContent),
                    parsedElements: this.countElements(parsedContent) - errors.length,
                    errorCount: errors.length,
                    warningCount: warnings.length,
                    processingTime,
                },
            };
        }
        catch (error) {
            errors.push({
                code: 'IDOC_PARSE_ERROR',
                message: error instanceof Error ? error.message : '알 수 없는 IDoc 파싱 오류',
                severity: 'error',
            });
            throw error;
        }
    }
    async parseXMLIDoc(content, options) {
        const xmlData = this.xmlParser.parse(content);
        // IDoc 루트 요소 찾기
        const idocRoot = xmlData.IDOC || xmlData.idoc || xmlData.IDoc;
        if (!idocRoot) {
            throw new Error('유효하지 않은 IDoc XML: 루트 요소를 찾을 수 없습니다.');
        }
        // 컨트롤 레코드 파싱
        const controlRecord = this.parseControlRecord(idocRoot.EDI_DC40 || idocRoot.EDI_DC);
        // 데이터 레코드 파싱
        const dataRecords = this.parseDataRecords(idocRoot);
        // 세그먼트 구조 파싱
        const segments = await this.parseSegments(idocRoot, options);
        // 계층 구조 생성
        const hierarchy = this.buildHierarchy(segments);
        return {
            idocType: controlRecord.idoctyp,
            release: controlRecord.docrel,
            segments,
            hierarchy,
            controlRecord,
            dataRecords,
        };
    }
    async parseFlatFileIDoc(content, options) {
        const lines = content.split('\n').filter(line => line.trim());
        if (lines.length === 0) {
            throw new Error('빈 IDoc 파일입니다.');
        }
        // 첫 번째 라인은 컨트롤 레코드
        const controlLine = lines[0];
        const controlRecord = this.parseControlRecordFromFlat(controlLine);
        // 나머지 라인들은 데이터 레코드
        const dataRecords = lines.slice(1).map((line, index) => this.parseDataRecordFromFlat(line, index + 2));
        // 세그먼트 구조 추출
        const segments = await this.extractSegmentsFromDataRecords(dataRecords, options);
        // 계층 구조 생성
        const hierarchy = this.buildHierarchy(segments);
        return {
            idocType: controlRecord.idoctyp,
            release: controlRecord.docrel,
            segments,
            hierarchy,
            controlRecord,
            dataRecords,
        };
    }
    parseControlRecord(controlData) {
        return {
            tabnam: controlData['@_TABNAM'] || controlData.TABNAM || 'EDI_DC40',
            mandt: controlData['@_MANDT'] || controlData.MANDT || '',
            docnum: controlData['@_DOCNUM'] || controlData.DOCNUM || '',
            docrel: controlData['@_DOCREL'] || controlData.DOCREL || '',
            status: controlData['@_STATUS'] || controlData.STATUS || '',
            direct: controlData['@_DIRECT'] || controlData.DIRECT || '',
            outmod: controlData['@_OUTMOD'] || controlData.OUTMOD || '',
            idoctyp: controlData['@_IDOCTYP'] || controlData.IDOCTYP || '',
            mestyp: controlData['@_MESTYP'] || controlData.MESTYP || '',
            sndpor: controlData['@_SNDPOR'] || controlData.SNDPOR || '',
            sndprt: controlData['@_SNDPRT'] || controlData.SNDPRT || '',
            sndprn: controlData['@_SNDPRN'] || controlData.SNDPRN || '',
            rcvpor: controlData['@_RCVPOR'] || controlData.RCVPOR || '',
            rcvprt: controlData['@_RCVPRT'] || controlData.RCVPRT || '',
            rcvprn: controlData['@_RCVPRN'] || controlData.RCVPRN || '',
        };
    }
    parseControlRecordFromFlat(line) {
        // IDoc 플랫 파일 형식: 고정 길이 필드
        // 예: EDI_DC40800000000000001...
        if (line.length < 100) {
            throw new Error('유효하지 않은 컨트롤 레코드 형식입니다.');
        }
        return {
            tabnam: line.substring(0, 10).trim(),
            mandt: line.substring(10, 13).trim(),
            docnum: line.substring(13, 29).trim(),
            docrel: line.substring(29, 33).trim(),
            status: line.substring(33, 35).trim(),
            direct: line.substring(35, 36).trim(),
            outmod: line.substring(36, 37).trim(),
            idoctyp: line.substring(37, 67).trim(),
            mestyp: line.substring(67, 97).trim(),
            sndpor: line.substring(97, 127).trim(),
            sndprt: line.substring(127, 129).trim(),
            sndprn: line.substring(129, 159).trim(),
            rcvpor: line.substring(159, 189).trim(),
            rcvprt: line.substring(189, 191).trim(),
            rcvprn: line.substring(191, 221).trim(),
        };
    }
    parseDataRecords(idocRoot) {
        const dataRecords = [];
        // XML에서 모든 세그먼트 데이터 추출
        this.extractDataRecordsRecursive(idocRoot, dataRecords);
        return dataRecords;
    }
    extractDataRecordsRecursive(node, dataRecords, level = 0) {
        if (typeof node !== 'object' || node === null)
            return;
        for (const [key, value] of Object.entries(node)) {
            if (key.startsWith('@_') || key === '#text')
                continue;
            if (Array.isArray(value)) {
                value.forEach((item, index) => {
                    if (typeof item === 'object' && item !== null) {
                        dataRecords.push({
                            segnam: key,
                            mandt: '',
                            docnum: '',
                            segnum: (dataRecords.length + 1).toString().padStart(6, '0'),
                            psgnum: '000000',
                            hlevel: level.toString().padStart(2, '0'),
                            sdata: JSON.stringify(item),
                        });
                        this.extractDataRecordsRecursive(item, dataRecords, level + 1);
                    }
                });
            }
            else if (typeof value === 'object' && value !== null) {
                dataRecords.push({
                    segnam: key,
                    mandt: '',
                    docnum: '',
                    segnum: (dataRecords.length + 1).toString().padStart(6, '0'),
                    psgnum: '000000',
                    hlevel: level.toString().padStart(2, '0'),
                    sdata: JSON.stringify(value),
                });
                this.extractDataRecordsRecursive(value, dataRecords, level + 1);
            }
        }
    }
    parseDataRecordFromFlat(line, lineNumber) {
        if (line.length < 60) {
            throw new Error(`라인 ${lineNumber}: 유효하지 않은 데이터 레코드 형식입니다.`);
        }
        return {
            segnam: line.substring(0, 27).trim(),
            mandt: line.substring(27, 30).trim(),
            docnum: line.substring(30, 46).trim(),
            segnum: line.substring(46, 52).trim(),
            psgnum: line.substring(52, 58).trim(),
            hlevel: line.substring(58, 60).trim(),
            sdata: line.substring(60).trim(),
        };
    }
    async parseSegments(idocRoot, options) {
        const segments = [];
        // 세그먼트 정의 추출 (실제 구현에서는 SAP 시스템에서 메타데이터를 가져와야 함)
        await this.extractSegmentsRecursive(idocRoot, segments, 0);
        return segments;
    }
    async extractSegmentsRecursive(node, segments, level, parent) {
        if (typeof node !== 'object' || node === null)
            return;
        for (const [key, value] of Object.entries(node)) {
            if (key.startsWith('@_') || key === '#text')
                continue;
            // 세그먼트로 간주되는 키 (대문자로 시작하고 특정 패턴)
            if (this.isSegmentKey(key)) {
                const segment = {
                    name: key,
                    definition: `세그먼트 ${key}`,
                    level,
                    status: this.determineSegmentStatus(key),
                    fields: await this.extractFieldsFromSegment(value),
                    children: [],
                    parent,
                    minOccurs: 0,
                    maxOccurs: Array.isArray(value) ? value.length : 1,
                };
                segments.push(segment);
                // 자식 세그먼트 처리
                if (Array.isArray(value)) {
                    for (const item of value) {
                        await this.extractSegmentsRecursive(item, segments, level + 1, key);
                    }
                }
                else {
                    await this.extractSegmentsRecursive(value, segments, level + 1, key);
                }
            }
        }
    }
    async extractSegmentsFromDataRecords(dataRecords, options) {
        const segmentMap = new Map();
        for (const record of dataRecords) {
            if (!segmentMap.has(record.segnam)) {
                const segment = {
                    name: record.segnam,
                    definition: `세그먼트 ${record.segnam}`,
                    level: parseInt(record.hlevel),
                    status: this.determineSegmentStatus(record.segnam),
                    fields: await this.extractFieldsFromData(record.sdata),
                    children: [],
                    minOccurs: 0,
                    maxOccurs: 1,
                };
                segmentMap.set(record.segnam, segment);
            }
        }
        return Array.from(segmentMap.values());
    }
    isSegmentKey(key) {
        // SAP IDoc 세그먼트 명명 규칙
        return /^[A-Z][A-Z0-9_]{2,}$/.test(key) && key !== 'EDI_DC40' && key !== 'EDI_DC';
    }
    determineSegmentStatus(segmentName) {
        // 실제 구현에서는 SAP 메타데이터에서 가져와야 함
        // 여기서는 기본값으로 설정
        if (segmentName.includes('HDR') || segmentName.includes('HEADER')) {
            return SegmentStatus.MANDATORY;
        }
        else if (segmentName.includes('ITM') || segmentName.includes('ITEM')) {
            return SegmentStatus.CONDITIONAL;
        }
        return SegmentStatus.OPTIONAL;
    }
    async extractFieldsFromSegment(segmentData) {
        const fields = [];
        if (typeof segmentData !== 'object' || segmentData === null) {
            return fields;
        }
        let position = 1;
        for (const [key, value] of Object.entries(segmentData)) {
            if (key.startsWith('@_') || key === '#text')
                continue;
            fields.push({
                name: key,
                dataElement: key.toUpperCase(),
                dataType: this.inferDataType(value),
                length: this.inferLength(value),
                position: position++,
                description: `필드 ${key}`,
                constraints: [],
            });
        }
        return fields;
    }
    async extractFieldsFromData(sdata) {
        try {
            const data = JSON.parse(sdata);
            return this.extractFieldsFromSegment(data);
        }
        catch {
            // JSON 파싱 실패 시 플랫 데이터로 처리
            return [{
                    name: 'DATA',
                    dataElement: 'CHAR',
                    dataType: 'CHAR',
                    length: sdata.length,
                    position: 1,
                    description: '세그먼트 데이터',
                    constraints: [],
                }];
        }
    }
    inferDataType(value) {
        if (typeof value === 'number') {
            return Number.isInteger(value) ? 'INT' : 'DEC';
        }
        else if (typeof value === 'boolean') {
            return 'CHAR';
        }
        else if (typeof value === 'string') {
            // 날짜 형식 확인
            if (/^\d{4}-\d{2}-\d{2}/.test(value)) {
                return 'DATS';
            }
            else if (/^\d{2}:\d{2}:\d{2}/.test(value)) {
                return 'TIMS';
            }
            return 'CHAR';
        }
        return 'CHAR';
    }
    inferLength(value) {
        if (typeof value === 'string') {
            return value.length || 1;
        }
        else if (typeof value === 'number') {
            return value.toString().length;
        }
        return 1;
    }
    buildHierarchy(segments) {
        const levelMap = new Map();
        let rootSegment = '';
        for (const segment of segments) {
            if (!levelMap.has(segment.level)) {
                levelMap.set(segment.level, []);
            }
            levelMap.get(segment.level).push(segment.name);
            if (segment.level === 0 || (segment.level === 1 && !rootSegment)) {
                rootSegment = segment.name;
            }
        }
        const levels = Array.from(levelMap.entries())
            .sort(([a], [b]) => a - b)
            .map(([level, segmentNames]) => ({
            level,
            segments: segmentNames,
        }));
        return {
            root: rootSegment,
            levels,
        };
    }
    async validate(schema) {
        const errors = [];
        const warnings = [];
        // IDoc 타입 검증
        if (!schema.content.idocType) {
            errors.push({
                rule: 'IDOC_TYPE_REQUIRED',
                message: 'IDoc 타입이 필요합니다.',
                severity: 'error',
            });
        }
        // 컨트롤 레코드 검증
        if (!schema.content.controlRecord.docnum) {
            warnings.push({
                rule: 'DOCUMENT_NUMBER_MISSING',
                message: '문서 번호가 누락되었습니다.',
                severity: 'warning',
            });
        }
        // 세그먼트 계층 구조 검증
        if (!schema.content.hierarchy.root) {
            errors.push({
                rule: 'ROOT_SEGMENT_MISSING',
                message: '루트 세그먼트가 정의되지 않았습니다.',
                severity: 'error',
            });
        }
        // 필수 세그먼트 검증
        const mandatorySegments = schema.content.segments.filter(s => s.status === SegmentStatus.MANDATORY);
        if (mandatorySegments.length === 0) {
            warnings.push({
                rule: 'NO_MANDATORY_SEGMENTS',
                message: '필수 세그먼트가 정의되지 않았습니다.',
                severity: 'warning',
            });
        }
        return {
            isValid: errors.length === 0,
            errors,
            warnings: warnings.filter(w => w.severity === 'warning'),
            summary: {
                totalRules: 4,
                passedRules: 4 - errors.length - warnings.length,
                failedRules: errors.length,
                warningRules: warnings.length,
            },
        };
    }
    getMetadata(schema) {
        return {
            version: schema.version,
            namespace: schema.metadata.namespace,
            systemInfo: {
                release: schema.content.release,
                version: schema.version,
            },
            createdAt: schema.createdAt,
            parsedAt: new Date(),
        };
    }
    generateId() {
        return `idoc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    countElements(content) {
        return content.segments.length + content.dataRecords.length;
    }
}
