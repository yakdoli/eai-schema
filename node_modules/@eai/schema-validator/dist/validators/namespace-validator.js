/**
 * 네임스페이스 충돌 검증기
 */
export class NamespaceValidator {
    namespaceDeclarations = new Map();
    prefixMappings = new Map();
    elementDeclarations = new Map();
    /**
     * 스키마의 네임스페이스 충돌을 검증합니다
     */
    async validateNamespaces(schema) {
        // 초기화
        this.namespaceDeclarations.clear();
        this.prefixMappings.clear();
        this.elementDeclarations.clear();
        // 네임스페이스 정보 수집
        this.collectNamespaceInfo(schema);
        // 충돌 검증 수행
        const conflicts = this.findNamespaceConflicts();
        const duplicateDeclarations = this.findDuplicateDeclarations();
        const ambiguousReferences = this.findAmbiguousReferences(schema);
        return {
            conflicts,
            duplicateDeclarations,
            ambiguousReferences
        };
    }
    /**
     * 네임스페이스 정보를 수집합니다
     */
    collectNamespaceInfo(schema) {
        // 메타데이터에서 네임스페이스 정보 수집
        if (schema.metadata) {
            // 타겟 네임스페이스
            if (schema.metadata.targetNamespace) {
                this.addNamespaceDeclaration(schema.metadata.targetNamespace, 'targetNamespace', { path: 'schema.metadata.targetNamespace' });
            }
            // 기본 네임스페이스
            if (schema.metadata.namespace) {
                this.addNamespaceDeclaration(schema.metadata.namespace, 'defaultNamespace', { path: 'schema.metadata.namespace' });
            }
            // 임포트된 네임스페이스
            if (schema.metadata.imports) {
                schema.metadata.imports.forEach((importRef, index) => {
                    if (importRef.namespace) {
                        this.addNamespaceDeclaration(importRef.namespace, 'import', { path: `schema.metadata.imports[${index}].namespace` });
                    }
                });
            }
        }
        // 엔티티에서 네임스페이스 정보 수집
        this.collectEntityNamespaces(schema);
        // 타입에서 네임스페이스 정보 수집
        this.collectTypeNamespaces(schema);
        // 오퍼레이션에서 네임스페이스 정보 수집
        this.collectOperationNamespaces(schema);
    }
    /**
     * 엔티티에서 네임스페이스 정보를 수집합니다
     */
    collectEntityNamespaces(schema) {
        if (schema.content?.entities) {
            schema.content.entities.forEach((entity, entityIndex) => {
                // 엔티티 이름 등록
                this.addElementDeclaration(entity.name, entity.namespace || schema.metadata?.targetNamespace || '', { path: `schema.content.entities[${entityIndex}].name`, element: entity.name });
                // 속성에서 네임스페이스 참조 수집
                if (entity.properties) {
                    entity.properties.forEach((property, propIndex) => {
                        if (property.type && this.hasNamespacePrefix(property.type)) {
                            const prefix = this.extractPrefix(property.type);
                            this.addPrefixMapping(prefix, property.type);
                        }
                    });
                }
            });
        }
    }
    /**
     * 타입에서 네임스페이스 정보를 수집합니다
     */
    collectTypeNamespaces(schema) {
        if (schema.content?.types) {
            schema.content.types.forEach((type, typeIndex) => {
                // 타입 이름 등록
                this.addElementDeclaration(type.name, schema.metadata?.targetNamespace || '', { path: `schema.content.types[${typeIndex}].name`, element: type.name });
                // 기본 타입에서 네임스페이스 참조 수집
                if (type.baseType && this.hasNamespacePrefix(type.baseType)) {
                    const prefix = this.extractPrefix(type.baseType);
                    this.addPrefixMapping(prefix, type.baseType);
                }
            });
        }
    }
    /**
     * 오퍼레이션에서 네임스페이스 정보를 수집합니다
     */
    collectOperationNamespaces(schema) {
        if (schema.content?.operations) {
            schema.content.operations.forEach((operation, opIndex) => {
                // 오퍼레이션 이름 등록
                this.addElementDeclaration(operation.name, schema.metadata?.targetNamespace || '', { path: `schema.content.operations[${opIndex}].name`, element: operation.name });
            });
        }
    }
    /**
     * 네임스페이스 선언을 추가합니다
     */
    addNamespaceDeclaration(namespace, definition, location) {
        if (!this.namespaceDeclarations.has(namespace)) {
            this.namespaceDeclarations.set(namespace, []);
        }
        this.namespaceDeclarations.get(namespace)?.push({
            name: namespace,
            location,
            definition
        });
    }
    /**
     * 요소 선언을 추가합니다
     */
    addElementDeclaration(name, namespace, location) {
        const fullName = namespace ? `${namespace}:${name}` : name;
        if (!this.elementDeclarations.has(fullName)) {
            this.elementDeclarations.set(fullName, []);
        }
        this.elementDeclarations.get(fullName)?.push({
            name,
            location,
            definition: `${namespace}:${name}`
        });
    }
    /**
     * 프리픽스 매핑을 추가합니다
     */
    addPrefixMapping(prefix, fullType) {
        if (!this.prefixMappings.has(prefix)) {
            this.prefixMappings.set(prefix, []);
        }
        if (!this.prefixMappings.get(prefix)?.includes(fullType)) {
            this.prefixMappings.get(prefix)?.push(fullType);
        }
    }
    /**
     * 네임스페이스 충돌을 찾습니다
     */
    findNamespaceConflicts() {
        const conflicts = [];
        // 동일한 네임스페이스에 대한 중복 선언 검사
        for (const [namespace, declarations] of this.namespaceDeclarations) {
            if (declarations.length > 1) {
                // 서로 다른 정의를 가진 중복 선언인지 확인
                const uniqueDefinitions = new Set(declarations.map(d => d.definition));
                if (uniqueDefinitions.size > 1) {
                    conflicts.push({
                        namespace,
                        conflictingElements: declarations,
                        conflictType: 'declaration'
                    });
                }
            }
        }
        // 프리픽스 충돌 검사
        for (const [prefix, types] of this.prefixMappings) {
            const namespaces = new Set(types.map(type => this.extractNamespaceFromType(type)));
            if (namespaces.size > 1) {
                conflicts.push({
                    namespace: prefix,
                    conflictingElements: types.map(type => ({
                        name: type,
                        location: { path: 'unknown' }, // 실제 구현에서는 정확한 위치 추적 필요
                        definition: type
                    })),
                    conflictType: 'prefix'
                });
            }
        }
        return conflicts;
    }
    /**
     * 중복 선언을 찾습니다
     */
    findDuplicateDeclarations() {
        const duplicates = [];
        for (const [fullName, declarations] of this.elementDeclarations) {
            if (declarations.length > 1) {
                const [namespace, elementName] = this.splitFullName(fullName);
                duplicates.push({
                    elementName,
                    namespace,
                    locations: declarations.map(d => d.location)
                });
            }
        }
        return duplicates;
    }
    /**
     * 모호한 참조를 찾습니다
     */
    findAmbiguousReferences(schema) {
        const ambiguousReferences = [];
        // 엔티티 속성에서 모호한 타입 참조 검사
        if (schema.content?.entities) {
            schema.content.entities.forEach((entity, entityIndex) => {
                if (entity.properties) {
                    entity.properties.forEach((property, propIndex) => {
                        if (property.type && !this.hasNamespacePrefix(property.type)) {
                            // 네임스페이스 없는 참조가 여러 네임스페이스에서 정의된 경우
                            const possibleTargets = this.findPossibleTargets(property.type);
                            if (possibleTargets.length > 1) {
                                ambiguousReferences.push({
                                    reference: property.type,
                                    possibleTargets,
                                    location: {
                                        path: `schema.content.entities[${entityIndex}].properties[${propIndex}].type`,
                                        element: property.name
                                    }
                                });
                            }
                        }
                    });
                }
            });
        }
        return ambiguousReferences;
    }
    /**
     * 가능한 타겟들을 찾습니다
     */
    findPossibleTargets(elementName) {
        const targets = [];
        for (const [fullName] of this.elementDeclarations) {
            const [, name] = this.splitFullName(fullName);
            if (name === elementName) {
                targets.push(fullName);
            }
        }
        return targets;
    }
    /**
     * 네임스페이스 프리픽스가 있는지 확인합니다
     */
    hasNamespacePrefix(typeName) {
        return typeName.includes(':');
    }
    /**
     * 타입 이름에서 프리픽스를 추출합니다
     */
    extractPrefix(typeName) {
        const colonIndex = typeName.indexOf(':');
        return colonIndex > 0 ? typeName.substring(0, colonIndex) : '';
    }
    /**
     * 타입에서 네임스페이스를 추출합니다
     */
    extractNamespaceFromType(typeName) {
        const colonIndex = typeName.indexOf(':');
        return colonIndex > 0 ? typeName.substring(0, colonIndex) : '';
    }
    /**
     * 전체 이름을 네임스페이스와 요소 이름으로 분리합니다
     */
    splitFullName(fullName) {
        const colonIndex = fullName.indexOf(':');
        if (colonIndex > 0) {
            return [fullName.substring(0, colonIndex), fullName.substring(colonIndex + 1)];
        }
        return ['', fullName];
    }
}
