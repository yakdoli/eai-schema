/**
 * 참조 무결성 검증기
 */
export class ReferenceValidator {
    resolvedReferences = new Map();
    referenceGraph = new Map();
    /**
     * 스키마의 참조 무결성을 검증합니다
     */
    async validateReferences(schema) {
        // 참조 그래프 초기화
        this.resolvedReferences.clear();
        this.referenceGraph.clear();
        // 모든 정의된 요소들을 수집
        this.collectDefinedElements(schema);
        // 참조 검증 수행
        const missingReferences = this.findMissingReferences(schema);
        const circularReferences = this.findCircularReferences(schema);
        const unresolvedImports = this.findUnresolvedImports(schema);
        return {
            missingReferences,
            circularReferences,
            unresolvedImports
        };
    }
    /**
     * 정의된 모든 요소들을 수집합니다
     */
    collectDefinedElements(schema) {
        const namespace = schema.metadata?.targetNamespace || '';
        // 엔티티 정의 수집
        if (schema.content?.entities) {
            schema.content.entities.forEach(entity => {
                const fullName = namespace ? `${namespace}:${entity.name}` : entity.name;
                this.resolvedReferences.set(entity.name, fullName);
                this.resolvedReferences.set(fullName, fullName);
            });
        }
        // 타입 정의 수집
        if (schema.content?.types) {
            schema.content.types.forEach(type => {
                const fullName = namespace ? `${namespace}:${type.name}` : type.name;
                this.resolvedReferences.set(type.name, fullName);
                this.resolvedReferences.set(fullName, fullName);
            });
        }
        // 오퍼레이션 정의 수집
        if (schema.content?.operations) {
            schema.content.operations.forEach(operation => {
                const fullName = namespace ? `${namespace}:${operation.name}` : operation.name;
                this.resolvedReferences.set(operation.name, fullName);
                this.resolvedReferences.set(fullName, fullName);
            });
        }
    }
    /**
     * 누락된 참조를 찾습니다
     */
    findMissingReferences(schema) {
        const missingReferences = [];
        // 엔티티 참조 검증
        if (schema.content?.entities) {
            schema.content.entities.forEach((entity, entityIndex) => {
                // 속성 타입 참조 검증
                if (entity.properties) {
                    entity.properties.forEach((property, propIndex) => {
                        if (property.type && !this.isBuiltInType(property.type)) {
                            if (!this.resolvedReferences.has(property.type)) {
                                missingReferences.push({
                                    referencingElement: `${entity.name}.${property.name}`,
                                    referencingLocation: {
                                        path: `schema.content.entities[${entityIndex}].properties[${propIndex}].type`,
                                        element: property.name
                                    },
                                    targetReference: property.type,
                                    targetNamespace: this.extractNamespace(property.type)
                                });
                            }
                        }
                    });
                }
                // 관계 참조 검증
                if (entity.relationships) {
                    entity.relationships.forEach((relationship, relIndex) => {
                        if (relationship.targetEntity && !this.resolvedReferences.has(relationship.targetEntity)) {
                            missingReferences.push({
                                referencingElement: `${entity.name}.${relationship.name}`,
                                referencingLocation: {
                                    path: `schema.content.entities[${entityIndex}].relationships[${relIndex}].targetEntity`,
                                    element: relationship.name
                                },
                                targetReference: relationship.targetEntity,
                                targetNamespace: this.extractNamespace(relationship.targetEntity)
                            });
                        }
                    });
                }
            });
        }
        return missingReferences;
    }
    /**
      * 순환 참조를 찾습니다
      */
    findCircularReferences(schema) {
        const circularReferences = [];
        const visited = new Set();
        const recursionStack = new Set();
        // 참조 그래프 구축
        this.buildReferenceGraph(schema);
        // 각 노드에서 DFS를 수행하여 순환 참조 탐지
        for (const [node] of this.referenceGraph) {
            if (!visited.has(node)) {
                const cycle = this.detectCycleFromNode(node, visited, recursionStack, []);
                if (cycle.length > 0) {
                    circularReferences.push({
                        path: cycle.map(c => c.split(':').pop() || c),
                        elements: cycle
                    });
                }
            }
        }
        return circularReferences;
    }
    /**
     * 참조 그래프를 구축합니다
     */
    buildReferenceGraph(schema) {
        if (schema.content?.entities) {
            schema.content.entities.forEach(entity => {
                const entityName = entity.name;
                if (!this.referenceGraph.has(entityName)) {
                    this.referenceGraph.set(entityName, new Set());
                }
                // 속성 타입 참조 추가
                if (entity.properties) {
                    entity.properties.forEach(property => {
                        if (property.type && !this.isBuiltInType(property.type)) {
                            this.referenceGraph.get(entityName)?.add(property.type);
                        }
                    });
                }
                // 관계 참조 추가
                if (entity.relationships) {
                    entity.relationships.forEach(relationship => {
                        if (relationship.targetEntity) {
                            this.referenceGraph.get(entityName)?.add(relationship.targetEntity);
                        }
                    });
                }
            });
        }
        // 타입 정의 참조 그래프 구축
        if (schema.content?.types) {
            schema.content.types.forEach(type => {
                const typeName = type.name;
                if (!this.referenceGraph.has(typeName)) {
                    this.referenceGraph.set(typeName, new Set());
                }
                // 기본 타입 참조 추가
                if (type.baseType && !this.isBuiltInType(type.baseType)) {
                    this.referenceGraph.get(typeName)?.add(type.baseType);
                }
            });
        }
    }
    /**
     * 특정 노드에서 순환 참조를 탐지합니다
     */
    detectCycleFromNode(node, visited, recursionStack, path) {
        visited.add(node);
        recursionStack.add(node);
        path.push(node);
        const neighbors = this.referenceGraph.get(node) || new Set();
        for (const neighbor of neighbors) {
            if (!visited.has(neighbor)) {
                const cycle = this.detectCycleFromNode(neighbor, visited, recursionStack, [...path]);
                if (cycle.length > 0) {
                    return cycle;
                }
            }
            else if (recursionStack.has(neighbor)) {
                // 순환 참조 발견
                const cycleStartIndex = path.indexOf(neighbor);
                return path.slice(cycleStartIndex).concat([neighbor]);
            }
        }
        recursionStack.delete(node);
        return [];
    }
    /**
     * 해결되지 않은 임포트를 찾습니다
     */
    findUnresolvedImports(schema) {
        const unresolvedImports = [];
        if (schema.metadata?.imports) {
            schema.metadata.imports.forEach((importRef, index) => {
                // 임포트된 네임스페이스나 스키마가 실제로 사용 가능한지 확인
                if (!this.isImportResolved(importRef)) {
                    unresolvedImports.push({
                        importPath: importRef.location || importRef.namespace || '',
                        namespace: importRef.namespace,
                        location: {
                            path: `schema.metadata.imports[${index}]`,
                            element: importRef.namespace
                        },
                        reason: this.getImportFailureReason(importRef)
                    });
                }
            });
        }
        return unresolvedImports;
    }
    /**
     * 임포트가 해결되었는지 확인합니다
     */
    isImportResolved(importRef) {
        // 실제 구현에서는 임포트된 스키마를 로드하고 검증해야 합니다
        // 여기서는 기본적인 검증만 수행합니다
        return !!(importRef.namespace || importRef.location);
    }
    /**
     * 임포트 실패 이유를 반환합니다
     */
    getImportFailureReason(importRef) {
        if (!importRef.location && !importRef.namespace) {
            return '임포트 위치와 네임스페이스가 모두 누락되었습니다';
        }
        if (!importRef.location) {
            return '임포트 위치가 누락되었습니다';
        }
        if (!importRef.namespace) {
            return '임포트 네임스페이스가 누락되었습니다';
        }
        return '알 수 없는 임포트 오류';
    }
    /**
     * 내장 타입인지 확인합니다
     */
    isBuiltInType(type) {
        const builtInTypes = [
            'string', 'number', 'integer', 'boolean', 'array', 'object',
            'xs:string', 'xs:int', 'xs:integer', 'xs:decimal', 'xs:boolean',
            'xs:date', 'xs:dateTime', 'xs:time', 'xs:duration',
            'xsd:string', 'xsd:int', 'xsd:integer', 'xsd:decimal', 'xsd:boolean',
            'xsd:date', 'xsd:dateTime', 'xsd:time', 'xsd:duration'
        ];
        return builtInTypes.includes(type.toLowerCase());
    }
    /**
     * 타입 이름에서 네임스페이스를 추출합니다
     */
    extractNamespace(typeName) {
        const colonIndex = typeName.indexOf(':');
        return colonIndex > 0 ? typeName.substring(0, colonIndex) : undefined;
    }
}
