import { ValidationSeverity } from './types';
import { SyntaxValidator } from './validators/syntax-validator';
import { ReferenceValidator } from './validators/reference-validator';
import { NamespaceValidator } from './validators/namespace-validator';
import { TypeValidator } from './validators/type-validator';
import { ReportGenerator } from './generators/report-generator';
/**
 * 메인 스키마 검증 엔진
 */
export class SchemaValidator {
    syntaxValidator;
    referenceValidator;
    namespaceValidator;
    typeValidator;
    reportGenerator;
    constructor() {
        this.syntaxValidator = new SyntaxValidator();
        this.referenceValidator = new ReferenceValidator();
        this.namespaceValidator = new NamespaceValidator();
        this.typeValidator = new TypeValidator();
        this.reportGenerator = new ReportGenerator();
    }
    /**
     * 스키마 전체 검증을 수행합니다
     */
    async validate(schema, options) {
        const startTime = Date.now();
        try {
            // 기본 옵션 설정
            const validationOptions = {
                strictMode: false,
                skipWarnings: false,
                maxIssues: 1000,
                validateReferences: true,
                validateNamespaces: true,
                validateTypes: true,
                ...options
            };
            // 구문 검증
            const syntaxResult = await this.validateSyntax(schema);
            // 에러가 있고 strict 모드인 경우 조기 종료
            if (validationOptions.strictMode && syntaxResult.issues.some(i => i.severity === ValidationSeverity.ERROR)) {
                return syntaxResult;
            }
            const allIssues = [...syntaxResult.issues];
            // 참조 무결성 검증
            if (validationOptions.validateReferences) {
                const referenceResult = await this.validateReferences(schema);
                // 참조 검증 결과를 이슈로 변환하여 추가
                // (실제 구현에서는 ReportGenerator의 메서드를 사용)
            }
            // 네임스페이스 검증
            if (validationOptions.validateNamespaces) {
                const namespaceResult = await this.validateNamespaces(schema);
                // 네임스페이스 검증 결과를 이슈로 변환하여 추가
            }
            // 타입 호환성 검증
            if (validationOptions.validateTypes) {
                const typeResult = await this.validateTypes(schema);
                // 타입 검증 결과를 이슈로 변환하여 추가
            }
            // 경고 필터링
            const filteredIssues = validationOptions.skipWarnings
                ? allIssues.filter(i => i.severity !== ValidationSeverity.WARNING)
                : allIssues;
            // 최대 이슈 수 제한
            const limitedIssues = validationOptions.maxIssues
                ? filteredIssues.slice(0, validationOptions.maxIssues)
                : filteredIssues;
            // 커스텀 규칙 적용
            if (validationOptions.customRules) {
                for (const rule of validationOptions.customRules) {
                    if (rule.schemaTypes.includes(schema.type)) {
                        const customIssues = rule.validator(schema);
                        limitedIssues.push(...customIssues);
                    }
                }
            }
            const executionTime = Date.now() - startTime;
            const summary = this.createSummary(limitedIssues);
            return {
                isValid: limitedIssues.filter(i => i.severity === ValidationSeverity.ERROR).length === 0,
                schemaId: schema.id,
                schemaType: schema.type,
                issues: limitedIssues,
                summary,
                executionTime,
                timestamp: new Date()
            };
        }
        catch (error) {
            const executionTime = Date.now() - startTime;
            return {
                isValid: false,
                schemaId: schema.id,
                schemaType: schema.type,
                issues: [{
                        id: `validation-error-${Date.now()}`,
                        type: 'syntax_error',
                        severity: ValidationSeverity.ERROR,
                        message: '검증 중 예상치 못한 오류가 발생했습니다',
                        description: error instanceof Error ? error.message : String(error)
                    }],
                summary: {
                    totalIssues: 1,
                    errorCount: 1,
                    warningCount: 0,
                    infoCount: 0,
                    validatedElements: 0,
                    skippedElements: 0
                },
                executionTime,
                timestamp: new Date()
            };
        }
    }
    /**
     * 구문적 정확성 검증
     */
    async validateSyntax(schema) {
        return this.syntaxValidator.validateSyntax(schema);
    }
    /**
     * 참조 무결성 검증
     */
    async validateReferences(schema) {
        return this.referenceValidator.validateReferences(schema);
    }
    /**
     * 네임스페이스 충돌 검증
     */
    async validateNamespaces(schema) {
        return this.namespaceValidator.validateNamespaces(schema);
    }
    /**
     * 타입 호환성 검증
     */
    async validateTypes(schema) {
        return this.typeValidator.validateTypes(schema);
    } /*
  *
     * 검증 리포트 생성
     */
    async generateReport(results) {
        if (results.length === 0) {
            throw new Error('검증 결과가 없습니다');
        }
        const firstResult = results[0];
        const mockSchema = {
            id: firstResult.schemaId,
            name: 'Unknown Schema',
            type: firstResult.schemaType,
            version: '1.0.0',
            originalFormat: '',
            metadata: {
                imports: [],
                annotations: []
            },
            content: {
                entities: [],
                types: [],
                operations: [],
                bindings: []
            },
            sourceSchema: {},
            conversionMetadata: {
                sourceType: firstResult.schemaType,
                targetType: firstResult.schemaType,
                conversionTime: 0,
                rulesApplied: [],
                warnings: [],
                lossyConversion: false,
                fidelityScore: 100
            },
            validationResult: {
                isValid: true,
                errors: [],
                warnings: [],
                infos: []
            },
            createdAt: new Date(),
            updatedAt: new Date()
        };
        return this.reportGenerator.generateReport(mockSchema, results);
    }
    /**
     * 통합 검증을 수행하고 리포트를 생성합니다
     */
    async validateAndGenerateReport(schema, options) {
        const startTime = Date.now();
        // 모든 검증 수행
        const syntaxResult = await this.validateSyntax(schema);
        const referenceResult = options?.validateReferences !== false
            ? await this.validateReferences(schema)
            : undefined;
        const namespaceResult = options?.validateNamespaces !== false
            ? await this.validateNamespaces(schema)
            : undefined;
        const typeResult = options?.validateTypes !== false
            ? await this.validateTypes(schema)
            : undefined;
        // 통합 리포트 생성
        const report = await this.reportGenerator.generateReport(schema, [syntaxResult], referenceResult, namespaceResult, typeResult);
        // 실행 시간 업데이트
        report.executionTime = Date.now() - startTime;
        return report;
    }
    /**
     * 검증 결과 요약을 생성합니다
     */
    createSummary(issues) {
        const errorCount = issues.filter(i => i.severity === ValidationSeverity.ERROR).length;
        const warningCount = issues.filter(i => i.severity === ValidationSeverity.WARNING).length;
        const infoCount = issues.filter(i => i.severity === ValidationSeverity.INFO).length;
        return {
            totalIssues: issues.length,
            errorCount,
            warningCount,
            infoCount,
            validatedElements: 0, // 실제 구현에서는 검증된 요소 수를 계산
            skippedElements: 0 // 실제 구현에서는 건너뛴 요소 수를 계산
        };
    }
    /**
     * 배치 검증을 수행합니다
     */
    async validateBatch(schemas, options) {
        const reports = [];
        for (const schema of schemas) {
            try {
                const report = await this.validateAndGenerateReport(schema, options);
                reports.push(report);
            }
            catch (error) {
                // 개별 스키마 검증 실패 시에도 계속 진행
                const errorReport = {
                    id: `error-report-${Date.now()}`,
                    schemaId: schema.id,
                    schemaName: schema.name,
                    schemaType: schema.type,
                    validationResults: [{
                            isValid: false,
                            schemaId: schema.id,
                            schemaType: schema.type,
                            issues: [{
                                    id: `batch-error-${Date.now()}`,
                                    type: 'syntax_error',
                                    severity: ValidationSeverity.ERROR,
                                    message: '배치 검증 중 오류가 발생했습니다',
                                    description: error instanceof Error ? error.message : String(error)
                                }],
                            summary: {
                                totalIssues: 1,
                                errorCount: 1,
                                warningCount: 0,
                                infoCount: 0,
                                validatedElements: 0,
                                skippedElements: 0
                            },
                            executionTime: 0,
                            timestamp: new Date()
                        }],
                    overallStatus: 'invalid',
                    summary: {
                        totalIssues: 1,
                        errorCount: 1,
                        warningCount: 0,
                        infoCount: 0,
                        validatedElements: 0,
                        skippedElements: 0
                    },
                    generatedAt: new Date(),
                    executionTime: 0
                };
                reports.push(errorReport);
            }
        }
        return reports;
    }
    /**
     * 검증 통계를 생성합니다
     */
    generateValidationStatistics(reports) {
        const totalSchemas = reports.length;
        const validSchemas = reports.filter(r => r.overallStatus === 'valid').length;
        const invalidSchemas = reports.filter(r => r.overallStatus === 'invalid').length;
        const warningSchemas = reports.filter(r => r.overallStatus === 'warning').length;
        const totalIssues = reports.reduce((sum, r) => sum + r.summary.totalIssues, 0);
        const totalErrors = reports.reduce((sum, r) => sum + r.summary.errorCount, 0);
        const totalWarnings = reports.reduce((sum, r) => sum + r.summary.warningCount, 0);
        const averageExecutionTime = reports.length > 0
            ? reports.reduce((sum, r) => sum + r.executionTime, 0) / reports.length
            : 0;
        return {
            totalSchemas,
            validSchemas,
            invalidSchemas,
            warningSchemas,
            totalIssues,
            totalErrors,
            totalWarnings,
            averageExecutionTime
        };
    }
}
