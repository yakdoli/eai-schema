import { SchemaType, UnifiedSchema } from '@eai/shared';
/**
 * 검증 결과 심각도 레벨
 */
export declare enum ValidationSeverity {
    ERROR = "error",
    WARNING = "warning",
    INFO = "info"
}
/**
 * 검증 이슈 타입
 */
export declare enum ValidationIssueType {
    SYNTAX_ERROR = "syntax_error",
    REFERENCE_ERROR = "reference_error",
    NAMESPACE_CONFLICT = "namespace_conflict",
    TYPE_MISMATCH = "type_mismatch",
    MISSING_REQUIRED = "missing_required",
    INVALID_FORMAT = "invalid_format"
}
/**
 * 검증 이슈 정보
 */
export interface ValidationIssue {
    id: string;
    type: ValidationIssueType;
    severity: ValidationSeverity;
    message: string;
    description?: string;
    location?: ValidationLocation;
    suggestion?: string;
    relatedIssues?: string[];
}
/**
 * 검증 이슈 위치 정보
 */
export interface ValidationLocation {
    path: string;
    line?: number;
    column?: number;
    element?: string;
    namespace?: string;
}
/**
 * 검증 결과
 */
export interface ValidationResult {
    isValid: boolean;
    schemaId: string;
    schemaType: SchemaType;
    issues: ValidationIssue[];
    summary: ValidationSummary;
    executionTime: number;
    timestamp: Date;
}
/**
 * 검증 결과 요약
 */
export interface ValidationSummary {
    totalIssues: number;
    errorCount: number;
    warningCount: number;
    infoCount: number;
    validatedElements: number;
    skippedElements: number;
}
/**
 * 참조 무결성 검증 결과
 */
export interface ReferenceValidationResult {
    missingReferences: MissingReference[];
    circularReferences: CircularReference[];
    unresolvedImports: UnresolvedImport[];
}
/**
 * 누락된 참조 정보
 */
export interface MissingReference {
    referencingElement: string;
    referencingLocation: ValidationLocation;
    targetReference: string;
    targetNamespace?: string;
}
/**
 * 순환 참조 정보
 */
export interface CircularReference {
    path: string[];
    elements: string[];
}
/**
 * 해결되지 않은 임포트 정보
 */
export interface UnresolvedImport {
    importPath: string;
    namespace?: string;
    location: ValidationLocation;
    reason: string;
}
/**
 * 네임스페이스 충돌 검증 결과
 */
export interface NamespaceValidationResult {
    conflicts: NamespaceConflict[];
    duplicateDeclarations: DuplicateDeclaration[];
    ambiguousReferences: AmbiguousReference[];
}
/**
 * 네임스페이스 충돌 정보
 */
export interface NamespaceConflict {
    namespace: string;
    conflictingElements: ConflictingElement[];
    conflictType: 'prefix' | 'uri' | 'declaration';
}
/**
 * 충돌하는 요소 정보
 */
export interface ConflictingElement {
    name: string;
    location: ValidationLocation;
    definition: string;
}
/**
 * 중복 선언 정보
 */
export interface DuplicateDeclaration {
    elementName: string;
    namespace?: string;
    locations: ValidationLocation[];
}
/**
 * 모호한 참조 정보
 */
export interface AmbiguousReference {
    reference: string;
    possibleTargets: string[];
    location: ValidationLocation;
}
/**
 * 타입 호환성 검증 결과
 */
export interface TypeValidationResult {
    incompatibleTypes: TypeIncompatibility[];
    missingTypes: MissingType[];
    invalidConstraints: InvalidConstraint[];
}
/**
 * 타입 비호환성 정보
 */
export interface TypeIncompatibility {
    sourceType: string;
    targetType: string;
    location: ValidationLocation;
    reason: string;
    severity: ValidationSeverity;
}
/**
 * 누락된 타입 정보
 */
export interface MissingType {
    typeName: string;
    referencedBy: string[];
    namespace?: string;
}
/**
 * 잘못된 제약조건 정보
 */
export interface InvalidConstraint {
    constraintType: string;
    value: any;
    location: ValidationLocation;
    reason: string;
}
/**
 * 검증 옵션
 */
export interface ValidationOptions {
    strictMode?: boolean;
    skipWarnings?: boolean;
    maxIssues?: number;
    validateReferences?: boolean;
    validateNamespaces?: boolean;
    validateTypes?: boolean;
    customRules?: ValidationRule[];
}
/**
 * 커스텀 검증 규칙
 */
export interface ValidationRule {
    id: string;
    name: string;
    description: string;
    severity: ValidationSeverity;
    schemaTypes: SchemaType[];
    validator: (schema: UnifiedSchema) => ValidationIssue[];
}
/**
 * 검증 리포트
 */
export interface ValidationReport {
    id: string;
    schemaId: string;
    schemaName: string;
    schemaType: SchemaType;
    validationResults: ValidationResult[];
    overallStatus: 'valid' | 'invalid' | 'warning';
    summary: ValidationSummary;
    generatedAt: Date;
    executionTime: number;
}
//# sourceMappingURL=index.d.ts.map