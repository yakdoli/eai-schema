import { XMLParser } from 'fast-xml-parser';
import {
  WSDLSchema,
  WSDLContent,
  WSDLDefinitions,
  WSDLService,
  WSDLBinding,
  WSDLPortType,
  WSDLMessage,
  WSDLTypes,
  WSDLParseOptions,
  WSDLParseResult,
  WSDLParseMetadata,
  WSDLVersion,
  WSDLValidationError,
  WSDLErrorCode,
  WSDLStyle,
  WSDLUse,
  WSDLAddressType,
  SchemaType,
  OperationType,
  BindingType,
} from '@eai/shared/types';
import { BaseParser } from './base-parser';
import { ErrorHandler } from '../utils/error-handler';
import { NamespaceResolver } from '../utils/namespace-resolver';

/**
 * WSDL 파싱 엔진
 * WSDL 1.1 및 2.0 스펙을 지원하며, 서비스, 포트, 오퍼레이션, 바인딩, 메시지 정의를 파싱합니다.
 */
export class WSDLParser extends BaseParser {
  private xmlParser: XMLParser;
  private namespaceResolver: NamespaceResolver;
  private errorHandler: ErrorHandler;

  constructor() {
    super();
    this.xmlParser = new XMLParser({
      ignoreAttributes: false,
      attributeNamePrefix: '@_',
      textNodeName: '#text',
      parseAttributeValue: true,
      trimValues: true,
      alwaysCreateTextNode: false,
    });
    
    this.namespaceResolver = new NamespaceResolver();
    this.errorHandler = new ErrorHandler();
  }

  /**
   * WSDL 문서를 파싱합니다
   */
  async parse(content: string, options: Partial<WSDLParseOptions> = {}): Promise<WSDLParseResult> {
    const parseOptions: WSDLParseOptions = {
      resolveExternalReferences: false,
      validateSchema: true,
      ignoreBaseNamespaces: false,
      maxDepth: 10,
      timeout: 30000,
      ...options,
    };

    try {
      // XML 파싱
      const parsedXml = this.xmlParser.parse(content);
      
      // WSDL 버전 감지
      const version = this.detectWSDLVersion(parsedXml);
      
      // 네임스페이스 해결
      const definitions = this.extractDefinitions(parsedXml);
      this.namespaceResolver.setNamespaces(definitions.xmlns);
      
      // WSDL 콘텐츠 파싱
      const wsdlContent = await this.parseWSDLContent(parsedXml, parseOptions);
      
      // 스키마 객체 생성
      const schema: WSDLSchema = {
        id: this.generateId(),
        name: definitions.name || 'Unnamed WSDL',
        version: '1.0',
        type: SchemaType.WSDL,
        originalFormat: 'WSDL',
        metadata: {
          namespace: definitions.targetNamespace,
          targetNamespace: definitions.targetNamespace,
          imports: [],
          annotations: [],
          documentation: this.extractDocumentation(parsedXml),
        },
        content: wsdlContent,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      // 메타데이터 생성
      const metadata = this.generateMetadata(schema, version);
      
      // 검증 수행
      const validation = parseOptions.validateSchema 
        ? await this.validateWSDL(schema, parseOptions)
        : { isValid: true, errors: [], warnings: [], infos: [] };

      return {
        schema,
        validation,
        metadata,
      };
    } catch (error) {
      throw this.errorHandler.handleParsingError(error, 'WSDL');
    }
  }

  /**
   * WSDL 버전을 감지합니다
   */
  private detectWSDLVersion(parsedXml: any): WSDLVersion {
    // WSDL 2.0은 description 요소를 사용
    if (parsedXml['wsdl:description'] || parsedXml.description) {
      return WSDLVersion.WSDL_2_0;
    }
    
    const definitions = parsedXml['wsdl:definitions'] || parsedXml.definitions;
    
    if (!definitions) {
      throw new Error('Invalid WSDL: definitions element not found');
    }

    // 네임스페이스로 버전 판단
    const xmlns = definitions['@_xmlns'] || {};
    if (xmlns['wsdl'] && (xmlns['wsdl'].includes('2004') || xmlns['wsdl'].includes('2006'))) {
      return WSDLVersion.WSDL_2_0;
    }
    
    return WSDLVersion.WSDL_1_1;
  }

  /**
   * WSDL definitions 요소를 추출합니다
   */
  private extractDefinitions(parsedXml: any): WSDLDefinitions {
    // WSDL 1.1 (definitions) 또는 WSDL 2.0 (description) 지원
    const definitions = parsedXml['wsdl:definitions'] || parsedXml.definitions || 
                       parsedXml['wsdl:description'] || parsedXml.description;
    
    if (!definitions) {
      throw new Error('Invalid WSDL: definitions or description element not found');
    }

    const xmlns: Record<string, string> = {};
    
    // 네임스페이스 속성 추출
    Object.keys(definitions).forEach(key => {
      if (key.startsWith('@_xmlns')) {
        const nsPrefix = key.replace('@_xmlns:', '').replace('@_xmlns', '');
        xmlns[nsPrefix || 'default'] = definitions[key];
      }
    });

    return {
      name: definitions['@_name'] || 'Unnamed',
      targetNamespace: definitions['@_targetNamespace'] || '',
      xmlns,
      elementFormDefault: definitions['@_elementFormDefault'],
      attributeFormDefault: definitions['@_attributeFormDefault'],
    };
  }

  /**
   * WSDL 콘텐츠를 파싱합니다
   */
  private async parseWSDLContent(parsedXml: any, options: WSDLParseOptions): Promise<WSDLContent> {
    // WSDL 1.1 (definitions) 또는 WSDL 2.0 (description) 지원
    const definitions = parsedXml['wsdl:definitions'] || parsedXml.definitions || 
                       parsedXml['wsdl:description'] || parsedXml.description;
    
    return {
      definitions: this.extractDefinitions(parsedXml),
      services: await this.parseServices(definitions),
      bindings: await this.parseBindings(definitions),
      portTypes: await this.parsePortTypes(definitions),
      messages: await this.parseMessages(definitions),
      types: await this.parseTypes(definitions),
    };
  }

  /**
   * WSDL 서비스를 파싱합니다
   */
  private async parseServices(definitions: any): Promise<WSDLService[]> {
    const services = definitions['wsdl:service'] || definitions.service || [];
    const serviceArray = this.ensureArray(services);
    
    return serviceArray.map(service => ({
      name: service['@_name'] || 'Unnamed Service',
      documentation: this.extractDocumentation(service),
      ports: this.parsePorts(service),
    }));
  }

  /**
   * WSDL 포트를 파싱합니다
   */
  private parsePorts(service: any): any[] {
    const ports = service['wsdl:port'] || service.port || [];
    const portArray = this.ensureArray(ports);
    
    return portArray.map(port => ({
      name: port['@_name'] || 'Unnamed Port',
      binding: this.namespaceResolver.resolveQName(port['@_binding'] || ''),
      address: this.parseAddress(port),
    }));
  }

  /**
   * WSDL 주소를 파싱합니다
   */
  private parseAddress(port: any): any {
    // SOAP 주소
    const soapAddress = port['soap:address'] || port['soap12:address'];
    if (soapAddress) {
      return {
        location: soapAddress['@_location'] || '',
        type: WSDLAddressType.SOAP,
      };
    }
    
    // HTTP 주소
    const httpAddress = port['http:address'];
    if (httpAddress) {
      return {
        location: httpAddress['@_location'] || '',
        type: WSDLAddressType.HTTP,
      };
    }
    
    // 기본값
    return {
      location: '',
      type: WSDLAddressType.SOAP,
    };
  }

  /**
   * WSDL 바인딩을 파싱합니다
   */
  private async parseBindings(definitions: any): Promise<WSDLBinding[]> {
    const bindings = definitions['wsdl:binding'] || definitions.binding || [];
    const bindingArray = this.ensureArray(bindings);
    
    return bindingArray.map(binding => {
      const soapBinding = binding['soap:binding'] || binding['soap12:binding'];
      
      return {
        name: binding['@_name'] || 'Unnamed Binding',
        type: BindingType.SOAP, // WSDL은 주로 SOAP 바인딩을 사용
        portType: this.namespaceResolver.resolveQName(binding['@_type'] || ''),
        style: soapBinding ? this.parseStyle(soapBinding['@_style']) : undefined,
        transport: soapBinding ? soapBinding['@_transport'] || '' : '',
        operations: this.parseBindingOperations(binding),
      };
    });
  }

  /**
   * WSDL 바인딩 오퍼레이션을 파싱합니다
   */
  private parseBindingOperations(binding: any): any[] {
    const operations = binding['wsdl:operation'] || binding.operation || [];
    const operationArray = this.ensureArray(operations);
    
    return operationArray.map(operation => {
      const soapOperation = operation['soap:operation'] || operation['soap12:operation'];
      
      return {
        name: operation['@_name'] || 'Unnamed Operation',
        soapAction: soapOperation ? soapOperation['@_soapAction'] : undefined,
        style: soapOperation ? this.parseStyle(soapOperation['@_style']) : undefined,
        input: this.parseBindingMessage(operation['wsdl:input'] || operation.input),
        output: this.parseBindingMessage(operation['wsdl:output'] || operation.output),
        faults: this.parseBindingFaults(operation),
      };
    });
  }

  /**
   * WSDL 바인딩 메시지를 파싱합니다
   */
  private parseBindingMessage(message: any): any {
    if (!message) return undefined;
    
    const soapBody = message['soap:body'] || message['soap12:body'];
    
    return {
      use: soapBody ? this.parseUse(soapBody['@_use']) : undefined,
      encodingStyle: soapBody ? soapBody['@_encodingStyle'] : undefined,
      namespace: soapBody ? soapBody['@_namespace'] : undefined,
      parts: this.parseBindingParts(soapBody),
    };
  }

  /**
   * WSDL 바인딩 파트를 파싱합니다
   */
  private parseBindingParts(soapBody: any): any[] {
    if (!soapBody || !soapBody['@_parts']) return [];
    
    const parts = soapBody['@_parts'].split(' ');
    return parts.map((part: string) => ({
      name: part,
      element: undefined,
      type: undefined,
    }));
  }

  /**
   * WSDL 바인딩 폴트를 파싱합니다
   */
  private parseBindingFaults(operation: any): any[] {
    const faults = operation['wsdl:fault'] || operation.fault || [];
    const faultArray = this.ensureArray(faults);
    
    return faultArray.map(fault => {
      const soapFault = fault['soap:fault'] || fault['soap12:fault'];
      
      return {
        name: fault['@_name'] || 'Unnamed Fault',
        use: soapFault ? this.parseUse(soapFault['@_use']) : undefined,
        encodingStyle: soapFault ? soapFault['@_encodingStyle'] : undefined,
        namespace: soapFault ? soapFault['@_namespace'] : undefined,
      };
    });
  }

  /**
   * WSDL 포트 타입을 파싱합니다
   */
  private async parsePortTypes(definitions: any): Promise<WSDLPortType[]> {
    const portTypes = definitions['wsdl:portType'] || definitions.portType || [];
    const portTypeArray = this.ensureArray(portTypes);
    
    return portTypeArray.map(portType => ({
      name: portType['@_name'] || 'Unnamed PortType',
      documentation: this.extractDocumentation(portType),
      operations: this.parseOperations(portType),
    }));
  }

  /**
   * WSDL 오퍼레이션을 파싱합니다
   */
  private parseOperations(portType: any): any[] {
    const operations = portType['wsdl:operation'] || portType.operation || [];
    const operationArray = this.ensureArray(operations);
    
    return operationArray.map(operation => ({
      name: operation['@_name'] || 'Unnamed Operation',
      type: this.determineOperationType(operation),
      parameterOrder: operation['@_parameterOrder'],
      input: this.parseOperationMessage(operation['wsdl:input'] || operation.input),
      output: this.parseOperationMessage(operation['wsdl:output'] || operation.output),
      faults: this.parseOperationFaults(operation),
      documentation: this.extractDocumentation(operation),
    }));
  }

  /**
   * 오퍼레이션 타입을 결정합니다
   */
  private determineOperationType(operation: any): OperationType {
    const hasInput = !!(operation['wsdl:input'] || operation.input);
    const hasOutput = !!(operation['wsdl:output'] || operation.output);
    
    if (hasInput && hasOutput) {
      return OperationType.REQUEST_RESPONSE;
    } else if (hasInput && !hasOutput) {
      return OperationType.ONE_WAY;
    } else if (!hasInput && hasOutput) {
      return OperationType.NOTIFICATION;
    } else {
      return OperationType.SOLICIT_RESPONSE;
    }
  }

  /**
   * WSDL 오퍼레이션 메시지를 파싱합니다
   */
  private parseOperationMessage(message: any): any {
    if (!message) return undefined;
    
    return {
      name: message['@_name'],
      message: this.namespaceResolver.resolveQName(message['@_message'] || ''),
      documentation: this.extractDocumentation(message),
    };
  }

  /**
   * WSDL 오퍼레이션 폴트를 파싱합니다
   */
  private parseOperationFaults(operation: any): any[] {
    const faults = operation['wsdl:fault'] || operation.fault || [];
    const faultArray = this.ensureArray(faults);
    
    return faultArray.map(fault => ({
      name: fault['@_name'] || 'Unnamed Fault',
      message: this.namespaceResolver.resolveQName(fault['@_message'] || ''),
      documentation: this.extractDocumentation(fault),
    }));
  }

  /**
   * WSDL 메시지를 파싱합니다
   */
  private async parseMessages(definitions: any): Promise<WSDLMessage[]> {
    const messages = definitions['wsdl:message'] || definitions.message || [];
    const messageArray = this.ensureArray(messages);
    
    return messageArray.map(message => ({
      name: message['@_name'] || 'Unnamed Message',
      documentation: this.extractDocumentation(message),
      parts: this.parseMessageParts(message),
    }));
  }

  /**
   * WSDL 메시지 파트를 파싱합니다
   */
  private parseMessageParts(message: any): any[] {
    const parts = message['wsdl:part'] || message.part || [];
    const partArray = this.ensureArray(parts);
    
    return partArray.map(part => ({
      name: part['@_name'] || 'Unnamed Part',
      element: part['@_element'] ? this.namespaceResolver.resolveQName(part['@_element']) : undefined,
      type: part['@_type'] ? this.namespaceResolver.resolveQName(part['@_type']) : undefined,
      documentation: this.extractDocumentation(part),
    }));
  }

  /**
   * WSDL 타입을 파싱합니다
   */
  private async parseTypes(definitions: any): Promise<WSDLTypes> {
    const types = definitions['wsdl:types'] || definitions.types;
    
    if (!types) {
      return {
        schemas: [],
        imports: [],
      };
    }
    
    return {
      schemas: await this.parseSchemas(types),
      imports: this.parseImports(types),
    };
  }

  /**
   * WSDL 스키마를 파싱합니다
   */
  private async parseSchemas(types: any): Promise<any[]> {
    const schemas = types['xs:schema'] || types['xsd:schema'] || types.schema || [];
    const schemaArray = this.ensureArray(schemas);
    
    // 여기서는 기본적인 스키마 정보만 추출
    // 상세한 XSD 파싱은 XSDParser에서 처리
    return schemaArray.map(schema => ({
      targetNamespace: schema['@_targetNamespace'],
      elementFormDefault: schema['@_elementFormDefault'],
      attributeFormDefault: schema['@_attributeFormDefault'],
      elements: [], // XSDParser에서 처리
      types: [], // XSDParser에서 처리
    }));
  }

  /**
   * WSDL 임포트를 파싱합니다
   */
  private parseImports(types: any): any[] {
    const imports = types['wsdl:import'] || types.import || [];
    const importArray = this.ensureArray(imports);
    
    return importArray.map(imp => ({
      namespace: imp['@_namespace'] || '',
      location: imp['@_location'] || '',
    }));
  }

  /**
   * 스타일을 파싱합니다
   */
  private parseStyle(style: string): WSDLStyle | undefined {
    if (!style) return undefined;
    
    switch (style.toLowerCase()) {
      case 'document':
        return WSDLStyle.DOCUMENT;
      case 'rpc':
        return WSDLStyle.RPC;
      default:
        return undefined;
    }
  }

  /**
   * 사용법을 파싱합니다
   */
  private parseUse(use: string): WSDLUse | undefined {
    if (!use) return undefined;
    
    switch (use.toLowerCase()) {
      case 'literal':
        return WSDLUse.LITERAL;
      case 'encoded':
        return WSDLUse.ENCODED;
      default:
        return undefined;
    }
  }

  /**
   * 문서화 정보를 추출합니다
   */
  private extractDocumentation(element: any): string | undefined {
    // definitions 레벨에서 문서화 찾기
    if (element['wsdl:definitions']) {
      const definitions = element['wsdl:definitions'];
      const doc = definitions['wsdl:documentation'] || definitions.documentation;
      if (doc) {
        if (typeof doc === 'string') {
          return doc.trim();
        }
        if (doc['#text']) {
          return doc['#text'].trim();
        }
      }
    }
    
    // 일반적인 요소에서 문서화 찾기
    const doc = element['wsdl:documentation'] || element.documentation;
    if (!doc) return undefined;
    
    if (typeof doc === 'string') {
      return doc.trim();
    }
    
    if (doc['#text']) {
      return doc['#text'].trim();
    }
    
    return undefined;
  }

  /**
   * 메타데이터를 생성합니다
   */
  private generateMetadata(schema: WSDLSchema, version: WSDLVersion): WSDLParseMetadata {
    const content = schema.content;
    
    return {
      version,
      serviceCount: content.services.length,
      operationCount: content.portTypes.reduce((count, pt) => count + pt.operations.length, 0),
      messageCount: content.messages.length,
      bindingCount: content.bindings.length,
      externalReferences: this.extractExternalReferences(content),
      namespaces: Object.keys(content.definitions.xmlns),
    };
  }

  /**
   * 외부 참조를 추출합니다
   */
  private extractExternalReferences(content: WSDLContent): string[] {
    const references: string[] = [];
    
    // 임포트에서 외부 참조 추출
    if (content.types && content.types.imports) {
      content.types.imports.forEach(imp => {
        if (imp && imp.location && typeof imp.location === 'string' && !imp.location.startsWith('#')) {
          references.push(imp.location);
        }
      });
    }
    
    return [...new Set(references)];
  }

  /**
   * WSDL을 검증합니다
   */
  private async validateWSDL(schema: WSDLSchema, options: WSDLParseOptions): Promise<any> {
    const errors: WSDLValidationError[] = [];
    const warnings: WSDLValidationError[] = [];
    const infos: WSDLValidationError[] = [];
    
    // 기본 구조 검증
    this.validateBasicStructure(schema, errors);
    
    // 참조 무결성 검증
    this.validateReferences(schema, errors, warnings);
    
    // 바인딩 검증
    this.validateBindings(schema, errors, warnings);
    
    // 네임스페이스 검증
    this.validateNamespaces(schema, warnings);
    
    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      infos,
    };
  }

  /**
   * 기본 구조를 검증합니다
   */
  private validateBasicStructure(schema: WSDLSchema, errors: WSDLValidationError[]): void {
    const content = schema.content;
    
    // 서비스가 있는지 확인
    if (content.services.length === 0) {
      errors.push({
        code: WSDLErrorCode.MISSING_REFERENCE,
        message: 'No services defined in WSDL',
        path: '/definitions',
        severity: 'error',
      });
    }
    
    // 포트 타입이 있는지 확인
    if (content.portTypes.length === 0) {
      errors.push({
        code: WSDLErrorCode.INVALID_PORT_TYPE,
        message: 'No port types defined in WSDL',
        path: '/definitions',
        severity: 'error',
      });
    }
  }

  /**
   * 참조 무결성을 검증합니다
   */
  private validateReferences(schema: WSDLSchema, errors: WSDLValidationError[], warnings: WSDLValidationError[]): void {
    const content = schema.content;
    
    // 바인딩에서 포트 타입 참조 검증
    content.bindings.forEach(binding => {
      // QName에서 로컬 이름 추출
      const portTypeName = this.extractLocalName(binding.portType);
      const portType = content.portTypes.find(pt => pt.name === portTypeName);
      if (!portType) {
        errors.push({
          code: WSDLErrorCode.MISSING_REFERENCE,
          message: `Port type '${binding.portType}' referenced by binding '${binding.name}' not found`,
          path: `/definitions/binding[@name='${binding.name}']`,
          severity: 'error',
        });
      }
    });
    
    // 오퍼레이션에서 메시지 참조 검증
    content.portTypes.forEach(portType => {
      portType.operations.forEach(operation => {
        if (operation.input) {
          const messageName = this.extractLocalName(operation.input.message);
          const message = content.messages.find(m => m.name === messageName);
          if (!message) {
            errors.push({
              code: WSDLErrorCode.MISSING_MESSAGE,
              message: `Message '${operation.input.message}' referenced by operation '${operation.name}' not found`,
              path: `/definitions/portType[@name='${portType.name}']/operation[@name='${operation.name}']`,
              severity: 'error',
            });
          }
        }
        
        if (operation.output) {
          const messageName = this.extractLocalName(operation.output.message);
          const message = content.messages.find(m => m.name === messageName);
          if (!message) {
            errors.push({
              code: WSDLErrorCode.MISSING_MESSAGE,
              message: `Message '${operation.output.message}' referenced by operation '${operation.name}' not found`,
              path: `/definitions/portType[@name='${portType.name}']/operation[@name='${operation.name}']`,
              severity: 'error',
            });
          }
        }
      });
    });
  }

  /**
   * QName에서 로컬 이름을 추출합니다
   */
  private extractLocalName(qname: string): string {
    if (!qname) return '';
    
    // {namespace}localName 형태인 경우
    if (qname.startsWith('{') && qname.includes('}')) {
      return qname.substring(qname.lastIndexOf('}') + 1);
    }
    
    // prefix:localName 형태인 경우
    if (qname.includes(':')) {
      return qname.substring(qname.lastIndexOf(':') + 1);
    }
    
    // 그냥 로컬 이름인 경우
    return qname;
  }

  /**
   * 바인딩을 검증합니다
   */
  private validateBindings(schema: WSDLSchema, errors: WSDLValidationError[], warnings: WSDLValidationError[]): void {
    const content = schema.content;
    
    content.bindings.forEach(binding => {
      // 바인딩에 오퍼레이션이 있는지 확인
      if (binding.operations.length === 0) {
        warnings.push({
          code: WSDLErrorCode.INVALID_BINDING,
          message: `Binding '${binding.name}' has no operations`,
          path: `/definitions/binding[@name='${binding.name}']`,
          severity: 'warning',
        });
      }
      
      // 포트 타입과 바인딩 오퍼레이션 일치 확인
      const portType = content.portTypes.find(pt => pt.name === binding.portType);
      if (portType) {
        binding.operations.forEach(bindingOp => {
          const portTypeOp = portType.operations.find(op => op.name === bindingOp.name);
          if (!portTypeOp) {
            warnings.push({
              code: WSDLErrorCode.INVALID_OPERATION,
              message: `Operation '${bindingOp.name}' in binding '${binding.name}' not found in port type '${portType.name}'`,
              path: `/definitions/binding[@name='${binding.name}']/operation[@name='${bindingOp.name}']`,
              severity: 'warning',
            });
          }
        });
      }
    });
  }

  /**
   * 네임스페이스를 검증합니다
   */
  private validateNamespaces(schema: WSDLSchema, warnings: WSDLValidationError[]): void {
    const xmlns = schema.content.definitions.xmlns;
    
    // 필수 네임스페이스 확인
    const requiredNamespaces = ['wsdl', 'soap'];
    requiredNamespaces.forEach(ns => {
      if (!xmlns[ns]) {
        warnings.push({
          code: WSDLErrorCode.INVALID_NAMESPACE,
          message: `Required namespace '${ns}' not declared`,
          path: '/definitions',
          severity: 'warning',
        });
      }
    });
    
    // 타겟 네임스페이스 확인
    if (!schema.content.definitions.targetNamespace) {
      warnings.push({
        code: WSDLErrorCode.INVALID_NAMESPACE,
        message: 'Target namespace not specified',
        path: '/definitions',
        severity: 'warning',
      });
    }
  }

  /**
   * 고유 ID를 생성합니다
   */
  private generateId(): string {
    return `wsdl_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}