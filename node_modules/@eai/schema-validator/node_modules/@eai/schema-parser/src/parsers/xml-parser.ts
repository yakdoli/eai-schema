import { XMLParser as FastXMLParser, XMLBuilder, XMLValidator } from 'fast-xml-parser';
import { DOMParser } from 'xmldom';
import { XMLParseResult, ParseOptions, ParseError, NamespaceContext } from '../types';
import { NamespaceResolver } from '../utils/namespace-resolver';
import { ErrorHandler } from '../utils/error-handler';

/**
 * XML 파싱 엔진
 * fast-xml-parser를 사용하여 XML 문서를 파싱하고 네임스페이스를 처리합니다.
 */
export class XMLParser {
  private fastParser: FastXMLParser;
  private namespaceResolver: NamespaceResolver;
  private errorHandler: ErrorHandler;

  constructor() {
    // fast-xml-parser 설정
    this.fastParser = new FastXMLParser({
      ignoreAttributes: false,
      attributeNamePrefix: '@_',
      textNodeName: '#text',
      allowBooleanAttributes: true,
      parseAttributeValue: false, // 속성 값을 문자열로 유지
      trimValues: true,
      processEntities: false, // XXE 공격 방지
      ignoreDeclaration: false,
      ignorePiTags: false
    });

    this.namespaceResolver = new NamespaceResolver();
    this.errorHandler = new ErrorHandler();
  }

  /**
   * XML 문자열을 파싱합니다.
   * @param xmlContent XML 문자열
   * @param options 파싱 옵션
   * @returns 파싱 결과
   */
  async parse(xmlContent: string, options: ParseOptions = {}): Promise<XMLParseResult> {
    const errors: ParseError[] = [];
    const warnings: ParseError[] = [];
    let data: any = null;
    let namespaces: NamespaceContext = {
      prefixToUri: new Map(),
      uriToPrefix: new Map()
    };

    try {
      // 입력 검증
      this.validateInput(xmlContent);

      // XML 구문 검증 (xmldom 사용)
      const syntaxErrors = this.validateSyntax(xmlContent);
      errors.push(...syntaxErrors);

      // 부분 실패 허용이 false이고 구문 에러가 있으면 중단
      if (!options.allowPartialFailure && syntaxErrors.length > 0) {
        throw new Error('XML 구문 에러로 인해 파싱을 중단합니다.');
      }

      // fast-xml-parser로 파싱
      const validationResult = XMLValidator.validate(xmlContent);
      if (validationResult === true) {
        data = this.fastParser.parse(xmlContent);
        
        // 네임스페이스 처리
        if (options.processNamespaces !== false) {
          namespaces = this.namespaceResolver.extractNamespaces(xmlContent);
          data = this.namespaceResolver.processNamespaces(data, namespaces);
        }
      } else {
        errors.push({
          code: 'XML_PARSE_ERROR',
          message: `XML 파싱 실패: ${validationResult.err?.msg || 'Unknown error'}`,
          severity: 'error'
        });
      }

    } catch (error) {
      errors.push(this.errorHandler.createParseError(error as Error));
    }

    return {
      data,
      errors,
      warnings,
      namespaces
    };
  }

  /**
   * 입력 검증
   */
  private validateInput(xmlContent: string): void {
    if (typeof xmlContent !== 'string') {
      throw new Error('유효하지 않은 XML 입력입니다.');
    }

    if (xmlContent.trim().length === 0) {
      throw new Error('빈 XML 문서입니다.');
    }

    // XXE 공격 패턴 검사
    if (this.containsXXEPatterns(xmlContent)) {
      throw new Error('보안상 위험한 XML 패턴이 감지되었습니다.');
    }
  }

  /**
   * XXE 공격 패턴 검사
   */
  private containsXXEPatterns(xmlContent: string): boolean {
    const xxePatterns = [
      /<!ENTITY\s+\w+\s+SYSTEM/i,
      /<!ENTITY\s+\w+\s+PUBLIC/i,
      /<!DOCTYPE[^>]*\[/i
    ];

    return xxePatterns.some(pattern => pattern.test(xmlContent));
  }

  /**
   * XML 구문 검증 (xmldom 사용)
   */
  private validateSyntax(xmlContent: string): ParseError[] {
    const errors: ParseError[] = [];
    
    try {
      const parser = new DOMParser({
        errorHandler: {
          warning: (msg: string) => {
            errors.push({
              code: 'XML_WARNING',
              message: msg,
              severity: 'warning'
            });
          },
          error: (msg: string) => {
            errors.push({
              code: 'XML_ERROR',
              message: msg,
              severity: 'error'
            });
          },
          fatalError: (msg: string) => {
            errors.push({
              code: 'XML_FATAL_ERROR',
              message: msg,
              severity: 'error'
            });
          }
        }
      });

      const doc = parser.parseFromString(xmlContent, 'text/xml');
      
      // 파싱 에러가 있는지 확인 (parsererror 요소가 있으면 에러)
      const parserError = doc.getElementsByTagName('parsererror');
      if (parserError.length > 0) {
        errors.push({
          code: 'XML_PARSE_ERROR',
          message: parserError[0].textContent || 'XML 파싱 에러',
          severity: 'error'
        });
      }
    } catch (error) {
      errors.push({
        code: 'XML_SYNTAX_ERROR',
        message: `XML 구문 에러: ${(error as Error).message}`,
        severity: 'error'
      });
    }

    return errors;
  }

  /**
   * 파싱된 객체를 XML 문자열로 변환
   */
  toXML(data: any, options: { format?: boolean } = {}): string {
    const builder = new XMLBuilder({
      ignoreAttributes: false,
      attributeNamePrefix: '@_',
      textNodeName: '#text',
      format: options.format || false,
      indentBy: '  ',
      suppressEmptyNode: false
    });

    return builder.build(data);
  }
}