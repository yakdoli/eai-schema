import { XSDParser } from '../../parsers/xsd-parser';
import { ParseOptions } from '../../types';

describe('XSDParser', () => {
  let parser: XSDParser;

  beforeEach(() => {
    parser = new XSDParser();
  });

  describe('기본 XSD 파싱', () => {
    it('간단한 XSD 스키마를 파싱해야 함', async () => {
      const xsdContent = `<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="http://example.com/test" elementFormDefault="qualified">
  <xs:element name="person" type="PersonType"/>
  <xs:complexType name="PersonType">
    <xs:sequence>
      <xs:element name="name" type="xs:string"/>
      <xs:element name="age" type="xs:int"/>
    </xs:sequence>
  </xs:complexType>
</xs:schema>`;

      const result = await parser.parse(xsdContent);

      expect(result.schema).toBeDefined();
      expect(result.errors).toHaveLength(0);
      expect(result.schema.targetNamespace).toBe('http://example.com/test');
      expect(result.schema.elementFormDefault).toBe('qualified');
      expect(result.complexTypes).toHaveLength(1);
      expect(result.complexTypes[0].name).toBe('PersonType');
    });

    it('XSD 스키마의 네임스페이스를 올바르게 처리해야 함', async () => {
      const xsdContent = `<?xml version="1.0" encoding="UTF-8"?>
<schema xmlns="http://www.w3.org/2001/XMLSchema" targetNamespace="http://example.com/test" xmlns:tns="http://example.com/test">
  <element name="testElement" type="string"/>
</schema>`;

      const result = await parser.parse(xsdContent);

      expect(result.schema).toBeDefined();
      expect(result.errors).toHaveLength(0);
      expect(result.schema.targetNamespace).toBe('http://example.com/test');
    });
  });

  describe('복합 타입 파싱', () => {
    it('복합 타입을 올바르게 파싱해야 함', async () => {
      const xsdContent = `
        <?xml version="1.0" encoding="UTF-8"?>
        <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   targetNamespace="http://example.com/test">
          
          <xs:complexType name="AddressType">
            <xs:sequence>
              <xs:element name="street" type="xs:string"/>
              <xs:element name="city" type="xs:string"/>
              <xs:element name="zipCode" type="xs:string"/>
            </xs:sequence>
            <xs:attribute name="country" type="xs:string" use="required"/>
          </xs:complexType>
          
          <xs:complexType name="PersonType">
            <xs:sequence>
              <xs:element name="name" type="xs:string"/>
              <xs:element name="address" type="AddressType"/>
            </xs:sequence>
            <xs:attribute name="id" type="xs:ID"/>
          </xs:complexType>
          
        </xs:schema>
      `;

      const result = await parser.parse(xsdContent);

      expect(result.complexTypes).toHaveLength(2);
      
      const addressType = result.complexTypes.find(t => t.name === 'AddressType');
      const personType = result.complexTypes.find(t => t.name === 'PersonType');
      
      expect(addressType).toBeDefined();
      expect(personType).toBeDefined();
      expect(addressType!.name).toBe('AddressType');
      expect(personType!.name).toBe('PersonType');
    });

    it('상속 관계가 있는 복합 타입을 파싱해야 함', async () => {
      const xsdContent = `
        <?xml version="1.0" encoding="UTF-8"?>
        <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   targetNamespace="http://example.com/test">
          
          <xs:complexType name="BaseType">
            <xs:sequence>
              <xs:element name="id" type="xs:string"/>
            </xs:sequence>
          </xs:complexType>
          
          <xs:complexType name="ExtendedType">
            <xs:complexContent>
              <xs:extension base="BaseType">
                <xs:sequence>
                  <xs:element name="name" type="xs:string"/>
                </xs:sequence>
              </xs:extension>
            </xs:complexContent>
          </xs:complexType>
          
        </xs:schema>
      `;

      const result = await parser.parse(xsdContent);

      expect(result.complexTypes).toHaveLength(2);
      
      const extendedType = result.complexTypes.find(t => t.name === 'ExtendedType');
      expect(extendedType).toBeDefined();
      expect(extendedType!.baseType).toBe('BaseType');
    });

    it('mixed content 복합 타입을 파싱해야 함', async () => {
      const xsdContent = `
        <?xml version="1.0" encoding="UTF-8"?>
        <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   targetNamespace="http://example.com/test">
          
          <xs:complexType name="MixedType" mixed="true">
            <xs:sequence>
              <xs:element name="emphasis" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
          
        </xs:schema>
      `;

      const result = await parser.parse(xsdContent);

      expect(result.complexTypes).toHaveLength(1);
      expect(result.complexTypes[0].mixed).toBe(true);
    });
  });

  describe('단순 타입 파싱', () => {
    it('제약 조건이 있는 단순 타입을 파싱해야 함', async () => {
      const xsdContent = `
        <?xml version="1.0" encoding="UTF-8"?>
        <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   targetNamespace="http://example.com/test">
          
          <xs:simpleType name="ZipCodeType">
            <xs:restriction base="xs:string">
              <xs:pattern value="[0-9]{5}"/>
              <xs:minLength value="5"/>
              <xs:maxLength value="5"/>
            </xs:restriction>
          </xs:simpleType>
          
          <xs:simpleType name="AgeType">
            <xs:restriction base="xs:int">
              <xs:minInclusive value="0"/>
              <xs:maxInclusive value="150"/>
            </xs:restriction>
          </xs:simpleType>
          
        </xs:schema>
      `;

      const result = await parser.parse(xsdContent);

      expect(result.simpleTypes).toHaveLength(2);
      
      const zipCodeType = result.simpleTypes.find(t => t.name === 'ZipCodeType');
      const ageType = result.simpleTypes.find(t => t.name === 'AgeType');
      
      expect(zipCodeType).toBeDefined();
      expect(ageType).toBeDefined();
      expect(zipCodeType!.baseType).toBe('xs:string');
      expect(ageType!.baseType).toBe('xs:int');
      expect(zipCodeType!.restrictions.length).toBeGreaterThan(0);
      expect(ageType!.restrictions.length).toBeGreaterThan(0);
    });

    it('열거형 단순 타입을 파싱해야 함', async () => {
      const xsdContent = `
        <?xml version="1.0" encoding="UTF-8"?>
        <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   targetNamespace="http://example.com/test">
          
          <xs:simpleType name="ColorType">
            <xs:restriction base="xs:string">
              <xs:enumeration value="red"/>
              <xs:enumeration value="green"/>
              <xs:enumeration value="blue"/>
            </xs:restriction>
          </xs:simpleType>
          
        </xs:schema>
      `;

      const result = await parser.parse(xsdContent);

      expect(result.simpleTypes).toHaveLength(1);
      
      const colorType = result.simpleTypes[0];
      expect(colorType.name).toBe('ColorType');
      expect(colorType.enumeration).toEqual(['red', 'green', 'blue']);
    });

    it('union 타입을 파싱해야 함', async () => {
      const xsdContent = `
        <?xml version="1.0" encoding="UTF-8"?>
        <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   targetNamespace="http://example.com/test">
          
          <xs:simpleType name="StringOrNumber">
            <xs:union memberTypes="xs:string xs:int"/>
          </xs:simpleType>
          
        </xs:schema>
      `;

      const result = await parser.parse(xsdContent);

      expect(result.simpleTypes).toHaveLength(1);
      expect(result.simpleTypes[0].name).toBe('StringOrNumber');
    });
  });

  describe('에러 처리', () => {
    it('잘못된 XSD 구조에 대해 에러를 반환해야 함', async () => {
      const invalidXsd = `
        <?xml version="1.0" encoding="UTF-8"?>
        <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
          <xs:complexType name="InvalidType">
            <xs:invalidElement/>
          </xs:complexType>
        </xs:schema>
      `;

      const result = await parser.parse(invalidXsd);

      // 구문적으로는 유효한 XML이지만 XSD 관점에서는 문제가 있을 수 있음
      expect(result.schema).toBeDefined();
    });

    it('스키마 루트가 없는 XML에 대해 에러를 반환해야 함', async () => {
      const nonSchemaXml = `
        <?xml version="1.0" encoding="UTF-8"?>
        <root>
          <element>value</element>
        </root>
      `;

      const result = await parser.parse(nonSchemaXml);

      expect(result.errors.length).toBeGreaterThan(0);
      expect(result.errors.some(e => e.message.includes('스키마 루트'))).toBe(true);
    });

    it('부분 실패 허용 모드에서 일부 타입 파싱 실패를 처리해야 함', async () => {
      const partiallyValidXsd = `
        <?xml version="1.0" encoding="UTF-8"?>
        <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   targetNamespace="http://example.com/test">
          
          <xs:complexType name="ValidType">
            <xs:sequence>
              <xs:element name="name" type="xs:string"/>
            </xs:sequence>
          </xs:complexType>
          
          <!-- 이 부분은 파싱에 문제가 있을 수 있음 -->
          <xs:complexType name="ProblematicType">
            <xs:sequence>
              <xs:element name="field" type="NonExistentType"/>
            </xs:sequence>
          </xs:complexType>
          
        </xs:schema>
      `;

      const result = await parser.parse(partiallyValidXsd, { allowPartialFailure: true });

      expect(result.schema).toBeDefined();
      expect(result.complexTypes.length).toBeGreaterThan(0);
      // 일부 에러가 있을 수 있지만 파싱은 계속됨
    });
  });

  describe('참조 해결', () => {
    it('타입 참조를 해결해야 함', async () => {
      const xsdContent = `
        <?xml version="1.0" encoding="UTF-8"?>
        <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   targetNamespace="http://example.com/test">
          
          <xs:element name="person" type="PersonType"/>
          
          <xs:complexType name="PersonType">
            <xs:sequence>
              <xs:element name="name" type="xs:string"/>
              <xs:element name="address" type="AddressType"/>
            </xs:sequence>
          </xs:complexType>
          
          <xs:complexType name="AddressType">
            <xs:sequence>
              <xs:element name="street" type="xs:string"/>
            </xs:sequence>
          </xs:complexType>
          
        </xs:schema>
      `;

      const result = await parser.parse(xsdContent, { resolveReferences: true });

      expect(result.schema).toBeDefined();
      expect(result.complexTypes).toHaveLength(2);
      expect(result.errors).toHaveLength(0);
    });

    it('참조 해결을 비활성화할 수 있어야 함', async () => {
      const xsdContent = `
        <?xml version="1.0" encoding="UTF-8"?>
        <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   targetNamespace="http://example.com/test">
          
          <xs:element name="person" type="PersonType"/>
          
          <xs:complexType name="PersonType">
            <xs:sequence>
              <xs:element name="name" type="xs:string"/>
            </xs:sequence>
          </xs:complexType>
          
        </xs:schema>
      `;

      const result = await parser.parse(xsdContent, { resolveReferences: false });

      expect(result.schema).toBeDefined();
      expect(result.complexTypes).toHaveLength(1);
    });
  });

  describe('네임스페이스 처리', () => {
    it('다중 네임스페이스를 가진 XSD를 파싱해야 함', async () => {
      const xsdContent = `
        <?xml version="1.0" encoding="UTF-8"?>
        <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
                   xmlns:tns="http://example.com/test"
                   xmlns:common="http://example.com/common"
                   targetNamespace="http://example.com/test">
          
          <xs:import namespace="http://example.com/common" schemaLocation="common.xsd"/>
          
          <xs:complexType name="PersonType">
            <xs:sequence>
              <xs:element name="name" type="xs:string"/>
              <xs:element name="address" type="common:AddressType"/>
            </xs:sequence>
          </xs:complexType>
          
        </xs:schema>
      `;

      const result = await parser.parse(xsdContent);

      expect(result.schema).toBeDefined();
      expect(result.schema.targetNamespace).toBe('http://example.com/test');
      expect(result.schema.imports.length).toBeGreaterThanOrEqual(0);
    });
  });
});