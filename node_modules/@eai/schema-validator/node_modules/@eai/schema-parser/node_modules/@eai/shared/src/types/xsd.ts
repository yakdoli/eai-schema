// XSD 스키마 타입 정의
import { BaseSchema, SchemaType, TypeDefinition, Constraint, ValidationResult } from './index';

export interface XSDSchema extends BaseSchema {
  type: SchemaType.XSD;
  content: XSDContent;
}

export interface XSDContent {
  schema: XSDSchemaElement;
  elements: XSDElement[];
  attributes: XSDAttribute[];
  complexTypes: XSDComplexType[];
  simpleTypes: XSDSimpleType[];
  groups: XSDGroup[];
  attributeGroups: XSDAttributeGroup[];
}

export interface XSDSchemaElement {
  targetNamespace?: string;
  elementFormDefault?: XSDFormChoice;
  attributeFormDefault?: XSDFormChoice;
  blockDefault?: string;
  finalDefault?: string;
  version?: string;
  xmlns: Record<string, string>;
}

export enum XSDFormChoice {
  QUALIFIED = 'qualified',
  UNQUALIFIED = 'unqualified',
}

export interface XSDElement {
  name: string;
  type?: string;
  ref?: string;
  minOccurs?: number;
  maxOccurs?: number | 'unbounded';
  nillable?: boolean;
  abstract?: boolean;
  substitutionGroup?: string;
  default?: string;
  fixed?: string;
  form?: XSDFormChoice;
  block?: string;
  final?: string;
  complexType?: XSDComplexType;
  simpleType?: XSDSimpleType;
  annotation?: XSDAnnotation;
}

export interface XSDAttribute {
  name: string;
  type?: string;
  ref?: string;
  use?: XSDUse;
  default?: string;
  fixed?: string;
  form?: XSDFormChoice;
  simpleType?: XSDSimpleType;
  annotation?: XSDAnnotation;
}

export enum XSDUse {
  REQUIRED = 'required',
  OPTIONAL = 'optional',
  PROHIBITED = 'prohibited',
}

export interface XSDComplexType extends TypeDefinition {
  abstract?: boolean;
  mixed?: boolean;
  block?: string;
  final?: string;
  content?: XSDComplexContent;
  attributes?: XSDAttribute[];
  attributeGroups?: XSDAttributeGroup[];
  anyAttribute?: XSDAnyAttribute;
  annotation?: XSDAnnotation;
}

export interface XSDComplexContent {
  type: XSDContentType;
  base?: string;
  elements?: XSDElement[];
  groups?: XSDGroup[];
  choice?: XSDChoice;
  sequence?: XSDSequence;
  all?: XSDAll;
}

export enum XSDContentType {
  EXTENSION = 'extension',
  RESTRICTION = 'restriction',
  SIMPLE_CONTENT = 'simpleContent',
  COMPLEX_CONTENT = 'complexContent',
}

export interface XSDSimpleType extends TypeDefinition {
  final?: string;
  restriction?: XSDRestriction;
  list?: XSDList;
  union?: XSDUnion;
  annotation?: XSDAnnotation;
}

export interface XSDRestriction {
  base: string;
  facets: XSDFacet[];
  enumeration?: string[];
  pattern?: string[];
  minInclusive?: string;
  maxInclusive?: string;
  minExclusive?: string;
  maxExclusive?: string;
  length?: number;
  minLength?: number;
  maxLength?: number;
  totalDigits?: number;
  fractionDigits?: number;
  whiteSpace?: XSDWhiteSpace;
}

export enum XSDWhiteSpace {
  PRESERVE = 'preserve',
  REPLACE = 'replace',
  COLLAPSE = 'collapse',
}

export interface XSDList {
  itemType: string;
  simpleType?: XSDSimpleType;
}

export interface XSDUnion {
  memberTypes: string[];
  simpleTypes?: XSDSimpleType[];
}

export interface XSDFacet {
  type: XSDFacetType;
  value: string;
  fixed?: boolean;
  annotation?: XSDAnnotation;
}

export enum XSDFacetType {
  ENUMERATION = 'enumeration',
  FRACTION_DIGITS = 'fractionDigits',
  LENGTH = 'length',
  MAX_EXCLUSIVE = 'maxExclusive',
  MAX_INCLUSIVE = 'maxInclusive',
  MAX_LENGTH = 'maxLength',
  MIN_EXCLUSIVE = 'minExclusive',
  MIN_INCLUSIVE = 'minInclusive',
  MIN_LENGTH = 'minLength',
  PATTERN = 'pattern',
  TOTAL_DIGITS = 'totalDigits',
  WHITE_SPACE = 'whiteSpace',
}

export interface XSDGroup {
  name?: string;
  ref?: string;
  minOccurs?: number;
  maxOccurs?: number | 'unbounded';
  choice?: XSDChoice;
  sequence?: XSDSequence;
  all?: XSDAll;
  annotation?: XSDAnnotation;
}

export interface XSDChoice {
  minOccurs?: number;
  maxOccurs?: number | 'unbounded';
  elements: XSDElement[];
  groups: XSDGroup[];
  choices: XSDChoice[];
  sequences: XSDSequence[];
  any: XSDAny[];
}

export interface XSDSequence {
  minOccurs?: number;
  maxOccurs?: number | 'unbounded';
  elements: XSDElement[];
  groups: XSDGroup[];
  choices: XSDChoice[];
  sequences: XSDSequence[];
  any: XSDAny[];
}

export interface XSDAll {
  minOccurs?: 0 | 1;
  maxOccurs?: 1;
  elements: XSDElement[];
}

export interface XSDAny {
  namespace?: string;
  processContents?: XSDProcessContents;
  minOccurs?: number;
  maxOccurs?: number | 'unbounded';
}

export enum XSDProcessContents {
  STRICT = 'strict',
  LAX = 'lax',
  SKIP = 'skip',
}

export interface XSDAttributeGroup {
  name?: string;
  ref?: string;
  attributes: XSDAttribute[];
  attributeGroups: XSDAttributeGroup[];
  anyAttribute?: XSDAnyAttribute;
  annotation?: XSDAnnotation;
}

export interface XSDAnyAttribute {
  namespace?: string;
  processContents?: XSDProcessContents;
}

export interface XSDAnnotation {
  documentation?: XSDDocumentation[];
  appInfo?: XSDAppInfo[];
}

export interface XSDDocumentation {
  source?: string;
  lang?: string;
  content: string;
}

export interface XSDAppInfo {
  source?: string;
  content: string;
}

// XSD 파싱 관련 타입
export interface XSDParseOptions {
  resolveIncludes: boolean;
  resolveImports: boolean;
  validateSchema: boolean;
  processAnnotations: boolean;
  maxDepth: number;
  timeout: number;
}

export interface XSDParseResult {
  schema: XSDSchema;
  validation: ValidationResult;
  metadata: XSDParseMetadata;
}

export interface XSDParseMetadata {
  version: string;
  elementCount: number;
  typeCount: number;
  attributeCount: number;
  namespaceCount: number;
  includes: string[];
  imports: string[];
}

// XSD 검증 관련 타입
export interface XSDValidationOptions {
  checkReferences: boolean;
  validateTypes: boolean;
  checkConstraints: boolean;
  strictMode: boolean;
}

export interface XSDValidationError {
  code: XSDErrorCode;
  message: string;
  path: string;
  line?: number;
  column?: number;
  severity: 'error' | 'warning' | 'info';
}

export enum XSDErrorCode {
  INVALID_TYPE_REFERENCE = 'INVALID_TYPE_REFERENCE',
  CIRCULAR_TYPE_DEFINITION = 'CIRCULAR_TYPE_DEFINITION',
  INVALID_FACET_VALUE = 'INVALID_FACET_VALUE',
  CONFLICTING_CONSTRAINTS = 'CONFLICTING_CONSTRAINTS',
  INVALID_NAMESPACE = 'INVALID_NAMESPACE',
  MISSING_REQUIRED_ATTRIBUTE = 'MISSING_REQUIRED_ATTRIBUTE',
  INVALID_OCCURRENCE_CONSTRAINT = 'INVALID_OCCURRENCE_CONSTRAINT',
  DUPLICATE_DEFINITION = 'DUPLICATE_DEFINITION',
}

// XSD 변환 관련 타입
export interface XSDConversionOptions {
  preserveAnnotations: boolean;
  flattenHierarchy: boolean;
  generateOptionalElements: boolean;
  includeDocumentation: boolean;
}

export interface XSDToEAIMapping {
  elements: ElementMapping[];
  types: ComplexTypeMapping[];
  simpleTypes: SimpleTypeMapping[];
  attributes: AttributeMapping[];
}

export interface ElementMapping {
  xsdElement: string;
  eaiProperty: string;
  typeMapping: string;
  constraints: Constraint[];
}

export interface ComplexTypeMapping {
  xsdType: string;
  eaiEntity: string;
  propertyMappings: XSDPropertyMapping[];
}

export interface SimpleTypeMapping {
  xsdType: string;
  eaiType: string;
  restrictions: RestrictionMapping[];
}

export interface XSDPropertyMapping {
  xsdProperty: string;
  eaiProperty: string;
  transformation?: string;
}

export interface AttributeMapping {
  xsdAttribute: string;
  eaiProperty: string;
  defaultValue?: string;
}

export interface RestrictionMapping {
  xsdRestriction: XSDFacetType;
  eaiConstraint: string;
  value: any;
}