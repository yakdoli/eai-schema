import { UnifiedSchema } from '@eai/shared';
import {
  TypeValidationResult,
  TypeIncompatibility,
  MissingType,
  InvalidConstraint,
  ValidationLocation,
  ValidationSeverity
} from '../types';

/**
 * 타입 호환성 검증기
 */
export class TypeValidator {
  private typeDefinitions = new Map<string, any>();
  private typeHierarchy = new Map<string, string>();

  /**
   * 스키마의 타입 호환성을 검증합니다
   */
  async validateTypes(schema: UnifiedSchema): Promise<TypeValidationResult> {
    // 초기화
    this.typeDefinitions.clear();
    this.typeHierarchy.clear();

    // 타입 정의 수집
    this.collectTypeDefinitions(schema);

    // 타입 검증 수행
    const incompatibleTypes = this.findIncompatibleTypes(schema);
    const missingTypes = this.findMissingTypes(schema);
    const invalidConstraints = this.findInvalidConstraints(schema);

    return {
      incompatibleTypes,
      missingTypes,
      invalidConstraints
    };
  }

  /**
   * 타입 정의를 수집합니다
   */
  private collectTypeDefinitions(schema: UnifiedSchema): void {
    // 내장 타입 등록
    this.registerBuiltInTypes();

    // 스키마에서 정의된 타입들 수집
    if (schema.content?.types) {
      schema.content.types.forEach(type => {
        this.typeDefinitions.set(type.name, type);
        
        // 타입 계층 구조 구축
        if (type.baseType) {
          this.typeHierarchy.set(type.name, type.baseType);
        }
      });
    }

    // 엔티티를 타입으로 등록
    if (schema.content?.entities) {
      schema.content.entities.forEach(entity => {
        this.typeDefinitions.set(entity.name, {
          name: entity.name,
          isComplex: true,
          properties: entity.properties
        });
      });
    }
  }

  /**
   * 내장 타입들을 등록합니다
   */
  private registerBuiltInTypes(): void {
    const builtInTypes = [
      // 기본 타입
      { name: 'string', category: 'primitive' },
      { name: 'number', category: 'primitive' },
      { name: 'integer', category: 'primitive' },
      { name: 'boolean', category: 'primitive' },
      { name: 'array', category: 'collection' },
      { name: 'object', category: 'complex' },
      
      // XML Schema 타입
      { name: 'xs:string', category: 'primitive', baseType: 'string' },
      { name: 'xs:int', category: 'primitive', baseType: 'integer' },
      { name: 'xs:integer', category: 'primitive', baseType: 'integer' },
      { name: 'xs:decimal', category: 'primitive', baseType: 'number' },
      { name: 'xs:boolean', category: 'primitive', baseType: 'boolean' },
      { name: 'xs:date', category: 'primitive' },
      { name: 'xs:dateTime', category: 'primitive' },
      { name: 'xs:time', category: 'primitive' },
      { name: 'xs:duration', category: 'primitive' },
      
      // XSD 타입 (별칭)
      { name: 'xsd:string', category: 'primitive', baseType: 'string' },
      { name: 'xsd:int', category: 'primitive', baseType: 'integer' },
      { name: 'xsd:integer', category: 'primitive', baseType: 'integer' },
      { name: 'xsd:decimal', category: 'primitive', baseType: 'number' },
      { name: 'xsd:boolean', category: 'primitive', baseType: 'boolean' },
      { name: 'xsd:date', category: 'primitive' },
      { name: 'xsd:dateTime', category: 'primitive' },
      { name: 'xsd:time', category: 'primitive' },
      { name: 'xsd:duration', category: 'primitive' }
    ];

    builtInTypes.forEach(type => {
      this.typeDefinitions.set(type.name, type);
      if (type.baseType) {
        this.typeHierarchy.set(type.name, type.baseType);
      }
    });
  }

  /**
   * 호환되지 않는 타입들을 찾습니다
   */
  private findIncompatibleTypes(schema: UnifiedSchema): TypeIncompatibility[] {
    const incompatibilities: TypeIncompatibility[] = [];

    // 엔티티 속성의 타입 호환성 검증
    if (schema.content?.entities) {
      schema.content.entities.forEach((entity, entityIndex) => {
        if (entity.properties) {
          entity.properties.forEach((property, propIndex) => {
            if (property.type) {
              const incompatibility = this.checkTypeCompatibility(
                property.type,
                property.constraints,
                {
                  path: `schema.content.entities[${entityIndex}].properties[${propIndex}].type`,
                  element: property.name
                }
              );
              
              if (incompatibility) {
                incompatibilities.push(incompatibility);
              }
            }
          });
        }
      });
    }

    // 타입 정의의 기본 타입 호환성 검증
    if (schema.content?.types) {
      schema.content.types.forEach((type, typeIndex) => {
        if (type.baseType) {
          const incompatibility = this.checkInheritanceCompatibility(
            type.name,
            type.baseType,
            {
              path: `schema.content.types[${typeIndex}].baseType`,
              element: type.name
            }
          );
          
          if (incompatibility) {
            incompatibilities.push(incompatibility);
          }
        }
      });
    }

    return incompatibilities;
  }

  /**
   * 타입 호환성을 검사합니다
   */
  private checkTypeCompatibility(
    typeName: string,
    constraints: any[] | undefined,
    location: ValidationLocation
  ): TypeIncompatibility | null {
    const typeDef = this.typeDefinitions.get(typeName);
    
    if (!typeDef) {
      return {
        sourceType: typeName,
        targetType: 'unknown',
        location,
        reason: `정의되지 않은 타입입니다: ${typeName}`,
        severity: ValidationSeverity.ERROR
      };
    }

    // 제약조건과 타입의 호환성 검사
    if (constraints && constraints.length > 0) {
      for (const constraint of constraints) {
        const constraintCompatibility = this.checkConstraintCompatibility(typeName, constraint);
        if (!constraintCompatibility.isCompatible) {
          return {
            sourceType: typeName,
            targetType: constraint.type || 'constraint',
            location,
            reason: constraintCompatibility.reason,
            severity: ValidationSeverity.WARNING
          };
        }
      }
    }

    return null;
  }

  /**
   * 상속 호환성을 검사합니다
   */
  private checkInheritanceCompatibility(
    derivedType: string,
    baseType: string,
    location: ValidationLocation
  ): TypeIncompatibility | null {
    const baseDef = this.typeDefinitions.get(baseType);
    
    if (!baseDef) {
      return {
        sourceType: derivedType,
        targetType: baseType,
        location,
        reason: `기본 타입이 정의되지 않았습니다: ${baseType}`,
        severity: ValidationSeverity.ERROR
      };
    }

    // 순환 상속 검사
    if (this.hasCircularInheritance(derivedType, baseType)) {
      return {
        sourceType: derivedType,
        targetType: baseType,
        location,
        reason: `순환 상속이 감지되었습니다: ${derivedType} -> ${baseType}`,
        severity: ValidationSeverity.ERROR
      };
    }

    return null;
  }

  /**
   * 제약조건 호환성을 검사합니다
   */
  private checkConstraintCompatibility(typeName: string, constraint: any): { isCompatible: boolean; reason: string } {
    const typeDef = this.typeDefinitions.get(typeName);
    
    if (!typeDef) {
      return { isCompatible: false, reason: '타입이 정의되지 않았습니다' };
    }

    // 숫자 타입에 대한 제약조건 검사
    if (this.isNumericType(typeName)) {
      if (constraint.minValue !== undefined && constraint.maxValue !== undefined) {
        if (constraint.minValue > constraint.maxValue) {
          return { isCompatible: false, reason: '최소값이 최대값보다 큽니다' };
        }
      }
    }

    // 문자열 타입에 대한 제약조건 검사
    if (this.isStringType(typeName)) {
      if (constraint.minLength !== undefined && constraint.maxLength !== undefined) {
        if (constraint.minLength > constraint.maxLength) {
          return { isCompatible: false, reason: '최소 길이가 최대 길이보다 큽니다' };
        }
      }
      
      if (constraint.pattern && !this.isValidRegex(constraint.pattern)) {
        return { isCompatible: false, reason: '유효하지 않은 정규식 패턴입니다' };
      }
    }

    return { isCompatible: true, reason: '' };
  }

  /**
   * 누락된 타입들을 찾습니다
   */
  private findMissingTypes(schema: UnifiedSchema): MissingType[] {
    const missingTypes: MissingType[] = [];
    const referencedTypes = new Set<string>();
    const typeReferences = new Map<string, string[]>();

    // 참조된 타입들 수집
    this.collectReferencedTypes(schema, referencedTypes, typeReferences);

    // 정의되지 않은 타입들 찾기
    for (const typeName of referencedTypes) {
      if (!this.typeDefinitions.has(typeName) && !this.isBuiltInType(typeName)) {
        missingTypes.push({
          typeName,
          referencedBy: typeReferences.get(typeName) || [],
          namespace: this.extractNamespace(typeName)
        });
      }
    }

    return missingTypes;
  }

  /**
   * 참조된 타입들을 수집합니다
   */
  private collectReferencedTypes(
    schema: UnifiedSchema,
    referencedTypes: Set<string>,
    typeReferences: Map<string, string[]>
  ): void {
    // 엔티티 속성에서 참조된 타입들
    if (schema.content?.entities) {
      schema.content.entities.forEach(entity => {
        if (entity.properties) {
          entity.properties.forEach(property => {
            if (property.type) {
              referencedTypes.add(property.type);
              this.addTypeReference(typeReferences, property.type, `${entity.name}.${property.name}`);
            }
          });
        }
      });
    }

    // 타입 정의에서 참조된 기본 타입들
    if (schema.content?.types) {
      schema.content.types.forEach(type => {
        if (type.baseType) {
          referencedTypes.add(type.baseType);
          this.addTypeReference(typeReferences, type.baseType, type.name);
        }
      });
    }
  }

  /**
   * 타입 참조를 추가합니다
   */
  private addTypeReference(typeReferences: Map<string, string[]>, typeName: string, referencedBy: string): void {
    if (!typeReferences.has(typeName)) {
      typeReferences.set(typeName, []);
    }
    typeReferences.get(typeName)?.push(referencedBy);
  }

  /**
   * 잘못된 제약조건들을 찾습니다
   */
  private findInvalidConstraints(schema: UnifiedSchema): InvalidConstraint[] {
    const invalidConstraints: InvalidConstraint[] = [];

    // 엔티티 속성의 제약조건 검증
    if (schema.content?.entities) {
      schema.content.entities.forEach((entity, entityIndex) => {
        if (entity.properties) {
          entity.properties.forEach((property, propIndex) => {
            if (property.constraints && property.constraints.length > 0) {
              // 개별 제약조건 검증
              property.constraints.forEach((constraint, constraintIndex) => {
                const validation = this.validateConstraint(constraint, property.type);
                if (!validation.isValid) {
                  invalidConstraints.push({
                    constraintType: constraint.type || 'unknown',
                    value: constraint.value,
                    location: {
                      path: `schema.content.entities[${entityIndex}].properties[${propIndex}].constraints[${constraintIndex}]`,
                      element: property.name
                    },
                    reason: validation.reason
                  });
                }
              });

              // 제약조건 간 호환성 검증 (minLength vs maxLength 등)
              this.validateConstraintCompatibility(property.constraints, property.type, {
                path: `schema.content.entities[${entityIndex}].properties[${propIndex}]`,
                element: property.name
              }, invalidConstraints);
            }
          });
        }
      });
    }

    return invalidConstraints;
  }

  /**
   * 제약조건들 간의 호환성을 검증합니다
   */
  private validateConstraintCompatibility(
    constraints: any[],
    typeName: string,
    location: any,
    invalidConstraints: InvalidConstraint[]
  ): void {
    const constraintMap = new Map<string, any>();
    
    // 제약조건들을 맵으로 변환
    constraints.forEach(constraint => {
      constraintMap.set(constraint.type, constraint);
    });

    // 문자열 타입의 길이 제약조건 검증
    if (this.isStringType(typeName)) {
      const minLength = constraintMap.get('minLength');
      const maxLength = constraintMap.get('maxLength');
      
      if (minLength && maxLength && minLength.value > maxLength.value) {
        invalidConstraints.push({
          constraintType: 'length_compatibility',
          value: { minLength: minLength.value, maxLength: maxLength.value },
          location,
          reason: `최소 길이(${minLength.value})가 최대 길이(${maxLength.value})보다 큽니다`
        });
      }
    }

    // 숫자 타입의 값 제약조건 검증
    if (this.isNumericType(typeName)) {
      const minValue = constraintMap.get('minValue');
      const maxValue = constraintMap.get('maxValue');
      
      if (minValue && maxValue && minValue.value > maxValue.value) {
        invalidConstraints.push({
          constraintType: 'value_compatibility',
          value: { minValue: minValue.value, maxValue: maxValue.value },
          location,
          reason: `최소값(${minValue.value})이 최대값(${maxValue.value})보다 큽니다`
        });
      }
    }
  }

  /**
   * 제약조건을 검증합니다
   */
  private validateConstraint(constraint: any, typeName: string): { isValid: boolean; reason: string } {
    if (!constraint.type) {
      return { isValid: false, reason: '제약조건 타입이 명시되지 않았습니다' };
    }

    switch (constraint.type) {
      case 'minLength':
      case 'maxLength':
        if (!this.isStringType(typeName)) {
          return { isValid: false, reason: '길이 제약조건은 문자열 타입에만 적용할 수 있습니다' };
        }
        if (typeof constraint.value !== 'number' || constraint.value < 0) {
          return { isValid: false, reason: '길이 제약조건 값은 0 이상의 숫자여야 합니다' };
        }
        break;

      case 'minValue':
      case 'maxValue':
        if (!this.isNumericType(typeName)) {
          return { isValid: false, reason: '값 제약조건은 숫자 타입에만 적용할 수 있습니다' };
        }
        if (typeof constraint.value !== 'number') {
          return { isValid: false, reason: '값 제약조건은 숫자여야 합니다' };
        }
        break;

      case 'pattern':
        if (!this.isStringType(typeName)) {
          return { isValid: false, reason: '패턴 제약조건은 문자열 타입에만 적용할 수 있습니다' };
        }
        if (!this.isValidRegex(constraint.value)) {
          return { isValid: false, reason: '유효하지 않은 정규식 패턴입니다' };
        }
        break;

      default:
        return { isValid: false, reason: `알 수 없는 제약조건 타입입니다: ${constraint.type}` };
    }

    return { isValid: true, reason: '' };
  }

  /**
   * 순환 상속이 있는지 확인합니다
   */
  private hasCircularInheritance(derivedType: string, baseType: string): boolean {
    const visited = new Set<string>();
    let current = baseType;

    while (current && !visited.has(current)) {
      if (current === derivedType) {
        return true;
      }
      visited.add(current);
      current = this.typeHierarchy.get(current) || '';
    }

    return false;
  }

  /**
   * 숫자 타입인지 확인합니다
   */
  private isNumericType(typeName: string): boolean {
    const numericTypes = ['number', 'integer', 'decimal', 'xs:int', 'xs:integer', 'xs:decimal', 'xsd:int', 'xsd:integer', 'xsd:decimal'];
    return numericTypes.includes(typeName.toLowerCase());
  }

  /**
   * 문자열 타입인지 확인합니다
   */
  private isStringType(typeName: string): boolean {
    const stringTypes = ['string', 'xs:string', 'xsd:string'];
    return stringTypes.includes(typeName.toLowerCase());
  }

  /**
   * 내장 타입인지 확인합니다
   */
  private isBuiltInType(typeName: string): boolean {
    return this.typeDefinitions.has(typeName) && 
           ['primitive', 'collection', 'complex'].includes(this.typeDefinitions.get(typeName)?.category);
  }

  /**
   * 유효한 정규식인지 확인합니다
   */
  private isValidRegex(pattern: string): boolean {
    try {
      new RegExp(pattern);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * 타입 이름에서 네임스페이스를 추출합니다
   */
  private extractNamespace(typeName: string): string | undefined {
    const colonIndex = typeName.indexOf(':');
    return colonIndex > 0 ? typeName.substring(0, colonIndex) : undefined;
  }
}