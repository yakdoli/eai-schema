import { UnifiedSchema } from '@eai/shared';
import {
  NamespaceValidationResult,
  NamespaceConflict,
  DuplicateDeclaration,
  AmbiguousReference,
  ConflictingElement,
  ValidationLocation
} from '../types';

/**
 * 네임스페이스 충돌 검증기
 */
export class NamespaceValidator {
  private namespaceDeclarations = new Map<string, ConflictingElement[]>();
  private prefixMappings = new Map<string, string[]>();
  private elementDeclarations = new Map<string, ConflictingElement[]>();

  /**
   * 스키마의 네임스페이스 충돌을 검증합니다
   */
  async validateNamespaces(schema: UnifiedSchema): Promise<NamespaceValidationResult> {
    // 초기화
    this.namespaceDeclarations.clear();
    this.prefixMappings.clear();
    this.elementDeclarations.clear();

    // 네임스페이스 정보 수집
    this.collectNamespaceInfo(schema);

    // 충돌 검증 수행
    const conflicts = this.findNamespaceConflicts();
    const duplicateDeclarations = this.findDuplicateDeclarations();
    const ambiguousReferences = this.findAmbiguousReferences(schema);

    return {
      conflicts,
      duplicateDeclarations,
      ambiguousReferences
    };
  }

  /**
   * 네임스페이스 정보를 수집합니다
   */
  private collectNamespaceInfo(schema: UnifiedSchema): void {
    // 메타데이터에서 네임스페이스 정보 수집
    if (schema.metadata) {
      // 타겟 네임스페이스
      if (schema.metadata.targetNamespace) {
        this.addNamespaceDeclaration(
          schema.metadata.targetNamespace,
          'targetNamespace',
          { path: 'schema.metadata.targetNamespace' }
        );
      }

      // 기본 네임스페이스
      if (schema.metadata.namespace) {
        this.addNamespaceDeclaration(
          schema.metadata.namespace,
          'defaultNamespace',
          { path: 'schema.metadata.namespace' }
        );
      }

      // 임포트된 네임스페이스
      if (schema.metadata.imports) {
        schema.metadata.imports.forEach((importRef, index) => {
          if (importRef.namespace) {
            this.addNamespaceDeclaration(
              importRef.namespace,
              'import',
              { path: `schema.metadata.imports[${index}].namespace` }
            );
          }
        });
      }
    }

    // 엔티티에서 네임스페이스 정보 수집
    this.collectEntityNamespaces(schema);

    // 타입에서 네임스페이스 정보 수집
    this.collectTypeNamespaces(schema);

    // 오퍼레이션에서 네임스페이스 정보 수집
    this.collectOperationNamespaces(schema);
  }

  /**
   * 엔티티에서 네임스페이스 정보를 수집합니다
   */
  private collectEntityNamespaces(schema: UnifiedSchema): void {
    if (schema.content?.entities) {
      schema.content.entities.forEach((entity, entityIndex) => {
        // 엔티티 이름 등록
        this.addElementDeclaration(
          entity.name,
          entity.namespace || schema.metadata?.targetNamespace || '',
          { path: `schema.content.entities[${entityIndex}].name`, element: entity.name }
        );

        // 속성에서 네임스페이스 참조 수집
        if (entity.properties) {
          entity.properties.forEach((property, propIndex) => {
            if (property.type && this.hasNamespacePrefix(property.type)) {
              const prefix = this.extractPrefix(property.type);
              this.addPrefixMapping(prefix, property.type);
            }
          });
        }
      });
    }
  }

  /**
   * 타입에서 네임스페이스 정보를 수집합니다
   */
  private collectTypeNamespaces(schema: UnifiedSchema): void {
    if (schema.content?.types) {
      schema.content.types.forEach((type, typeIndex) => {
        // 타입 이름 등록
        this.addElementDeclaration(
          type.name,
          schema.metadata?.targetNamespace || '',
          { path: `schema.content.types[${typeIndex}].name`, element: type.name }
        );

        // 기본 타입에서 네임스페이스 참조 수집
        if (type.baseType && this.hasNamespacePrefix(type.baseType)) {
          const prefix = this.extractPrefix(type.baseType);
          this.addPrefixMapping(prefix, type.baseType);
        }
      });
    }
  }

  /**
   * 오퍼레이션에서 네임스페이스 정보를 수집합니다
   */
  private collectOperationNamespaces(schema: UnifiedSchema): void {
    if (schema.content?.operations) {
      schema.content.operations.forEach((operation, opIndex) => {
        // 오퍼레이션 이름 등록
        this.addElementDeclaration(
          operation.name,
          schema.metadata?.targetNamespace || '',
          { path: `schema.content.operations[${opIndex}].name`, element: operation.name }
        );
      });
    }
  }

  /**
   * 네임스페이스 선언을 추가합니다
   */
  private addNamespaceDeclaration(namespace: string, definition: string, location: ValidationLocation): void {
    if (!this.namespaceDeclarations.has(namespace)) {
      this.namespaceDeclarations.set(namespace, []);
    }
    
    this.namespaceDeclarations.get(namespace)?.push({
      name: namespace,
      location,
      definition
    });
  }

  /**
   * 요소 선언을 추가합니다
   */
  private addElementDeclaration(name: string, namespace: string, location: ValidationLocation): void {
    const fullName = namespace ? `${namespace}:${name}` : name;
    
    if (!this.elementDeclarations.has(fullName)) {
      this.elementDeclarations.set(fullName, []);
    }
    
    this.elementDeclarations.get(fullName)?.push({
      name,
      location,
      definition: `${namespace}:${name}`
    });
  }

  /**
   * 프리픽스 매핑을 추가합니다
   */
  private addPrefixMapping(prefix: string, fullType: string): void {
    if (!this.prefixMappings.has(prefix)) {
      this.prefixMappings.set(prefix, []);
    }
    
    if (!this.prefixMappings.get(prefix)?.includes(fullType)) {
      this.prefixMappings.get(prefix)?.push(fullType);
    }
  }

  /**
   * 네임스페이스 충돌을 찾습니다
   */
  private findNamespaceConflicts(): NamespaceConflict[] {
    const conflicts: NamespaceConflict[] = [];

    // 동일한 네임스페이스에 대한 중복 선언 검사
    for (const [namespace, declarations] of this.namespaceDeclarations) {
      if (declarations.length > 1) {
        // 서로 다른 정의를 가진 중복 선언인지 확인
        const uniqueDefinitions = new Set(declarations.map(d => d.definition));
        if (uniqueDefinitions.size > 1) {
          conflicts.push({
            namespace,
            conflictingElements: declarations,
            conflictType: 'declaration'
          });
        }
      }
    }

    // 프리픽스 충돌 검사
    for (const [prefix, types] of this.prefixMappings) {
      const namespaces = new Set(types.map(type => this.extractNamespaceFromType(type)));
      if (namespaces.size > 1) {
        conflicts.push({
          namespace: prefix,
          conflictingElements: types.map(type => ({
            name: type,
            location: { path: 'unknown' }, // 실제 구현에서는 정확한 위치 추적 필요
            definition: type
          })),
          conflictType: 'prefix'
        });
      }
    }

    return conflicts;
  }

  /**
   * 중복 선언을 찾습니다
   */
  private findDuplicateDeclarations(): DuplicateDeclaration[] {
    const duplicates: DuplicateDeclaration[] = [];

    for (const [fullName, declarations] of this.elementDeclarations) {
      if (declarations.length > 1) {
        const [namespace, elementName] = this.splitFullName(fullName);
        duplicates.push({
          elementName,
          namespace,
          locations: declarations.map(d => d.location)
        });
      }
    }

    return duplicates;
  }

  /**
   * 모호한 참조를 찾습니다
   */
  private findAmbiguousReferences(schema: UnifiedSchema): AmbiguousReference[] {
    const ambiguousReferences: AmbiguousReference[] = [];

    // 엔티티 속성에서 모호한 타입 참조 검사
    if (schema.content?.entities) {
      schema.content.entities.forEach((entity, entityIndex) => {
        if (entity.properties) {
          entity.properties.forEach((property, propIndex) => {
            if (property.type && !this.hasNamespacePrefix(property.type)) {
              // 네임스페이스 없는 참조가 여러 네임스페이스에서 정의된 경우
              const possibleTargets = this.findPossibleTargets(property.type);
              if (possibleTargets.length > 1) {
                ambiguousReferences.push({
                  reference: property.type,
                  possibleTargets,
                  location: {
                    path: `schema.content.entities[${entityIndex}].properties[${propIndex}].type`,
                    element: property.name
                  }
                });
              }
            }
          });
        }
      });
    }

    return ambiguousReferences;
  }

  /**
   * 가능한 타겟들을 찾습니다
   */
  private findPossibleTargets(elementName: string): string[] {
    const targets: string[] = [];

    for (const [fullName] of this.elementDeclarations) {
      const [, name] = this.splitFullName(fullName);
      if (name === elementName) {
        targets.push(fullName);
      }
    }

    return targets;
  }

  /**
   * 네임스페이스 프리픽스가 있는지 확인합니다
   */
  private hasNamespacePrefix(typeName: string): boolean {
    return typeName.includes(':');
  }

  /**
   * 타입 이름에서 프리픽스를 추출합니다
   */
  private extractPrefix(typeName: string): string {
    const colonIndex = typeName.indexOf(':');
    return colonIndex > 0 ? typeName.substring(0, colonIndex) : '';
  }

  /**
   * 타입에서 네임스페이스를 추출합니다
   */
  private extractNamespaceFromType(typeName: string): string {
    const colonIndex = typeName.indexOf(':');
    return colonIndex > 0 ? typeName.substring(0, colonIndex) : '';
  }

  /**
   * 전체 이름을 네임스페이스와 요소 이름으로 분리합니다
   */
  private splitFullName(fullName: string): [string, string] {
    const colonIndex = fullName.indexOf(':');
    if (colonIndex > 0) {
      return [fullName.substring(0, colonIndex), fullName.substring(colonIndex + 1)];
    }
    return ['', fullName];
  }
}