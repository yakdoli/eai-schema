import { UnifiedSchema, SchemaType } from '@eai/shared';
import {
  ValidationResult,
  ValidationIssue,
  ValidationSeverity,
  ValidationIssueType,
  ValidationSummary,
  ValidationLocation
} from '../types';

/**
 * 구문적 정확성 검증기
 */
export class SyntaxValidator {
  /**
   * 스키마의 구문적 정확성을 검증합니다
   */
  async validateSyntax(schema: UnifiedSchema): Promise<ValidationResult> {
    const startTime = Date.now();
    const issues: ValidationIssue[] = [];

    try {
      // 기본 스키마 구조 검증
      this.validateBasicStructure(schema, issues);

      // 스키마 타입별 특화 검증
      await this.validateSchemaTypeSpecific(schema, issues);

      // 필수 필드 검증
      this.validateRequiredFields(schema, issues);

      // 데이터 타입 검증
      this.validateDataTypes(schema, issues);

      const summary = this.createSummary(issues);
      const executionTime = Date.now() - startTime;

      return {
        isValid: issues.filter(i => i.severity === ValidationSeverity.ERROR).length === 0,
        schemaId: schema.id,
        schemaType: schema.type,
        issues,
        summary,
        executionTime,
        timestamp: new Date()
      };
    } catch (error) {
      const issue: ValidationIssue = {
        id: `syntax-error-${Date.now()}`,
        type: ValidationIssueType.SYNTAX_ERROR,
        severity: ValidationSeverity.ERROR,
        message: '구문 검증 중 예상치 못한 오류가 발생했습니다',
        description: error instanceof Error ? error.message : String(error)
      };

      issues.push(issue);

      return {
        isValid: false,
        schemaId: schema.id,
        schemaType: schema.type,
        issues,
        summary: this.createSummary(issues),
        executionTime: Date.now() - startTime,
        timestamp: new Date()
      };
    }
  }  /*
*
   * 기본 스키마 구조를 검증합니다
   */
  private validateBasicStructure(schema: UnifiedSchema, issues: ValidationIssue[]): void {
    // 스키마 ID 검증
    if (!schema.id || typeof schema.id !== 'string') {
      issues.push({
        id: `basic-structure-${Date.now()}-1`,
        type: ValidationIssueType.SYNTAX_ERROR,
        severity: ValidationSeverity.ERROR,
        message: '스키마 ID가 누락되었거나 유효하지 않습니다',
        location: { path: 'schema.id' }
      });
    }

    // 스키마 이름 검증
    if (!schema.name || typeof schema.name !== 'string') {
      issues.push({
        id: `basic-structure-${Date.now()}-2`,
        type: ValidationIssueType.SYNTAX_ERROR,
        severity: ValidationSeverity.ERROR,
        message: '스키마 이름이 누락되었거나 유효하지 않습니다',
        location: { path: 'schema.name' }
      });
    }

    // 스키마 타입 검증
    if (!schema.type || !Object.values(SchemaType).includes(schema.type)) {
      issues.push({
        id: `basic-structure-${Date.now()}-3`,
        type: ValidationIssueType.SYNTAX_ERROR,
        severity: ValidationSeverity.ERROR,
        message: '스키마 타입이 누락되었거나 지원되지 않는 타입입니다',
        location: { path: 'schema.type' }
      });
    }

    // 메타데이터 검증
    if (!schema.metadata) {
      issues.push({
        id: `basic-structure-${Date.now()}-4`,
        type: ValidationIssueType.SYNTAX_ERROR,
        severity: ValidationSeverity.WARNING,
        message: '스키마 메타데이터가 누락되었습니다',
        location: { path: 'schema.metadata' }
      });
    }

    // 콘텐츠 검증
    if (!schema.content) {
      issues.push({
        id: `basic-structure-${Date.now()}-5`,
        type: ValidationIssueType.SYNTAX_ERROR,
        severity: ValidationSeverity.ERROR,
        message: '스키마 콘텐츠가 누락되었습니다',
        location: { path: 'schema.content' }
      });
    }
  }

  /**
   * 스키마 타입별 특화 검증을 수행합니다
   */
  private async validateSchemaTypeSpecific(schema: UnifiedSchema, issues: ValidationIssue[]): Promise<void> {
    switch (schema.type) {
      case SchemaType.WSDL:
        this.validateWSDLSyntax(schema, issues);
        break;
      case SchemaType.XSD:
        this.validateXSDSyntax(schema, issues);
        break;
      case SchemaType.JSON_SCHEMA:
        this.validateJSONSchemaSyntax(schema, issues);
        break;
      case SchemaType.OPENAPI:
        this.validateOpenAPISyntax(schema, issues);
        break;
      default:
        issues.push({
          id: `schema-type-${Date.now()}`,
          type: ValidationIssueType.SYNTAX_ERROR,
          severity: ValidationSeverity.WARNING,
          message: `알 수 없는 스키마 타입입니다: ${schema.type}`,
          location: { path: 'schema.type' }
        });
    }
  }

  /**
   * WSDL 스키마 구문 검증
   */
  private validateWSDLSyntax(schema: UnifiedSchema, issues: ValidationIssue[]): void {
    if (!schema.content?.operations || !Array.isArray(schema.content.operations) || schema.content.operations.length === 0) {
      issues.push({
        id: `wsdl-syntax-${Date.now()}-1`,
        type: ValidationIssueType.SYNTAX_ERROR,
        severity: ValidationSeverity.ERROR,
        message: 'WSDL 스키마에 오퍼레이션 정의가 누락되었습니다',
        location: { path: 'schema.content.operations' }
      });
    }

    if (!schema.content?.bindings || !Array.isArray(schema.content.bindings)) {
      issues.push({
        id: `wsdl-syntax-${Date.now()}-2`,
        type: ValidationIssueType.SYNTAX_ERROR,
        severity: ValidationSeverity.WARNING,
        message: 'WSDL 스키마에 바인딩 정의가 누락되었습니다',
        location: { path: 'schema.content.bindings' }
      });
    }
  }

  /**
   * XSD 스키마 구문 검증
   */
  private validateXSDSyntax(schema: UnifiedSchema, issues: ValidationIssue[]): void {
    if (!schema.content?.types || !Array.isArray(schema.content.types)) {
      issues.push({
        id: `xsd-syntax-${Date.now()}-1`,
        type: ValidationIssueType.SYNTAX_ERROR,
        severity: ValidationSeverity.ERROR,
        message: 'XSD 스키마에 타입 정의가 누락되었습니다',
        location: { path: 'schema.content.types' }
      });
    }

    // 타겟 네임스페이스 검증
    if (!schema.metadata?.targetNamespace) {
      issues.push({
        id: `xsd-syntax-${Date.now()}-2`,
        type: ValidationIssueType.SYNTAX_ERROR,
        severity: ValidationSeverity.WARNING,
        message: 'XSD 스키마에 타겟 네임스페이스가 정의되지 않았습니다',
        location: { path: 'schema.metadata.targetNamespace' }
      });
    }
  }

  /**
   * JSON Schema 구문 검증
   */
  private validateJSONSchemaSyntax(schema: UnifiedSchema, issues: ValidationIssue[]): void {
    // JSON Schema 버전 검증
    if (!schema.version) {
      issues.push({
        id: `json-schema-syntax-${Date.now()}-1`,
        type: ValidationIssueType.SYNTAX_ERROR,
        severity: ValidationSeverity.WARNING,
        message: 'JSON Schema 버전이 명시되지 않았습니다',
        location: { path: 'schema.version' }
      });
    }

    // 스키마 정의 검증
    if (!schema.content?.types || schema.content.types.length === 0) {
      issues.push({
        id: `json-schema-syntax-${Date.now()}-2`,
        type: ValidationIssueType.SYNTAX_ERROR,
        severity: ValidationSeverity.ERROR,
        message: 'JSON Schema에 타입 정의가 누락되었습니다',
        location: { path: 'schema.content.types' }
      });
    }
  }

  /**
   * OpenAPI 스키마 구문 검증
   */
  private validateOpenAPISyntax(schema: UnifiedSchema, issues: ValidationIssue[]): void {
    // OpenAPI 버전 검증
    if (!schema.version) {
      issues.push({
        id: `openapi-syntax-${Date.now()}-1`,
        type: ValidationIssueType.SYNTAX_ERROR,
        severity: ValidationSeverity.ERROR,
        message: 'OpenAPI 버전이 명시되지 않았습니다',
        location: { path: 'schema.version' }
      });
    }

    // 경로 정의 검증
    if (!schema.content?.operations || schema.content.operations.length === 0) {
      issues.push({
        id: `openapi-syntax-${Date.now()}-2`,
        type: ValidationIssueType.SYNTAX_ERROR,
        severity: ValidationSeverity.ERROR,
        message: 'OpenAPI 스키마에 경로 정의가 누락되었습니다',
        location: { path: 'schema.content.operations' }
      });
    }
  }

  /**
   * 필수 필드 검증
   */
  private validateRequiredFields(schema: UnifiedSchema, issues: ValidationIssue[]): void {
    // 엔티티 필수 필드 검증
    if (schema.content?.entities) {
      schema.content.entities.forEach((entity, index) => {
        if (!entity.name) {
          issues.push({
            id: `required-field-${Date.now()}-entity-${index}`,
            type: ValidationIssueType.MISSING_REQUIRED,
            severity: ValidationSeverity.ERROR,
            message: `엔티티 이름이 누락되었습니다 (인덱스: ${index})`,
            location: { path: `schema.content.entities[${index}].name` }
          });
        }

        if (!entity.properties || !Array.isArray(entity.properties)) {
          issues.push({
            id: `required-field-${Date.now()}-entity-props-${index}`,
            type: ValidationIssueType.MISSING_REQUIRED,
            severity: ValidationSeverity.WARNING,
            message: `엔티티 속성이 정의되지 않았습니다: ${entity.name}`,
            location: { path: `schema.content.entities[${index}].properties` }
          });
        }
      });
    }

    // 타입 정의 필수 필드 검증
    if (schema.content?.types) {
      schema.content.types.forEach((type, index) => {
        if (!type.name) {
          issues.push({
            id: `required-field-${Date.now()}-type-${index}`,
            type: ValidationIssueType.MISSING_REQUIRED,
            severity: ValidationSeverity.ERROR,
            message: `타입 이름이 누락되었습니다 (인덱스: ${index})`,
            location: { path: `schema.content.types[${index}].name` }
          });
        }
      });
    }

    // 오퍼레이션 필수 필드 검증
    if (schema.content?.operations) {
      schema.content.operations.forEach((operation, index) => {
        if (!operation.name) {
          issues.push({
            id: `required-field-${Date.now()}-operation-${index}`,
            type: ValidationIssueType.MISSING_REQUIRED,
            severity: ValidationSeverity.ERROR,
            message: `오퍼레이션 이름이 누락되었습니다 (인덱스: ${index})`,
            location: { path: `schema.content.operations[${index}].name` }
          });
        }
      });
    }
  }

  /**
   * 데이터 타입 검증
   */
  private validateDataTypes(schema: UnifiedSchema, issues: ValidationIssue[]): void {
    // 엔티티 속성 타입 검증
    if (schema.content?.entities) {
      schema.content.entities.forEach((entity, entityIndex) => {
        if (entity.properties) {
          entity.properties.forEach((property, propIndex) => {
            if (!property.type) {
              issues.push({
                id: `data-type-${Date.now()}-prop-${entityIndex}-${propIndex}`,
                type: ValidationIssueType.TYPE_MISMATCH,
                severity: ValidationSeverity.ERROR,
                message: `속성 타입이 정의되지 않았습니다: ${entity.name}.${property.name}`,
                location: { 
                  path: `schema.content.entities[${entityIndex}].properties[${propIndex}].type`,
                  element: property.name
                }
              });
            }
          });
        }
      });
    }
  }

  /**
   * 검증 결과 요약을 생성합니다
   */
  private createSummary(issues: ValidationIssue[]): ValidationSummary {
    const errorCount = issues.filter(i => i.severity === ValidationSeverity.ERROR).length;
    const warningCount = issues.filter(i => i.severity === ValidationSeverity.WARNING).length;
    const infoCount = issues.filter(i => i.severity === ValidationSeverity.INFO).length;

    return {
      totalIssues: issues.length,
      errorCount,
      warningCount,
      infoCount,
      validatedElements: 0, // 실제 구현에서는 검증된 요소 수를 계산
      skippedElements: 0    // 실제 구현에서는 건너뛴 요소 수를 계산
    };
  }
}