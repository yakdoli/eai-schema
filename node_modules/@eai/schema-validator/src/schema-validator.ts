import { UnifiedSchema } from '@eai/shared';
import { ISchemaValidator } from './interfaces/validator';
import {
  ValidationResult,
  ValidationOptions,
  ReferenceValidationResult,
  NamespaceValidationResult,
  TypeValidationResult,
  ValidationReport,
  ValidationSeverity
} from './types';
import { SyntaxValidator } from './validators/syntax-validator';
import { ReferenceValidator } from './validators/reference-validator';
import { NamespaceValidator } from './validators/namespace-validator';
import { TypeValidator } from './validators/type-validator';
import { ReportGenerator } from './generators/report-generator';

/**
 * 메인 스키마 검증 엔진
 */
export class SchemaValidator implements ISchemaValidator {
  private syntaxValidator: SyntaxValidator;
  private referenceValidator: ReferenceValidator;
  private namespaceValidator: NamespaceValidator;
  private typeValidator: TypeValidator;
  private reportGenerator: ReportGenerator;

  constructor() {
    this.syntaxValidator = new SyntaxValidator();
    this.referenceValidator = new ReferenceValidator();
    this.namespaceValidator = new NamespaceValidator();
    this.typeValidator = new TypeValidator();
    this.reportGenerator = new ReportGenerator();
  }

  /**
   * 스키마 전체 검증을 수행합니다
   */
  async validate(schema: UnifiedSchema, options?: ValidationOptions): Promise<ValidationResult> {
    const startTime = Date.now();
    
    try {
      // 기본 옵션 설정
      const validationOptions = {
        strictMode: false,
        skipWarnings: false,
        maxIssues: 1000,
        validateReferences: true,
        validateNamespaces: true,
        validateTypes: true,
        ...options
      };

      // 구문 검증
      const syntaxResult = await this.validateSyntax(schema);
      
      // 에러가 있고 strict 모드인 경우 조기 종료
      if (validationOptions.strictMode && syntaxResult.issues.some(i => i.severity === ValidationSeverity.ERROR)) {
        return syntaxResult;
      }

      const allIssues = [...syntaxResult.issues];

      // 참조 무결성 검증
      if (validationOptions.validateReferences) {
        const referenceResult = await this.validateReferences(schema);
        // 참조 검증 결과를 이슈로 변환하여 추가
        // (실제 구현에서는 ReportGenerator의 메서드를 사용)
      }

      // 네임스페이스 검증
      if (validationOptions.validateNamespaces) {
        const namespaceResult = await this.validateNamespaces(schema);
        // 네임스페이스 검증 결과를 이슈로 변환하여 추가
      }

      // 타입 호환성 검증
      if (validationOptions.validateTypes) {
        const typeResult = await this.validateTypes(schema);
        // 타입 검증 결과를 이슈로 변환하여 추가
      }

      // 경고 필터링
      const filteredIssues = validationOptions.skipWarnings 
        ? allIssues.filter(i => i.severity !== ValidationSeverity.WARNING)
        : allIssues;

      // 최대 이슈 수 제한
      const limitedIssues = validationOptions.maxIssues 
        ? filteredIssues.slice(0, validationOptions.maxIssues)
        : filteredIssues;

      // 커스텀 규칙 적용
      if (validationOptions.customRules) {
        for (const rule of validationOptions.customRules) {
          if (rule.schemaTypes.includes(schema.type)) {
            const customIssues = rule.validator(schema);
            limitedIssues.push(...customIssues);
          }
        }
      }

      const executionTime = Date.now() - startTime;
      const summary = this.createSummary(limitedIssues);

      return {
        isValid: limitedIssues.filter(i => i.severity === ValidationSeverity.ERROR).length === 0,
        schemaId: schema.id,
        schemaType: schema.type,
        issues: limitedIssues,
        summary,
        executionTime,
        timestamp: new Date()
      };

    } catch (error) {
      const executionTime = Date.now() - startTime;
      
      return {
        isValid: false,
        schemaId: schema.id,
        schemaType: schema.type,
        issues: [{
          id: `validation-error-${Date.now()}`,
          type: 'syntax_error' as any,
          severity: ValidationSeverity.ERROR,
          message: '검증 중 예상치 못한 오류가 발생했습니다',
          description: error instanceof Error ? error.message : String(error)
        }],
        summary: {
          totalIssues: 1,
          errorCount: 1,
          warningCount: 0,
          infoCount: 0,
          validatedElements: 0,
          skippedElements: 0
        },
        executionTime,
        timestamp: new Date()
      };
    }
  }

  /**
   * 구문적 정확성 검증
   */
  async validateSyntax(schema: UnifiedSchema): Promise<ValidationResult> {
    return this.syntaxValidator.validateSyntax(schema);
  }

  /**
   * 참조 무결성 검증
   */
  async validateReferences(schema: UnifiedSchema): Promise<ReferenceValidationResult> {
    return this.referenceValidator.validateReferences(schema);
  }

  /**
   * 네임스페이스 충돌 검증
   */
  async validateNamespaces(schema: UnifiedSchema): Promise<NamespaceValidationResult> {
    return this.namespaceValidator.validateNamespaces(schema);
  }

  /**
   * 타입 호환성 검증
   */
  async validateTypes(schema: UnifiedSchema): Promise<TypeValidationResult> {
    return this.typeValidator.validateTypes(schema);
  }  /*
*
   * 검증 리포트 생성
   */
  async generateReport(results: ValidationResult[]): Promise<ValidationReport> {
    if (results.length === 0) {
      throw new Error('검증 결과가 없습니다');
    }

    const firstResult = results[0];
    const mockSchema: UnifiedSchema = {
      id: firstResult.schemaId,
      name: 'Unknown Schema',
      type: firstResult.schemaType,
      version: '1.0.0',
      originalFormat: '',
      metadata: {
        imports: [],
        annotations: []
      },
      content: {
        entities: [],
        types: [],
        operations: [],
        bindings: []
      },
      sourceSchema: {} as any,
      conversionMetadata: {
        sourceType: firstResult.schemaType,
        targetType: firstResult.schemaType,
        conversionTime: 0,
        rulesApplied: [],
        warnings: [],
        lossyConversion: false,
        fidelityScore: 100
      },
      validationResult: {
        isValid: true,
        errors: [],
        warnings: [],
        infos: []
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };

    return this.reportGenerator.generateReport(mockSchema, results);
  }

  /**
   * 통합 검증을 수행하고 리포트를 생성합니다
   */
  async validateAndGenerateReport(schema: UnifiedSchema, options?: ValidationOptions): Promise<ValidationReport> {
    const startTime = Date.now();

    // 모든 검증 수행
    const syntaxResult = await this.validateSyntax(schema);
    const referenceResult = options?.validateReferences !== false 
      ? await this.validateReferences(schema) 
      : undefined;
    const namespaceResult = options?.validateNamespaces !== false 
      ? await this.validateNamespaces(schema) 
      : undefined;
    const typeResult = options?.validateTypes !== false 
      ? await this.validateTypes(schema) 
      : undefined;

    // 통합 리포트 생성
    const report = await this.reportGenerator.generateReport(
      schema,
      [syntaxResult],
      referenceResult,
      namespaceResult,
      typeResult
    );

    // 실행 시간 업데이트
    report.executionTime = Date.now() - startTime;

    return report;
  }

  /**
   * 검증 결과 요약을 생성합니다
   */
  private createSummary(issues: any[]): any {
    const errorCount = issues.filter(i => i.severity === ValidationSeverity.ERROR).length;
    const warningCount = issues.filter(i => i.severity === ValidationSeverity.WARNING).length;
    const infoCount = issues.filter(i => i.severity === ValidationSeverity.INFO).length;

    return {
      totalIssues: issues.length,
      errorCount,
      warningCount,
      infoCount,
      validatedElements: 0, // 실제 구현에서는 검증된 요소 수를 계산
      skippedElements: 0    // 실제 구현에서는 건너뛴 요소 수를 계산
    };
  }

  /**
   * 배치 검증을 수행합니다
   */
  async validateBatch(schemas: UnifiedSchema[], options?: ValidationOptions): Promise<ValidationReport[]> {
    const reports: ValidationReport[] = [];

    for (const schema of schemas) {
      try {
        const report = await this.validateAndGenerateReport(schema, options);
        reports.push(report);
      } catch (error) {
        // 개별 스키마 검증 실패 시에도 계속 진행
        const errorReport: ValidationReport = {
          id: `error-report-${Date.now()}`,
          schemaId: schema.id,
          schemaName: schema.name,
          schemaType: schema.type,
          validationResults: [{
            isValid: false,
            schemaId: schema.id,
            schemaType: schema.type,
            issues: [{
              id: `batch-error-${Date.now()}`,
              type: 'syntax_error' as any,
              severity: ValidationSeverity.ERROR,
              message: '배치 검증 중 오류가 발생했습니다',
              description: error instanceof Error ? error.message : String(error)
            }],
            summary: {
              totalIssues: 1,
              errorCount: 1,
              warningCount: 0,
              infoCount: 0,
              validatedElements: 0,
              skippedElements: 0
            },
            executionTime: 0,
            timestamp: new Date()
          }],
          overallStatus: 'invalid',
          summary: {
            totalIssues: 1,
            errorCount: 1,
            warningCount: 0,
            infoCount: 0,
            validatedElements: 0,
            skippedElements: 0
          },
          generatedAt: new Date(),
          executionTime: 0
        };
        reports.push(errorReport);
      }
    }

    return reports;
  }

  /**
   * 검증 통계를 생성합니다
   */
  generateValidationStatistics(reports: ValidationReport[]): {
    totalSchemas: number;
    validSchemas: number;
    invalidSchemas: number;
    warningSchemas: number;
    totalIssues: number;
    totalErrors: number;
    totalWarnings: number;
    averageExecutionTime: number;
  } {
    const totalSchemas = reports.length;
    const validSchemas = reports.filter(r => r.overallStatus === 'valid').length;
    const invalidSchemas = reports.filter(r => r.overallStatus === 'invalid').length;
    const warningSchemas = reports.filter(r => r.overallStatus === 'warning').length;
    
    const totalIssues = reports.reduce((sum, r) => sum + r.summary.totalIssues, 0);
    const totalErrors = reports.reduce((sum, r) => sum + r.summary.errorCount, 0);
    const totalWarnings = reports.reduce((sum, r) => sum + r.summary.warningCount, 0);
    
    const averageExecutionTime = reports.length > 0 
      ? reports.reduce((sum, r) => sum + r.executionTime, 0) / reports.length 
      : 0;

    return {
      totalSchemas,
      validSchemas,
      invalidSchemas,
      warningSchemas,
      totalIssues,
      totalErrors,
      totalWarnings,
      averageExecutionTime
    };
  }
}