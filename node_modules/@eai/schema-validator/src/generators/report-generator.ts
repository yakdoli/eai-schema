import { UnifiedSchema } from '@eai/shared';
import {
  ValidationResult,
  ValidationReport,
  ValidationSummary,
  ValidationIssue,
  ValidationSeverity,
  ReferenceValidationResult,
  NamespaceValidationResult,
  TypeValidationResult,
  ValidationIssueType
} from '../types';

/**
 * 검증 리포트 생성기
 */
export class ReportGenerator {
  /**
   * 검증 결과들로부터 통합 리포트를 생성합니다
   */
  async generateReport(
    schema: UnifiedSchema,
    validationResults: ValidationResult[],
    referenceResult?: ReferenceValidationResult,
    namespaceResult?: NamespaceValidationResult,
    typeResult?: TypeValidationResult
  ): Promise<ValidationReport> {
    const reportId = this.generateReportId();
    const allIssues = this.consolidateIssues(validationResults, referenceResult, namespaceResult, typeResult);
    const overallSummary = this.createOverallSummary(allIssues);
    const overallStatus = this.determineOverallStatus(allIssues);
    const totalExecutionTime = validationResults.reduce((sum, result) => sum + result.executionTime, 0);

    return {
      id: reportId,
      schemaId: schema.id,
      schemaName: schema.name,
      schemaType: schema.type,
      validationResults,
      overallStatus,
      summary: overallSummary,
      generatedAt: new Date(),
      executionTime: totalExecutionTime
    };
  }

  /**
   * 모든 검증 결과에서 이슈들을 통합합니다
   */
  private consolidateIssues(
    validationResults: ValidationResult[],
    referenceResult?: ReferenceValidationResult,
    namespaceResult?: NamespaceValidationResult,
    typeResult?: TypeValidationResult
  ): ValidationIssue[] {
    const allIssues: ValidationIssue[] = [];

    // 기본 검증 결과에서 이슈 수집
    validationResults.forEach(result => {
      allIssues.push(...result.issues);
    });

    // 참조 무결성 검증 결과에서 이슈 생성
    if (referenceResult) {
      allIssues.push(...this.createReferenceIssues(referenceResult));
    }

    // 네임스페이스 검증 결과에서 이슈 생성
    if (namespaceResult) {
      allIssues.push(...this.createNamespaceIssues(namespaceResult));
    }

    // 타입 검증 결과에서 이슈 생성
    if (typeResult) {
      allIssues.push(...this.createTypeIssues(typeResult));
    }

    return this.deduplicateIssues(allIssues);
  }

  /**
   * 참조 무결성 검증 결과에서 이슈를 생성합니다
   */
  private createReferenceIssues(referenceResult: ReferenceValidationResult): ValidationIssue[] {
    const issues: ValidationIssue[] = [];

    // 누락된 참조 이슈
    referenceResult.missingReferences.forEach((missingRef, index) => {
      issues.push({
        id: `missing-ref-${Date.now()}-${index}`,
        type: ValidationIssueType.REFERENCE_ERROR,
        severity: ValidationSeverity.ERROR,
        message: `참조를 찾을 수 없습니다: ${missingRef.targetReference}`,
        description: `${missingRef.referencingElement}에서 ${missingRef.targetReference}를 참조하지만 정의를 찾을 수 없습니다`,
        location: missingRef.referencingLocation,
        suggestion: `${missingRef.targetReference} 타입을 정의하거나 올바른 참조로 수정하세요`
      });
    });

    // 순환 참조 이슈
    referenceResult.circularReferences.forEach((circularRef, index) => {
      issues.push({
        id: `circular-ref-${Date.now()}-${index}`,
        type: ValidationIssueType.REFERENCE_ERROR,
        severity: ValidationSeverity.WARNING,
        message: `순환 참조가 감지되었습니다`,
        description: `참조 경로: ${circularRef.path.join(' -> ')}`,
        suggestion: '순환 참조를 제거하거나 적절한 참조 구조로 변경하세요'
      });
    });

    // 해결되지 않은 임포트 이슈
    referenceResult.unresolvedImports.forEach((unresolvedImport, index) => {
      issues.push({
        id: `unresolved-import-${Date.now()}-${index}`,
        type: ValidationIssueType.REFERENCE_ERROR,
        severity: ValidationSeverity.ERROR,
        message: `임포트를 해결할 수 없습니다: ${unresolvedImport.importPath}`,
        description: unresolvedImport.reason,
        location: unresolvedImport.location,
        suggestion: '임포트 경로를 확인하고 올바른 스키마 위치를 지정하세요'
      });
    });

    return issues;
  }

  /**
   * 네임스페이스 검증 결과에서 이슈를 생성합니다
   */
  private createNamespaceIssues(namespaceResult: NamespaceValidationResult): ValidationIssue[] {
    const issues: ValidationIssue[] = [];

    // 네임스페이스 충돌 이슈
    namespaceResult.conflicts.forEach((conflict, index) => {
      issues.push({
        id: `namespace-conflict-${Date.now()}-${index}`,
        type: ValidationIssueType.NAMESPACE_CONFLICT,
        severity: ValidationSeverity.ERROR,
        message: `네임스페이스 충돌: ${conflict.namespace}`,
        description: `${conflict.conflictType} 충돌이 감지되었습니다`,
        suggestion: '네임스페이스 선언을 확인하고 충돌을 해결하세요'
      });
    });

    // 중복 선언 이슈
    namespaceResult.duplicateDeclarations.forEach((duplicate, index) => {
      issues.push({
        id: `duplicate-declaration-${Date.now()}-${index}`,
        type: ValidationIssueType.NAMESPACE_CONFLICT,
        severity: ValidationSeverity.WARNING,
        message: `중복 선언: ${duplicate.elementName}`,
        description: `${duplicate.namespace ? `네임스페이스 ${duplicate.namespace}에서 ` : ''}${duplicate.elementName}이(가) 여러 번 선언되었습니다`,
        suggestion: '중복된 선언을 제거하거나 다른 이름을 사용하세요'
      });
    });

    // 모호한 참조 이슈
    namespaceResult.ambiguousReferences.forEach((ambiguous, index) => {
      issues.push({
        id: `ambiguous-reference-${Date.now()}-${index}`,
        type: ValidationIssueType.NAMESPACE_CONFLICT,
        severity: ValidationSeverity.WARNING,
        message: `모호한 참조: ${ambiguous.reference}`,
        description: `여러 가능한 타겟이 있습니다: ${ambiguous.possibleTargets.join(', ')}`,
        location: ambiguous.location,
        suggestion: '네임스페이스를 명시하여 참조를 명확하게 하세요'
      });
    });

    return issues;
  }  
/**
   * 타입 검증 결과에서 이슈를 생성합니다
   */
  private createTypeIssues(typeResult: TypeValidationResult): ValidationIssue[] {
    const issues: ValidationIssue[] = [];

    // 타입 비호환성 이슈
    typeResult.incompatibleTypes.forEach((incompatible, index) => {
      issues.push({
        id: `type-incompatible-${Date.now()}-${index}`,
        type: ValidationIssueType.TYPE_MISMATCH,
        severity: incompatible.severity,
        message: `타입 비호환성: ${incompatible.sourceType} -> ${incompatible.targetType}`,
        description: incompatible.reason,
        location: incompatible.location,
        suggestion: '호환되는 타입으로 변경하거나 타입 변환을 추가하세요'
      });
    });

    // 누락된 타입 이슈
    typeResult.missingTypes.forEach((missingType, index) => {
      issues.push({
        id: `type-missing-${Date.now()}-${index}`,
        type: ValidationIssueType.REFERENCE_ERROR,
        severity: ValidationSeverity.ERROR,
        message: `누락된 타입: ${missingType.typeName}`,
        description: `다음 요소들에서 참조됨: ${missingType.referencedBy.join(', ')}`,
        suggestion: `${missingType.typeName} 타입을 정의하세요`
      });
    });

    // 잘못된 제약조건 이슈
    typeResult.invalidConstraints.forEach((invalidConstraint, index) => {
      issues.push({
        id: `constraint-invalid-${Date.now()}-${index}`,
        type: ValidationIssueType.INVALID_FORMAT,
        severity: ValidationSeverity.WARNING,
        message: `잘못된 제약조건: ${invalidConstraint.constraintType}`,
        description: invalidConstraint.reason,
        location: invalidConstraint.location,
        suggestion: '제약조건을 수정하거나 제거하세요'
      });
    });

    return issues;
  }

  /**
   * 중복된 이슈들을 제거합니다
   */
  private deduplicateIssues(issues: ValidationIssue[]): ValidationIssue[] {
    const seen = new Set<string>();
    const deduplicated: ValidationIssue[] = [];

    issues.forEach(issue => {
      const key = `${issue.type}-${issue.message}-${issue.location?.path || ''}`;
      if (!seen.has(key)) {
        seen.add(key);
        deduplicated.push(issue);
      }
    });

    return deduplicated;
  }

  /**
   * 전체 요약을 생성합니다
   */
  private createOverallSummary(issues: ValidationIssue[]): ValidationSummary {
    const errorCount = issues.filter(i => i.severity === ValidationSeverity.ERROR).length;
    const warningCount = issues.filter(i => i.severity === ValidationSeverity.WARNING).length;
    const infoCount = issues.filter(i => i.severity === ValidationSeverity.INFO).length;

    return {
      totalIssues: issues.length,
      errorCount,
      warningCount,
      infoCount,
      validatedElements: 0, // 실제 구현에서는 검증된 요소 수를 계산
      skippedElements: 0    // 실제 구현에서는 건너뛴 요소 수를 계산
    };
  }

  /**
   * 전체 상태를 결정합니다
   */
  private determineOverallStatus(issues: ValidationIssue[]): 'valid' | 'invalid' | 'warning' {
    const hasErrors = issues.some(i => i.severity === ValidationSeverity.ERROR);
    const hasWarnings = issues.some(i => i.severity === ValidationSeverity.WARNING);

    if (hasErrors) {
      return 'invalid';
    } else if (hasWarnings) {
      return 'warning';
    } else {
      return 'valid';
    }
  }

  /**
   * 리포트 ID를 생성합니다
   */
  private generateReportId(): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8);
    return `validation-report-${timestamp}-${random}`;
  }

  /**
   * HTML 형태의 리포트를 생성합니다
   */
  async generateHTMLReport(report: ValidationReport): Promise<string> {
    const html = `
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>스키마 검증 리포트 - ${report.schemaName}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background-color: #f5f5f5; padding: 20px; border-radius: 5px; }
        .summary { display: flex; gap: 20px; margin: 20px 0; }
        .summary-item { background: white; padding: 15px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .error { color: #d32f2f; }
        .warning { color: #f57c00; }
        .info { color: #1976d2; }
        .valid { color: #388e3c; }
        .issue { margin: 10px 0; padding: 15px; border-left: 4px solid; }
        .issue.error { border-color: #d32f2f; background-color: #ffebee; }
        .issue.warning { border-color: #f57c00; background-color: #fff3e0; }
        .issue.info { border-color: #1976d2; background-color: #e3f2fd; }
    </style>
</head>
<body>
    <div class="header">
        <h1>스키마 검증 리포트</h1>
        <p><strong>스키마:</strong> ${report.schemaName} (${report.schemaType})</p>
        <p><strong>생성일시:</strong> ${report.generatedAt.toLocaleString('ko-KR')}</p>
        <p><strong>실행시간:</strong> ${report.executionTime}ms</p>
        <p><strong>전체 상태:</strong> <span class="${report.overallStatus}">${this.getStatusText(report.overallStatus)}</span></p>
    </div>

    <div class="summary">
        <div class="summary-item">
            <h3>총 이슈</h3>
            <p>${report.summary.totalIssues}</p>
        </div>
        <div class="summary-item">
            <h3 class="error">에러</h3>
            <p>${report.summary.errorCount}</p>
        </div>
        <div class="summary-item">
            <h3 class="warning">경고</h3>
            <p>${report.summary.warningCount}</p>
        </div>
        <div class="summary-item">
            <h3 class="info">정보</h3>
            <p>${report.summary.infoCount}</p>
        </div>
    </div>

    <h2>검증 결과 상세</h2>
    ${this.generateIssuesHTML(report.validationResults)}
</body>
</html>`;

    return html;
  }

  /**
   * 이슈들의 HTML을 생성합니다
   */
  private generateIssuesHTML(validationResults: ValidationResult[]): string {
    let html = '';

    validationResults.forEach(result => {
      if (result.issues.length > 0) {
        html += `<h3>검증 결과: ${result.schemaType}</h3>`;
        
        result.issues.forEach(issue => {
          html += `
            <div class="issue ${issue.severity}">
                <h4>${issue.message}</h4>
                ${issue.description ? `<p>${issue.description}</p>` : ''}
                ${issue.location ? `<p><strong>위치:</strong> ${issue.location.path}</p>` : ''}
                ${issue.suggestion ? `<p><strong>제안:</strong> ${issue.suggestion}</p>` : ''}
            </div>`;
        });
      }
    });

    return html || '<p>검증 이슈가 없습니다.</p>';
  }

  /**
   * 상태 텍스트를 반환합니다
   */
  private getStatusText(status: string): string {
    switch (status) {
      case 'valid': return '유효';
      case 'invalid': return '무효';
      case 'warning': return '경고';
      default: return '알 수 없음';
    }
  }

  /**
   * JSON 형태의 리포트를 생성합니다
   */
  async generateJSONReport(report: ValidationReport): Promise<string> {
    return JSON.stringify(report, null, 2);
  }

  /**
   * CSV 형태의 이슈 리포트를 생성합니다
   */
  async generateCSVReport(report: ValidationReport): Promise<string> {
    const headers = ['ID', '타입', '심각도', '메시지', '설명', '위치', '제안'];
    const rows = [headers.join(',')];

    report.validationResults.forEach(result => {
      result.issues.forEach(issue => {
        const row = [
          issue.id,
          issue.type,
          issue.severity,
          `"${issue.message.replace(/"/g, '""')}"`,
          `"${(issue.description || '').replace(/"/g, '""')}"`,
          `"${(issue.location?.path || '').replace(/"/g, '""')}"`,
          `"${(issue.suggestion || '').replace(/"/g, '""')}"`
        ];
        rows.push(row.join(','));
      });
    });

    return rows.join('\n');
  }
}