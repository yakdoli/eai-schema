import { ReportGenerator } from '../../generators/report-generator';
import { UnifiedSchema, SchemaType } from '@eai/shared';
import { ValidationResult, ValidationSeverity, ValidationIssueType } from '../../types';

describe('ReportGenerator', () => {
  let generator: ReportGenerator;
  let mockSchema: UnifiedSchema;
  let mockValidationResult: ValidationResult;

  beforeEach(() => {
    generator = new ReportGenerator();
    
    mockSchema = {
      id: 'test-schema',
      name: 'Test Schema',
      type: SchemaType.XSD,
      version: '1.0.0',
      originalFormat: 'application/xml',
      metadata: {},
      content: {},
      createdAt: new Date(),
      updatedAt: new Date()
    };

    mockValidationResult = {
      isValid: false,
      schemaId: 'test-schema',
      schemaType: SchemaType.XSD,
      issues: [
        {
          id: 'issue-1',
          type: ValidationIssueType.SYNTAX_ERROR,
          severity: ValidationSeverity.ERROR,
          message: '테스트 에러 메시지',
          description: '테스트 에러 설명',
          location: { path: 'test.path' },
          suggestion: '테스트 제안'
        },
        {
          id: 'issue-2',
          type: ValidationIssueType.REFERENCE_ERROR,
          severity: ValidationSeverity.WARNING,
          message: '테스트 경고 메시지',
          description: '테스트 경고 설명'
        }
      ],
      summary: {
        totalIssues: 2,
        errorCount: 1,
        warningCount: 1,
        infoCount: 0,
        validatedElements: 10,
        skippedElements: 0
      },
      executionTime: 100,
      timestamp: new Date()
    };
  });

  describe('generateReport', () => {
    it('기본 검증 리포트를 생성해야 합니다', async () => {
      const report = await generator.generateReport(mockSchema, [mockValidationResult]);

      expect(report).toBeDefined();
      expect(report.id).toBeDefined();
      expect(report.schemaId).toBe(mockSchema.id);
      expect(report.schemaName).toBe(mockSchema.name);
      expect(report.schemaType).toBe(mockSchema.type);
      expect(report.validationResults).toHaveLength(1);
      expect(report.overallStatus).toBe('invalid'); // 에러가 있으므로
      expect(report.summary.totalIssues).toBe(2);
      expect(report.summary.errorCount).toBe(1);
      expect(report.summary.warningCount).toBe(1);
    });

    it('유효한 스키마에 대해 valid 상태를 반환해야 합니다', async () => {
      const validResult = {
        ...mockValidationResult,
        isValid: true,
        issues: []
      };
      validResult.summary = {
        totalIssues: 0,
        errorCount: 0,
        warningCount: 0,
        infoCount: 0,
        validatedElements: 10,
        skippedElements: 0
      };

      const report = await generator.generateReport(mockSchema, [validResult]);

      expect(report.overallStatus).toBe('valid');
      expect(report.summary.totalIssues).toBe(0);
    });

    it('경고만 있는 경우 warning 상태를 반환해야 합니다', async () => {
      const warningOnlyResult = {
        ...mockValidationResult,
        isValid: true,
        issues: [
          {
            id: 'warning-1',
            type: ValidationIssueType.NAMESPACE_CONFLICT,
            severity: ValidationSeverity.WARNING,
            message: '경고 메시지'
          }
        ]
      };
      warningOnlyResult.summary = {
        totalIssues: 1,
        errorCount: 0,
        warningCount: 1,
        infoCount: 0,
        validatedElements: 10,
        skippedElements: 0
      };

      const report = await generator.generateReport(mockSchema, [warningOnlyResult]);

      expect(report.overallStatus).toBe('warning');
    });
  });

  describe('generateHTMLReport', () => {
    it('HTML 리포트를 생성해야 합니다', async () => {
      const report = await generator.generateReport(mockSchema, [mockValidationResult]);
      const htmlReport = await generator.generateHTMLReport(report);

      expect(htmlReport).toContain('<!DOCTYPE html>');
      expect(htmlReport).toContain(mockSchema.name);
      expect(htmlReport).toContain('테스트 에러 메시지');
      expect(htmlReport).toContain('테스트 경고 메시지');
    });
  });

  describe('generateJSONReport', () => {
    it('JSON 리포트를 생성해야 합니다', async () => {
      const report = await generator.generateReport(mockSchema, [mockValidationResult]);
      const jsonReport = await generator.generateJSONReport(report);

      expect(() => JSON.parse(jsonReport)).not.toThrow();
      
      const parsedReport = JSON.parse(jsonReport);
      expect(parsedReport.schemaId).toBe(mockSchema.id);
      expect(parsedReport.validationResults).toHaveLength(1);
    });
  });

  describe('generateCSVReport', () => {
    it('CSV 리포트를 생성해야 합니다', async () => {
      const report = await generator.generateReport(mockSchema, [mockValidationResult]);
      const csvReport = await generator.generateCSVReport(report);

      expect(csvReport).toContain('ID,타입,심각도,메시지,설명,위치,제안');
      expect(csvReport).toContain('issue-1');
      expect(csvReport).toContain('issue-2');
      expect(csvReport).toContain('테스트 에러 메시지');
    });
  });
});