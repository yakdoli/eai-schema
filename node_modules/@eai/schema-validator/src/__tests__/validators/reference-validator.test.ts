import { ReferenceValidator } from '../../validators/reference-validator';
import { UnifiedSchema, SchemaType } from '@eai/shared';

describe('ReferenceValidator', () => {
  let validator: ReferenceValidator;
  let mockSchema: UnifiedSchema;

  beforeEach(() => {
    validator = new ReferenceValidator();
    mockSchema = {
      id: 'test-schema',
      name: 'Test Schema',
      type: SchemaType.XSD,
      version: '1.0.0',
      originalFormat: 'application/xml',
      metadata: {
        targetNamespace: 'http://example.com/test',
        imports: []
      },
      content: {
        entities: [
          {
            name: 'User',
            properties: [
              {
                name: 'id',
                type: 'string',
                isRequired: true,
                constraints: []
              },
              {
                name: 'profile',
                type: 'Profile', // 정의된 타입 참조
                isRequired: false,
                constraints: []
              }
            ],
            relationships: [],
            constraints: []
          },
          {
            name: 'Profile',
            properties: [
              {
                name: 'name',
                type: 'string',
                isRequired: true,
                constraints: []
              }
            ],
            relationships: [],
            constraints: []
          }
        ],
        types: [],
        operations: [],
        bindings: []
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  });

  describe('validateReferences', () => {
    it('유효한 참조에 대해 빈 결과를 반환해야 합니다', async () => {
      const result = await validator.validateReferences(mockSchema);

      expect(result.missingReferences).toHaveLength(0);
      expect(result.circularReferences).toHaveLength(0);
      expect(result.unresolvedImports).toHaveLength(0);
    });

    it('누락된 참조를 감지해야 합니다', async () => {
      const schemaWithMissingRef = { ...mockSchema };
      schemaWithMissingRef.content.entities[0].properties.push({
        name: 'address',
        type: 'Address', // 정의되지 않은 타입
        isRequired: false,
        constraints: []
      });

      const result = await validator.validateReferences(schemaWithMissingRef);

      expect(result.missingReferences.length).toBeGreaterThan(0);
      expect(result.missingReferences[0].targetReference).toBe('Address');
      expect(result.missingReferences[0].referencingElement).toBe('User.address');
    });

    it('순환 참조를 감지해야 합니다', async () => {
      const schemaWithCircularRef = { ...mockSchema };
      // Profile이 User를 참조하도록 설정 (User -> Profile -> User)
      schemaWithCircularRef.content.entities[1].properties.push({
        name: 'user',
        type: 'User',
        isRequired: false,
        constraints: []
      });

      const result = await validator.validateReferences(schemaWithCircularRef);

      expect(result.circularReferences.length).toBeGreaterThan(0);
    });

    it('해결되지 않은 임포트를 감지해야 합니다', async () => {
      const schemaWithUnresolvedImport = { ...mockSchema };
      schemaWithUnresolvedImport.metadata.imports = [
        {
          namespace: 'http://example.com/missing',
          location: 'missing-schema.xsd'
        }
      ];

      const result = await validator.validateReferences(schemaWithUnresolvedImport);

      expect(result.unresolvedImports.length).toBeGreaterThan(0);
    });

    it('내장 타입은 누락된 참조로 간주하지 않아야 합니다', async () => {
      const schemaWithBuiltInTypes = { ...mockSchema };
      schemaWithBuiltInTypes.content.entities[0].properties = [
        { name: 'stringField', type: 'string', isRequired: false, constraints: [] },
        { name: 'numberField', type: 'number', isRequired: false, constraints: [] },
        { name: 'xsStringField', type: 'xs:string', isRequired: false, constraints: [] },
        { name: 'xsdIntField', type: 'xsd:int', isRequired: false, constraints: [] }
      ];

      const result = await validator.validateReferences(schemaWithBuiltInTypes);

      expect(result.missingReferences).toHaveLength(0);
    });
  });
});