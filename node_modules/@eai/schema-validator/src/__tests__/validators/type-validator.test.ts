import { TypeValidator } from '../../validators/type-validator';
import { UnifiedSchema, SchemaType } from '@eai/shared';
import { ValidationSeverity } from '../../types';

describe('TypeValidator', () => {
  let validator: TypeValidator;
  let mockSchema: UnifiedSchema;

  beforeEach(() => {
    validator = new TypeValidator();
    mockSchema = {
      id: 'test-schema',
      name: 'Test Schema',
      type: SchemaType.XSD,
      version: '1.0.0',
      originalFormat: 'application/xml',
      metadata: {
        targetNamespace: 'http://example.com/test'
      },
      content: {
        entities: [
          {
            name: 'TestEntity',
            properties: [
              {
                name: 'stringField',
                type: 'string',
                isRequired: true,
                constraints: [
                  { type: 'minLength', value: 1 },
                  { type: 'maxLength', value: 100 }
                ]
              },
              {
                name: 'numberField',
                type: 'number',
                isRequired: false,
                constraints: [
                  { type: 'minValue', value: 0 },
                  { type: 'maxValue', value: 1000 }
                ]
              }
            ],
            relationships: [],
            constraints: []
          }
        ],
        types: [
          {
            name: 'CustomString',
            baseType: 'string',
            isComplex: false,
            restrictions: [],
            facets: []
          }
        ],
        operations: [],
        bindings: []
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  });

  describe('validateTypes', () => {
    it('유효한 타입 정의에 대해 빈 결과를 반환해야 합니다', async () => {
      const result = await validator.validateTypes(mockSchema);

      expect(result.incompatibleTypes).toHaveLength(0);
      expect(result.missingTypes).toHaveLength(0);
      expect(result.invalidConstraints).toHaveLength(0);
    });

    it('정의되지 않은 타입 참조를 감지해야 합니다', async () => {
      const schemaWithMissingType = { ...mockSchema };
      schemaWithMissingType.content.entities[0].properties.push({
        name: 'customField',
        type: 'UndefinedType',
        isRequired: false,
        constraints: []
      });

      const result = await validator.validateTypes(schemaWithMissingType);

      expect(result.missingTypes.length).toBeGreaterThan(0);
      expect(result.missingTypes[0].typeName).toBe('UndefinedType');
    });

    it('잘못된 제약조건을 감지해야 합니다', async () => {
      const schemaWithInvalidConstraints = { ...mockSchema };
      schemaWithInvalidConstraints.content.entities[0].properties[0].constraints = [
        { type: 'minLength', value: 100 }, // minLength > maxLength
        { type: 'maxLength', value: 50 }
      ];

      const result = await validator.validateTypes(schemaWithInvalidConstraints);

      expect(result.invalidConstraints.length).toBeGreaterThan(0);
    });

    it('타입 불일치를 감지해야 합니다', async () => {
      const schemaWithTypeIncompatibility = { ...mockSchema };
      // 문자열 타입에 숫자 제약조건 적용
      schemaWithTypeIncompatibility.content.entities[0].properties[0].constraints = [
        { type: 'minValue', value: 0 } // 문자열 타입에 숫자 제약조건
      ];

      const result = await validator.validateTypes(schemaWithTypeIncompatibility);

      expect(result.invalidConstraints.length).toBeGreaterThan(0);
      expect(result.invalidConstraints[0].reason).toContain('숫자 타입에만 적용');
    });

    it('순환 상속을 감지해야 합니다', async () => {
      const schemaWithCircularInheritance = { ...mockSchema };
      schemaWithCircularInheritance.content.types = [
        {
          name: 'TypeA',
          baseType: 'TypeB',
          isComplex: false,
          restrictions: [],
          facets: []
        },
        {
          name: 'TypeB',
          baseType: 'TypeA', // 순환 상속
          isComplex: false,
          restrictions: [],
          facets: []
        }
      ];

      const result = await validator.validateTypes(schemaWithCircularInheritance);

      expect(result.incompatibleTypes.length).toBeGreaterThan(0);
      expect(result.incompatibleTypes.some(i => i.reason.includes('순환 상속'))).toBe(true);
    });

    it('유효하지 않은 정규식 패턴을 감지해야 합니다', async () => {
      const schemaWithInvalidPattern = { ...mockSchema };
      schemaWithInvalidPattern.content.entities[0].properties[0].constraints = [
        { type: 'pattern', value: '[invalid regex(' } // 잘못된 정규식
      ];

      const result = await validator.validateTypes(schemaWithInvalidPattern);

      expect(result.invalidConstraints.length).toBeGreaterThan(0);
      expect(result.invalidConstraints[0].reason).toContain('정규식 패턴');
    });

    it('내장 타입들을 올바르게 인식해야 합니다', async () => {
      const schemaWithBuiltInTypes = { ...mockSchema };
      schemaWithBuiltInTypes.content.entities[0].properties = [
        { name: 'stringField', type: 'string', isRequired: false, constraints: [] },
        { name: 'numberField', type: 'number', isRequired: false, constraints: [] },
        { name: 'xsStringField', type: 'xs:string', isRequired: false, constraints: [] },
        { name: 'xsdIntField', type: 'xsd:int', isRequired: false, constraints: [] }
      ];

      const result = await validator.validateTypes(schemaWithBuiltInTypes);

      expect(result.missingTypes).toHaveLength(0);
    });
  });
});