import { SyntaxValidator } from '../../validators/syntax-validator';
import { UnifiedSchema, SchemaType } from '@eai/shared';
import { ValidationSeverity } from '../../types';

describe('SyntaxValidator', () => {
  let validator: SyntaxValidator;
  let mockSchema: UnifiedSchema;

  beforeEach(() => {
    validator = new SyntaxValidator();
    mockSchema = {
      id: 'test-schema',
      name: 'Test Schema',
      type: SchemaType.XSD,
      version: '1.0.0',
      originalFormat: 'application/xml',
      metadata: {
        targetNamespace: 'http://example.com/test'
      },
      content: {
        entities: [
          {
            name: 'TestEntity',
            properties: [
              {
                name: 'id',
                type: 'string',
                isRequired: true,
                constraints: []
              }
            ],
            relationships: [],
            constraints: []
          }
        ],
        types: [
          {
            name: 'TestType',
            baseType: 'string',
            isComplex: false,
            restrictions: [],
            facets: []
          }
        ],
        operations: [],
        bindings: []
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  });

  describe('validateSyntax', () => {
    it('유효한 스키마를 성공적으로 검증해야 합니다', async () => {
      const result = await validator.validateSyntax(mockSchema);

      expect(result.isValid).toBe(true);
      expect(result.issues).toHaveLength(0);
      expect(result.summary.errorCount).toBe(0);
    });

    it('스키마 ID가 누락된 경우 에러를 반환해야 합니다', async () => {
      const invalidSchema = { ...mockSchema, id: '' };

      const result = await validator.validateSyntax(invalidSchema);

      expect(result.isValid).toBe(false);
      expect(result.issues.some(i => 
        i.severity === ValidationSeverity.ERROR && 
        i.message.includes('스키마 ID')
      )).toBe(true);
    });

    it('스키마 이름이 누락된 경우 에러를 반환해야 합니다', async () => {
      const invalidSchema = { ...mockSchema, name: '' };

      const result = await validator.validateSyntax(invalidSchema);

      expect(result.isValid).toBe(false);
      expect(result.issues.some(i => 
        i.severity === ValidationSeverity.ERROR && 
        i.message.includes('스키마 이름')
      )).toBe(true);
    });

    it('엔티티 이름이 누락된 경우 에러를 반환해야 합니다', async () => {
      const invalidSchema = { ...mockSchema };
      invalidSchema.content.entities[0].name = '';

      const result = await validator.validateSyntax(invalidSchema);

      expect(result.isValid).toBe(false);
      expect(result.issues.some(i => 
        i.severity === ValidationSeverity.ERROR && 
        i.message.includes('엔티티 이름')
      )).toBe(true);
    });

    it('속성 타입이 누락된 경우 에러를 반환해야 합니다', async () => {
      const invalidSchema = { ...mockSchema };
      invalidSchema.content.entities[0].properties[0].type = '';

      const result = await validator.validateSyntax(invalidSchema);

      expect(result.isValid).toBe(false);
      expect(result.issues.some(i => 
        i.severity === ValidationSeverity.ERROR && 
        i.message.includes('속성 타입')
      )).toBe(true);
    });
  });

  describe('WSDL 특화 검증', () => {
    it('WSDL 스키마의 오퍼레이션이 누락된 경우 에러를 반환해야 합니다', async () => {
      const wsdlSchema = { ...mockSchema, type: SchemaType.WSDL };
      wsdlSchema.content.operations = [];

      const result = await validator.validateSyntax(wsdlSchema);

      expect(result.issues.some(i => 
        i.message.includes('오퍼레이션 정의가 누락')
      )).toBe(true);
    });
  });

  describe('JSON Schema 특화 검증', () => {
    it('JSON Schema의 타입 정의가 누락된 경우 에러를 반환해야 합니다', async () => {
      const jsonSchema = { ...mockSchema, type: SchemaType.JSON_SCHEMA };
      jsonSchema.content.types = [];

      const result = await validator.validateSyntax(jsonSchema);

      expect(result.issues.some(i => 
        i.message.includes('타입 정의가 누락')
      )).toBe(true);
    });
  });
});