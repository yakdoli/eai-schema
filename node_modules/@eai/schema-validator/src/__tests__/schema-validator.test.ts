import { SchemaValidator } from '../schema-validator';
import { UnifiedSchema, SchemaType } from '@eai/shared';
import { ValidationSeverity, ValidationOptions } from '../types';

describe('SchemaValidator', () => {
  let validator: SchemaValidator;
  let mockSchema: UnifiedSchema;

  beforeEach(() => {
    validator = new SchemaValidator();
    mockSchema = {
      id: 'test-schema-1',
      name: 'Test Schema',
      type: SchemaType.XSD,
      version: '1.0.0',
      originalFormat: 'application/xml',
      metadata: {
        targetNamespace: 'http://example.com/test',
        imports: [],
        annotations: []
      },
      content: {
        entities: [
          {
            name: 'TestEntity',
            properties: [
              {
                name: 'id',
                type: 'string',
                isRequired: true,
                constraints: []
              },
              {
                name: 'name',
                type: 'string',
                isRequired: false,
                constraints: []
              }
            ],
            relationships: [],
            constraints: []
          }
        ],
        types: [
          {
            name: 'CustomType',
            baseType: 'string',
            isComplex: false,
            restrictions: [],
            facets: []
          }
        ],
        operations: [],
        bindings: []
      },
      sourceSchema: {} as any,
      conversionMetadata: {
        sourceType: SchemaType.XSD,
        targetType: SchemaType.XSD,
        conversionTime: 0,
        rulesApplied: [],
        warnings: [],
        lossyConversion: false,
        fidelityScore: 100
      },
      validationResult: {
        isValid: true,
        errors: [],
        warnings: [],
        infos: []
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  });

  describe('validate', () => {
    it('유효한 스키마를 성공적으로 검증해야 합니다', async () => {
      const result = await validator.validate(mockSchema);

      expect(result.isValid).toBe(true);
      expect(result.schemaId).toBe(mockSchema.id);
      expect(result.schemaType).toBe(mockSchema.type);
      expect(result.issues).toHaveLength(0);
      expect(result.summary.errorCount).toBe(0);
    });

    it('잘못된 스키마에 대해 에러를 반환해야 합니다', async () => {
      const invalidSchema = { ...mockSchema };
      invalidSchema.content.entities[0].name = ''; // 빈 이름

      const result = await validator.validate(invalidSchema);

      expect(result.isValid).toBe(false);
      expect(result.issues.length).toBeGreaterThan(0);
      expect(result.summary.errorCount).toBeGreaterThan(0);
    });

    it('검증 옵션을 적용해야 합니다', async () => {
      const options: ValidationOptions = {
        skipWarnings: true,
        maxIssues: 5,
        validateReferences: false
      };

      const result = await validator.validate(mockSchema, options);

      expect(result.issues.every(i => i.severity !== ValidationSeverity.WARNING)).toBe(true);
    });
  });

  describe('validateSyntax', () => {
    it('구문 검증을 수행해야 합니다', async () => {
      const result = await validator.validateSyntax(mockSchema);

      expect(result).toBeDefined();
      expect(result.schemaId).toBe(mockSchema.id);
      expect(result.schemaType).toBe(mockSchema.type);
    });

    it('구문 오류를 감지해야 합니다', async () => {
      const invalidSchema = { ...mockSchema };
      invalidSchema.id = ''; // 잘못된 ID

      const result = await validator.validateSyntax(invalidSchema);

      expect(result.isValid).toBe(false);
      expect(result.issues.some(i => i.type === 'syntax_error')).toBe(true);
    });
  });

  describe('validateReferences', () => {
    it('참조 무결성을 검증해야 합니다', async () => {
      const result = await validator.validateReferences(mockSchema);

      expect(result).toBeDefined();
      expect(result.missingReferences).toBeDefined();
      expect(result.circularReferences).toBeDefined();
      expect(result.unresolvedImports).toBeDefined();
    });

    it('누락된 참조를 감지해야 합니다', async () => {
      const schemaWithMissingRef = { ...mockSchema };
      schemaWithMissingRef.content.entities[0].properties.push({
        name: 'missingTypeField',
        type: 'NonExistentType',
        isRequired: false,
        constraints: []
      });

      const result = await validator.validateReferences(schemaWithMissingRef);

      expect(result.missingReferences.length).toBeGreaterThan(0);
    });
  });

  describe('validateNamespaces', () => {
    it('네임스페이스 검증을 수행해야 합니다', async () => {
      const result = await validator.validateNamespaces(mockSchema);

      expect(result).toBeDefined();
      expect(result.conflicts).toBeDefined();
      expect(result.duplicateDeclarations).toBeDefined();
      expect(result.ambiguousReferences).toBeDefined();
    });
  });

  describe('validateTypes', () => {
    it('타입 호환성을 검증해야 합니다', async () => {
      const result = await validator.validateTypes(mockSchema);

      expect(result).toBeDefined();
      expect(result.incompatibleTypes).toBeDefined();
      expect(result.missingTypes).toBeDefined();
      expect(result.invalidConstraints).toBeDefined();
    });
  });

  describe('generateReport', () => {
    it('검증 리포트를 생성해야 합니다', async () => {
      const validationResult = await validator.validate(mockSchema);
      const report = await validator.generateReport([validationResult]);

      expect(report).toBeDefined();
      expect(report.schemaId).toBe(mockSchema.id);
      expect(report.validationResults).toHaveLength(1);
      expect(report.summary).toBeDefined();
      expect(report.overallStatus).toBeDefined();
    });
  });

  describe('validateAndGenerateReport', () => {
    it('통합 검증 및 리포트 생성을 수행해야 합니다', async () => {
      const report = await validator.validateAndGenerateReport(mockSchema);

      expect(report).toBeDefined();
      expect(report.schemaId).toBe(mockSchema.id);
      expect(report.schemaName).toBe(mockSchema.name);
      expect(report.schemaType).toBe(mockSchema.type);
      expect(report.executionTime).toBeGreaterThanOrEqual(0);
    });
  });

  describe('validateBatch', () => {
    it('여러 스키마를 배치로 검증해야 합니다', async () => {
      const schema2 = { ...mockSchema, id: 'test-schema-2', name: 'Test Schema 2' };
      const schemas = [mockSchema, schema2];

      const reports = await validator.validateBatch(schemas);

      expect(reports).toHaveLength(2);
      expect(reports[0].schemaId).toBe(mockSchema.id);
      expect(reports[1].schemaId).toBe(schema2.id);
    });
  });

  describe('generateValidationStatistics', () => {
    it('검증 통계를 생성해야 합니다', async () => {
      const report1 = await validator.validateAndGenerateReport(mockSchema);
      const report2 = await validator.validateAndGenerateReport({
        ...mockSchema,
        id: 'test-schema-2'
      });

      const stats = validator.generateValidationStatistics([report1, report2]);

      expect(stats.totalSchemas).toBe(2);
      expect(stats.validSchemas).toBeGreaterThanOrEqual(0);
      expect(stats.invalidSchemas).toBeGreaterThanOrEqual(0);
      expect(stats.averageExecutionTime).toBeGreaterThanOrEqual(0);
    });
  });
});